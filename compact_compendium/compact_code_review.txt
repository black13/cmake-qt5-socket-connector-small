=== NodeGraph Compact Code Review Package ===
Generated: Fri Aug 22 16:08:13 CDT 2025

This is a focused code review package containing only the core functionality.

=== main.cpp ===

#include <QApplication>
#include <QCommandLineParser>
#include <QCommandLineOption>
#include <QFileInfo>
#include <QDebug>
#include <QLoggingCategory>
#include <QStandardPaths>
#include <QDir>
#include <QTextStream>
#include <QDateTime>
#include <QMutex>
#include <QTimer>
#include <QMessageBox>
#include <QJSValue>
#include <iostream>
#include "window.h"
#include "scene.h"
#include "node.h"
#include "edge.h"
#include "graph_factory.h"
#include "node_registry.h"
#include "javascript_engine.h"
#include "template_registry.h"
#include "script_executor.h"

void setupLogging()
{
    // Create logs directory if it doesn't exist
    QDir logsDir("logs");
    if (!logsDir.exists()) {
        logsDir.mkpath(".");
    }
    
    // Create timestamped log file
    QString timestamp = QDateTime::currentDateTime().toString("yyyy-MM-dd_hh-mm-ss");
    QString logFileName = QString("logs/NodeGraph_%1.log").arg(timestamp);
    
    // Redirect Qt debug output to file
    static QFile debugFile(logFileName);
    debugFile.open(QIODevice::WriteOnly | QIODevice::Append);
    static QTextStream stream(&debugFile);
    
    qInstallMessageHandler([](QtMsgType type, const QMessageLogContext &context, const QString &msg) {
        QString timestamp = QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss.zzz");
        QString typeStr;
        
        switch (type) {
        case QtDebugMsg:    typeStr = "DEBUG"; break;
        case QtInfoMsg:     typeStr = "INFO "; break;
        case QtWarningMsg:  typeStr = "WARN "; break;
        case QtCriticalMsg: typeStr = "ERROR"; break;
        case QtFatalMsg:    typeStr = "FATAL"; break;
        }
        
        QString logEntry = QString("[%1] %2: %3").arg(timestamp, typeStr, msg);
        
        // Write to main log
        stream << logEntry << Qt::endl;
        stream.flush();
        
        // Write JavaScript-related messages to separate JS log
        if (msg.contains("JavaScript", Qt::CaseInsensitive) || 
            msg.contains("Script", Qt::CaseInsensitive) ||
            msg.contains("QJSEngine", Qt::CaseInsensitive) ||
            msg.contains("JS_ERROR", Qt::CaseInsensitive) ||
            msg.contains("JS_EXECUTION", Qt::CaseInsensitive)) {
            
            static QFile jsLogFile(QString("logs/JavaScript_%1.log").arg(QDateTime::currentDateTime().toString("yyyy-MM-dd_hh-mm-ss")));
            if (!jsLogFile.isOpen()) {
                jsLogFile.open(QIODevice::WriteOnly | QIODevice::Append);
            }
            
            if (jsLogFile.isOpen()) {
                QTextStream jsStream(&jsLogFile);
                jsStream << logEntry << Qt::endl;
                jsStream.flush();
            }
        }
    });
    
    qDebug() << "=== NodeGraph Application Started ===";
    qDebug() << "Log file:" << logFileName;
    qDebug() << "Timestamp:" << QDateTime::currentDateTime().toString();
}

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    
    // Setup file logging
    setupLogging();
    
    
    // Set application metadata for Qt command line tools
    QCoreApplication::setApplicationName("NodeGraph");
    QCoreApplication::setApplicationVersion("1.0.0");
    QCoreApplication::setOrganizationName("NodeGraph Project");
    // setApplicationDisplayName not available in Qt 5.x on all platforms
    
    // Setup Qt5 command line parser
    QCommandLineParser parser;
    parser.setApplicationDescription("A self-serializing node graph editor with libxml2 backend");
    parser.addHelpOption();
    parser.addVersionOption();
    
    // Add file loading option
    QCommandLineOption loadFileOption(QStringList() << "l" << "load",
                                      "Load graph from XML file",
                                      "file");
    parser.addOption(loadFileOption);
    
    // Add CLI scripting options
    QCommandLineOption scriptOption(QStringList() << "s" << "script",
                                    "Execute JavaScript file and exit",
                                    "script_file");
    parser.addOption(scriptOption);
    
    QCommandLineOption evalOption(QStringList() << "e" << "eval",
                                  "Execute JavaScript code and exit",
                                  "code");
    parser.addOption(evalOption);
    
    
    
    // Add positional argument for file
    parser.addPositionalArgument("file", "XML file to load (optional)");
    
    // Process command line arguments
    parser.process(app);
    
    // Handle CLI scripting options (execute and exit)
    if (parser.isSet(scriptOption) || parser.isSet(evalOption)) {
        qDebug() << "CLI scripting mode detected";
        
        // Create minimal scene for JavaScript execution
        Scene cliScene;
        
        // Initialize JavaScript engine for CLI
        JavaScriptEngine* jsEngine = cliScene.getJavaScriptEngine();
        if (!jsEngine) {
            qCritical() << "Failed to initialize JavaScript engine for CLI scripting";
            return -1;
        }
        
        // Execute script or code
        bool success = false;
        if (parser.isSet(scriptOption)) {
            QString scriptFile = parser.value(scriptOption);
            qDebug() << "Executing script file:" << scriptFile;
            QJSValue result = jsEngine->evaluateFile(scriptFile);
            success = !result.isError();
            if (!success) {
                std::cerr << "Script error: " << result.toString().toStdString() << std::endl;
            }
        } else if (parser.isSet(evalOption)) {
            QString code = parser.value(evalOption);
            qDebug() << "Executing JavaScript code:" << code;
            QJSValue result = jsEngine->evaluate(code);
            success = !result.isError();
            if (success) {
                std::cout << "Result: " << result.toString().toStdString() << std::endl;
            } else {
                std::cerr << "Error: " << result.toString().toStdString() << std::endl;
            }
        }
        
        qDebug() << "CLI scripting completed, success:" << success;
        return success ? 0 : -1;
    }
    
    // Command line parsing
    
    // Create main window
    // qDebug() << "=== STEP 1: Creating Window (BEFORE node registration) ===";
    qDebug() << "NodeRegistry types at window creation:" << NodeRegistry::instance().getRegisteredTypes().size();
    Window window;
    qDebug() << "Window created successfully";
    
    // Initialize JavaScript engine
    // qDebug() << "=== STEP 2: Initializing JavaScript Engine (BEFORE node registration) ===";
    qDebug() << "NodeRegistry types before JS engine:" << NodeRegistry::instance().getRegisteredTypes().size();
    Scene* scene = window.getScene();
    if (scene) {
        auto* jsEngine = scene->getJavaScriptEngine();
        if (!jsEngine) {
            qDebug() << "Warning: JavaScript engine initialization failed";
        } else {
            qDebug() << "JavaScript engine initialized successfully";
            qDebug() << "NodeRegistry types after JS engine init:" << NodeRegistry::instance().getRegisteredTypes().size();
            
            // MANDATORY EXECUTION TEST: Comprehensive JavaScript verification
            if (!jsEngine->runMandatoryExecutionTest()) {
                qCritical() << "CRITICAL: JavaScript engine failed mandatory execution test";
                qCritical() << "CRITICAL: Application may not function correctly";
            }
            
            // MANDATORY SYSTEM CHECK: Template system and core functionality
            QString systemCheckPath = "scripts/system_check.js";
            if (QFile::exists(systemCheckPath)) {
                qDebug() << "Running mandatory system validation:" << systemCheckPath;
                QJSValue result = jsEngine->evaluateFile(systemCheckPath);
                if (result.isError()) {
                    qCritical() << "CRITICAL: System validation failed - core functionality may be impaired";
                    qCritical() << "Error:" << result.toString();
                }
            } else {
                qWarning() << "System check script not found:" << systemCheckPath;
            }
        }
    }
    
    // Handle file loading
    QString filename;
    if (parser.isSet(loadFileOption)) {
        filename = parser.value(loadFileOption);
    } else {
        const QStringList positionalArgs = parser.positionalArguments();
        if (!positionalArgs.isEmpty()) {
            filename = positionalArgs.first();
        }
    }
    
    // Store information about file loading status for user notification
    bool fileLoadAttempted = !filename.isEmpty();
    QString originalFilename = filename; // Store original filename for user message
    
    // Create empty XML document for GraphFactory
    // GraphFactory will handle all file loading - single XML authority
    // qDebug() << "=== Creating Empty XML Document ===";
    xmlDocPtr xmlDoc = xmlNewDoc(BAD_CAST "1.0");
    xmlNodePtr root = xmlNewNode(nullptr, BAD_CAST "graph");
    xmlDocSetRootElement(xmlDoc, root);
    
    xmlSetProp(root, BAD_CAST "version", BAD_CAST "1.0");
    xmlSetProp(root, BAD_CAST "xmlns", BAD_CAST "http://nodegraph.org/schema");
    
    qDebug() << "Empty XML document created - GraphFactory will handle file loading";
    
    // Register all supported node types
    // qDebug() << "=== STEP 3: Registering Node Types (AFTER window/JS engine creation) ===";
    qDebug() << "NodeRegistry types BEFORE registration:" << NodeRegistry::instance().getRegisteredTypes().size();
    qDebug() << "Starting node type registration process...";
    
    // Core node types
    NodeRegistry::instance().registerNode("IN", []() { 
        Node* node = new Node(); 
        node->setNodeType("IN"); 
        return node; 
    });
    // qDebug() << "Registered: IN (count now:" << NodeRegistry::instance().getRegisteredTypes().size() << ")"
    
    NodeRegistry::instance().registerNode("OUT", []() { 
        Node* node = new Node(); 
        node->setNodeType("OUT"); 
        return node; 
    });
    // qDebug() << "Registered: OUT (count now:" << NodeRegistry::instance().getRegisteredTypes().size() << ")"
    
    NodeRegistry::instance().registerNode("PROC", []() { 
        Node* node = new Node(); 
        node->setNodeType("PROC"); 
        return node; 
    });
    // qDebug() << "Registered: PROC (count now:" << NodeRegistry::instance().getRegisteredTypes().size() << ")"
    
    // Palette node types - each with proper type designation
    NodeRegistry::instance().registerNode("SOURCE", []() { 
        Node* node = new Node(); 
        node->setNodeType("SOURCE"); 
        return node; 
    });
    // qDebug() << "Registered: SOURCE (count now:" << NodeRegistry::instance().getRegisteredTypes().size() << ")"
    
    NodeRegistry::instance().registerNode("SINK", []() { 
        Node* node = new Node(); 
        node->setNodeType("SINK"); 
        return node; 
    });
    // qDebug() << "Registered: SINK (count now:" << NodeRegistry::instance().getRegisteredTypes().size() << ")"
    
    NodeRegistry::instance().registerNode("TRANSFORM", []() { 
        Node* node = new Node(); 
        node->setNodeType("TRANSFORM"); 
        return node; 
    });
    // qDebug() << "Registered: TRANSFORM (count now:" << NodeRegistry::instance().getRegisteredTypes().size() << ")"
    
    NodeRegistry::instance().registerNode("MERGE", []() { 
        Node* node = new Node(); 
        node->setNodeType("MERGE"); 
        return node; 
    });
    // qDebug() << "Registered: MERGE (count now:" << NodeRegistry::instance().getRegisteredTypes().size() << ")"
    
    NodeRegistry::instance().registerNode("SPLIT", []() { 
        Node* node = new Node(); 
        node->setNodeType("SPLIT"); 
        return node; 
    });
    // qDebug() << "Registered: SPLIT (count now:" << NodeRegistry::instance().getRegisteredTypes().size() << ")"
    
    // Legacy compatibility for older tests
    NodeRegistry::instance().registerNode("PROCESSOR", []() { 
        Node* node = new Node(); 
        node->setNodeType("PROCESSOR"); 
        return node; 
    });
    // qDebug() << "Registered: PROCESSOR (count now:" << NodeRegistry::instance().getRegisteredTypes().size() << ")"
    
    QStringList registeredTypes = NodeRegistry::instance().getRegisteredTypes();

    // Test the NodeRegistry to verify nodes are registered
    qDebug() << "=== NodeGraph Application Starting ===";
    qDebug() << "Registered node types:" << NodeRegistry::instance().getRegisteredTypes();
    qDebug() << "Total registered types:" << registeredTypes.size();
    // qDebug() << "=== Logging each registered type ===";
    for (int i = 0; i < registeredTypes.size(); ++i) {
        qDebug() << QString("  [%1] \"%2\"").arg(i + 1).arg(registeredTypes[i]);
    }
    // qDebug() << "======================================";
    
    // Initialize GraphFactory with scene and XML document
    // Scene* scene = window.getScene(); // Already declared above
    if (!scene) {
        qCritical() << "✗ Failed to get scene from window";
        return -1;
    }
    
    GraphFactory factory(scene, xmlDoc);
    qDebug() << "GraphFactory initialized with empty XML document";
    
    // Initialize TemplateRegistry and load templates
    TemplateRegistry templateRegistry;
    QString templatePath = "node_templates.xml";
    if (QFile::exists(templatePath)) {
        if (templateRegistry.loadFromXmlFile(templatePath)) {
            qDebug() << "TemplateRegistry loaded" << templateRegistry.templateCount() << "templates";
            factory.setTemplateRegistry(&templateRegistry);
            qDebug() << "GraphFactory configured with TemplateRegistry";
        } else {
            qWarning() << "Failed to load templates from" << templatePath;
        }
    } else {
        qWarning() << "Template file not found:" << templatePath << "- using legacy node creation";
    }
    
    if (!filename.isEmpty()) {
        // GraphFactory is now the single XML authority
        qDebug() << "Loading file via GraphFactory:" << filename;
        if (!factory.loadFromXmlFile(filename)) {
            qCritical() << "GraphFactory failed to load XML file:" << filename;
            if (fileLoadAttempted) {
                qDebug() << "Original filename was:" << originalFilename;
            }
            return -1;
        }
        
        qDebug() << "Graph loaded successfully from file via GraphFactory:" << filename;
        
    } else {
        qDebug() << "Starting with empty graph - no file specified";
        // qDebug() << "=== Starting with Empty Graph ===";
        qDebug() << "No file specified - application will start with clean scene";
        qDebug() << "  Users can create nodes manually or load XML files via Ctrl+L";
    }
    
    // qDebug() << "=== XML-First Architecture Test Complete ===";
    
    // Set current file if we loaded from command line
    if (!filename.isEmpty()) {
        window.setCurrentFile(filename);
        qDebug() << "Command line file loaded - Ctrl+S will save to:" << filename;
    }
    
    // Cleanup XML document when done
    // Note: GraphFactory holds reference, so clean up after window closes
    
    window.show();
    
    
    // Show user-friendly message about file loading status
    if (fileLoadAttempted && originalFilename != filename) {
        // File was attempted but failed to load (filename was cleared)
        QTimer::singleShot(500, [&window, originalFilename]() {
            QMessageBox::information(&window, "File Not Found", 
                QString("The specified file could not be found or loaded:\n\n%1\n\nStarting with an empty graph instead.\n\nYou can create a new graph or open an existing file using File → Open.")
                .arg(originalFilename));
        });
    }
    
    int result = app.exec();
    
    // Final status before exit
    qDebug() << "=== NodeGraph Application Ending ===";
    
    // Cleanup XML document
    if (xmlDoc) {
        xmlFreeDoc(xmlDoc);
        qDebug() << "XML document cleaned up";
    }
    
    return result;
}

=== window.h ===

#pragma once

#include <QMainWindow>
#include <QString>
#include <QToolBar>
#include <QAction>
#include <QDockWidget>
#include <QLabel>
#include <QStatusBar>
#include <QMenuBar>
#include <QProgressBar>
#include <QSpinBox>
#include <QComboBox>
#include <libxml/tree.h>

class View;
class Scene;
class GraphFactory;
class XmlAutosaveObserver;
class NodePaletteWidget;
// class JavaScriptConsole;  // Disabled for now

/**
 * Window - Enhanced main window for self-serializing node editor
 * 
 * Features:
 * - Professional UI with dock widgets and status bar
 * - Node palette with drag-and-drop functionality
 * - Multi-section status bar with graph statistics
 * - Menu system with proper actions
 * - Integration with self-serializing architecture
 */
class Window : public QMainWindow
{
public:
    explicit Window(QWidget* parent = nullptr);
    ~Window();
    
    // Access to scene for testing
    Scene* getScene() const { return m_scene; }
    
    // Update status bar with current graph information
    void updateStatusBar();
    
    // Create node at specific position (disabled for now)
    // void createNodeAtPosition(const QString& nodeType, const QPointF& scenePos);
    
    // Note: JavaScript test methods removed - use CLI scripting:
    // ./NodeGraph --script path/to/script.js
    // ./NodeGraph --eval "JavaScript code here"

protected:
    // PHASE 3: Safe shutdown coordination
    void closeEvent(QCloseEvent* event) override;
public slots:
    // Scene event handlers
    void onSceneChanged();
    void onSelectionChanged();
    
    // Basic XML saving functionality
    bool saveGraph(const QString& filename);
    bool loadGraph(const QString& filename);
    
    // File management
    void setCurrentFile(const QString& filename);
    QString getCurrentFile() const { return m_currentFile; }
    
    // Interactive node creation
    void createInputNode();
    void createOutputNode();
    void createProcessorNode();
    
    // Node creation from palette (will be implemented with proper includes)
    void createNodeFromPalette(const QPointF& scenePos, const QString& nodeType, 
                              const QString& name, int inputSockets, int outputSockets);
    
private slots:
    // Menu actions
    void newFile();
    void openFile();
    void saveFile();
    void saveAsFile();
    void exportGraph();
    void showAbout();
    
    // View actions
    void zoomIn();
    void zoomOut();
    void zoomFit();
    void zoomReset();
    
    // Selection info update
    void updateSelectionInfo();
    
    // Palette integration
    void onNodeCreationRequested();
    
protected:
    // Handle keyboard shortcuts
    void keyPressEvent(QKeyEvent* event) override;

private:
    Scene* m_scene;
    View* m_view;
    GraphFactory* m_factory;
    xmlDocPtr m_xmlDocument;
    XmlAutosaveObserver* m_autosaveObserver;
    
    // UI elements
    QAction* m_addInputAction;
    QAction* m_addOutputAction;
    QAction* m_addProcessorAction;
    
    // Professional node palette system
    QDockWidget* m_nodePaletteDock;
    NodePaletteWidget* m_nodePalette;
    
    // JavaScript console (disabled for now)
    // QDockWidget* m_javaScriptConsoleDock;
    // JavaScriptConsole* m_javaScriptConsole;
    
    // Status bar components
    QLabel* m_fileInfoLabel;      // Current file info
    QLabel* m_graphStatsLabel;    // Node/edge count
    QLabel* m_selectionLabel;     // Selection information
    QLabel* m_positionLabel;      // Mouse position
    QLabel* m_zoomLabel;          // Current zoom level
    QProgressBar* m_operationProgress; // For long operations
    
    // Menu system
    QMenu* m_fileMenu;
    QMenu* m_editMenu;
    QMenu* m_viewMenu;
    QMenu* m_toolsMenu;
    QMenu* m_helpMenu;
    
    // File management
    QString m_currentFile;
    
    // Setup methods
    void setupUI();
    void setupMenus();
    void setupActions();
    void setupStatusBar();
    void setupDockWidgets();
    
    // Menu creation helpers
    void createFileMenu();
    void createEditMenu();
    void createViewMenu();
    void createToolsMenu();
    void createHelpMenu();
    
    // Status bar helpers
    void createStatusBarWidgets();
    void connectStatusBarSignals();
};

=== window.cpp ===

#include "window.h"
#include "view.h"
#include "scene.h"
#include "node.h"
#include "edge.h"
#include "graph_factory.h"
#include "xml_autosave_observer.h"
#include "javascript_engine.h"
#include "node_palette_widget.h"
// #include "javascript_console.h"  // Disabled for now
#include <QKeyEvent>
#include <QFileDialog>
#include <QMessageBox>
#include <QDebug>
#include <QElapsedTimer>
#include <QFileInfo>
#include <QAction>
#include <QIcon>
#include <QRandomGenerator>
#include <QDockWidget>
#include <QLabel>
#include <QStatusBar>
#include <QMenuBar>
#include <QProgressBar>
#include <QApplication>
#include <QDesktopServices>
#include <QUrl>
#include <QJSValue>
#include <libxml/tree.h>
#include <libxml/xmlsave.h>

Window::Window(QWidget* parent)
    : QMainWindow(parent)
    , m_scene(new Scene(this))
    , m_view(new View(m_scene, this))
{
    setWindowTitle("NodeGraph - Self-Serializing Node Editor");
    resize(1400, 900);
    
    // Initialize UI components to nullptr
    m_nodePaletteDock = nullptr;
    m_nodePalette = nullptr;
    // m_javaScriptConsoleDock = nullptr;
    // m_javaScriptConsole = nullptr;
    m_fileInfoLabel = nullptr;
    m_graphStatsLabel = nullptr;
    m_selectionLabel = nullptr;
    m_positionLabel = nullptr;
    m_zoomLabel = nullptr;
    m_operationProgress = nullptr;
    
    // Create XML document for factory
    m_xmlDocument = xmlNewDoc(BAD_CAST "1.0");
    xmlNodePtr root = xmlNewNode(nullptr, BAD_CAST "graph");
    xmlDocSetRootElement(m_xmlDocument, root);
    xmlSetProp(root, BAD_CAST "version", BAD_CAST "1.0");
    
    // Initialize factory for interactive node creation
    m_factory = new GraphFactory(m_scene, m_xmlDocument);
    
    // Initialize autosave observer for automatic XML saving
    m_autosaveObserver = new XmlAutosaveObserver(m_scene, "autosave.xml");
    m_autosaveObserver->setDelay(750); // 750ms delay after changes
    
    // CRITICAL: Attach observer to scene to receive notifications
    m_scene->attach(m_autosaveObserver);
    
    // Setup enhanced UI
    setupUI();
    setupActions();
    setupMenus();
    setupStatusBar();
    setupDockWidgets(); // JavaScript console disabled for now
    
    // Connect scene signals for status updates
    connect(m_scene, &Scene::sceneChanged, this, &Window::onSceneChanged);
    
    // Connect view signals for drag-and-drop
    connect(m_view, &View::nodeDropped, this, &Window::createNodeFromPalette);
    
    // Initial status update
    updateStatusBar();
    
    // Enable keyboard shortcuts
    setFocusPolicy(Qt::StrongFocus);
}

Window::~Window()
{
    // Clean up autosave observer
    if (m_autosaveObserver) {
        m_scene->detach(m_autosaveObserver);
        delete m_autosaveObserver;
    }
    
    // Clean up XML document
    if (m_xmlDocument) {
        xmlFreeDoc(m_xmlDocument);
        m_xmlDocument = nullptr;
    }
}

void Window::setupActions()
{
    // Create actions for node creation
    m_addInputAction = new QAction("Add Input", this);
    m_addInputAction->setToolTip("Add Input Node (Ctrl+1)");
    m_addInputAction->setShortcut(QKeySequence("Ctrl+1"));
    connect(m_addInputAction, &QAction::triggered, this, &Window::createInputNode);
    
    m_addOutputAction = new QAction("Add Output", this);
    m_addOutputAction->setToolTip("Add Output Node (Ctrl+2)");
    m_addOutputAction->setShortcut(QKeySequence("Ctrl+2"));
    connect(m_addOutputAction, &QAction::triggered, this, &Window::createOutputNode);
    
    m_addProcessorAction = new QAction("Add Processor", this);
    m_addProcessorAction->setToolTip("Add Processor Node (Ctrl+3)");
    m_addProcessorAction->setShortcut(QKeySequence("Ctrl+3"));
    connect(m_addProcessorAction, &QAction::triggered, this, &Window::createProcessorNode);
}


void Window::keyPressEvent(QKeyEvent* event)
{
    if (event->modifiers() & Qt::ControlModifier) {
        switch (event->key()) {
            case Qt::Key_1:
                createInputNode();
                break;
            case Qt::Key_2:
                createOutputNode();
                break;
            case Qt::Key_3:
                createProcessorNode();
                break;
            case Qt::Key_S:
                if (event->modifiers() & Qt::ShiftModifier) {
                    // Ctrl+Shift+S = Save As
                    QString filename = QFileDialog::getSaveFileName(
                        this, 
                        "Save Graph As", 
                        "graph.xml", 
                        "XML Files (*.xml)");
                    if (!filename.isEmpty()) {
                        if (saveGraph(filename)) {
                            m_currentFile = filename;
                            setWindowTitle(QString("Node Editor - %1").arg(QFileInfo(filename).fileName()));
                        }
                    }
                } else {
                    // Ctrl+S = Save
                    if (m_currentFile.isEmpty()) {
                        // No current file, show Save As dialog
                        QString filename = QFileDialog::getSaveFileName(
                            this, 
                            "Save Graph", 
                            "graph.xml", 
                            "XML Files (*.xml)");
                        if (!filename.isEmpty()) {
                            if (saveGraph(filename)) {
                                m_currentFile = filename;
                                setWindowTitle(QString("Node Editor - %1").arg(QFileInfo(filename).fileName()));
                            }
                        }
                    } else {
                        // Save to current file
                        saveGraph(m_currentFile);
                    }
                }
                break;
            case Qt::Key_O:
                // Ctrl+O = Open
                {
                    QString filename = QFileDialog::getOpenFileName(
                        this, 
                        "Open Graph", 
                        "", 
                        "XML Files (*.xml)");
                    if (!filename.isEmpty()) {
                        if (loadGraph(filename)) {
                            m_currentFile = filename;
                            setWindowTitle(QString("Node Editor - %1").arg(QFileInfo(filename).fileName()));
                        }
                    }
                }
                break;
        }
    } else if (event->key() == Qt::Key_Delete || event->key() == Qt::Key_Backspace) {
        // Delete selected items
        qDebug() << "=== DELETE KEY PRESSED ===";
        qDebug() << "Delete key pressed - key:" << (event->key() == Qt::Key_Delete ? "DELETE" : "BACKSPACE");
        qDebug() << "Modifiers:" << event->modifiers();
        qDebug() << "Scene focus item:" << (m_scene->focusItem() ? "HAS_FOCUS" : "NO_FOCUS");
        qDebug() << "Scene selected items count:" << m_scene->selectedItems().size();
        qDebug() << "Calling m_scene->deleteSelected()...";
        m_scene->deleteSelected();
        qDebug() << "=== DELETE KEY PROCESSING COMPLETE ===";
    }
    QMainWindow::keyPressEvent(event);
}

void Window::setCurrentFile(const QString& filename)
{
    m_currentFile = filename;
    if (!filename.isEmpty()) {
        setWindowTitle(QString("Node Editor - %1").arg(QFileInfo(filename).fileName()));
        qDebug() << "Current file set to:" << filename;
    } else {
        setWindowTitle("Node Editor");
        qDebug() << "Current file cleared";
    }
}

bool Window::saveGraph(const QString& filename)
{
    qDebug() << "Saving graph to:" << filename;
    
    QElapsedTimer timer;
    timer.start();
    
    // Create XML document
    xmlDocPtr doc = xmlNewDoc(BAD_CAST "1.0");
    xmlNodePtr root = xmlNewNode(nullptr, BAD_CAST "graph");
    xmlDocSetRootElement(doc, root);
    xmlSetProp(root, BAD_CAST "version", BAD_CAST "1.0");
    
    // Step 1: Save all nodes
    for (Node* node : m_scene->getNodes().values()) {
        xmlNodePtr nodeXml = node->write(doc, root);
        Q_UNUSED(nodeXml)
    }
    
    // Step 2: Save all edges
    for (Edge* edge : m_scene->getEdges().values()) {
        xmlNodePtr edgeXml = edge->write(doc, root);
        Q_UNUSED(edgeXml)
    }
    
    // Step 3: Save to file
    int result = xmlSaveFormatFileEnc(filename.toUtf8().constData(), doc, "UTF-8", 1);
    xmlFreeDoc(doc);
    
    qint64 elapsed = timer.elapsed();
    
    if (result != -1) {
        QFileInfo fileInfo(filename);
        qint64 fileSize = fileInfo.size();
        int nodeCount = m_scene->getNodes().size();
        int edgeCount = m_scene->getEdges().size();
        
        qDebug() << "Manual save complete:";
        qDebug() << "   File:" << fileInfo.fileName();
        qDebug() << "   Time:" << elapsed << "ms";
        qDebug() << "   Size:" << (fileSize / 1024.0) << "KB";
        qDebug() << "   Nodes:" << nodeCount;
        qDebug() << "   Edges:" << edgeCount;
        
        QMessageBox::information(this, "Save Complete", 
            QString("Graph saved successfully!\n\nFile: %1\nNodes: %2\nEdges: %3\nTime: %4ms\nSize: %5 KB")
            .arg(fileInfo.fileName())
            .arg(nodeCount)
            .arg(edgeCount)
            .arg(elapsed)
            .arg(fileSize / 1024.0, 0, 'f', 1));
        return true;
    } else {
        qDebug() << "Failed to save graph";
        QMessageBox::critical(this, "Save Error", "Failed to save graph to file.");
        return false;
    }
}

bool Window::loadGraph(const QString& filename)
{
    qDebug() << "=== LOADING GRAPH ===" << filename;
    
    QElapsedTimer timer;
    timer.start();
    
    // Clear current scene AND registries to prevent dangling pointers
    qDebug() << "Clearing current graph...";
    m_scene->clearGraph();
    
    // Use GraphFactory to load from XML file
    qDebug() << "Starting GraphFactory XML load...";
    if (m_factory->loadFromXmlFile(filename)) {
        qint64 elapsed = timer.elapsed();
        
        // Set current file for Ctrl+S functionality
        m_currentFile = filename;
        setWindowTitle(QString("Node Editor - %1").arg(QFileInfo(filename).fileName()));
        
        qDebug() << "Graph loaded successfully in" << elapsed << "ms";
        
        // DEBUGGING: Detailed count verification
        int nodeCount = m_scene->getNodes().size();
        int edgeCount = m_scene->getEdges().size();
        qDebug() << "DEBUG: Hash container sizes:";
        qDebug() << "  m_scene->getNodes().size() =" << nodeCount;
        qDebug() << "  m_scene->getEdges().size() =" << edgeCount;
        qDebug() << "  Qt scene items count:" << m_scene->items().size();
        qDebug() << "  Current file set to:" << m_currentFile;
        
        QMessageBox::information(this, "Load Complete", 
            QString("Graph loaded successfully!\n\nFile: %1\nNodes: %2\nEdges: %3\nTime: %4ms\n\nCtrl+S will now save to this file.")
            .arg(QFileInfo(filename).fileName())
            .arg(nodeCount)
            .arg(edgeCount)
            .arg(elapsed));
        return true;
    } else {
        qDebug() << "Failed to load graph";
        QMessageBox::critical(this, "Load Error", 
            QString("Failed to load graph from file.\n\nFile: %1")
            .arg(QFileInfo(filename).fileName()));
        return false;
    }
}

void Window::createInputNode()
{
    // Find a nice position in the view center
    QPointF viewCenter = m_view->mapToScene(m_view->viewport()->rect().center());
    
    // Add some randomization so multiple nodes don't overlap
    qreal randomX = QRandomGenerator::global()->bounded(-50, 50);
    qreal randomY = QRandomGenerator::global()->bounded(-50, 50);
    QPointF position = viewCenter + QPointF(randomX, randomY);
    
    // Create input node using factory (XML-first approach)
    Node* node = m_factory->createNode("SOURCE", position);
    
    if (node) {
        qDebug() << "Created input node at" << position;
    } else {
        qDebug() << "Failed to create input node";
    }
}

void Window::createOutputNode()
{
    // Find a nice position in the view center
    QPointF viewCenter = m_view->mapToScene(m_view->viewport()->rect().center());
    
    // Add some randomization so multiple nodes don't overlap
    qreal randomX = QRandomGenerator::global()->bounded(-50, 50);
    qreal randomY = QRandomGenerator::global()->bounded(-50, 50);
    QPointF position = viewCenter + QPointF(randomX, randomY);
    
    // Create output node using factory (XML-first approach)
    Node* node = m_factory->createNode("SINK", position);
    
    if (node) {
        qDebug() << "Created output node at" << position;
    } else {
        qDebug() << "Failed to create output node";
    }
}

void Window::createProcessorNode()
{
    // Find a nice position in the view center
    QPointF viewCenter = m_view->mapToScene(m_view->viewport()->rect().center());
    
    // Add some randomization so multiple nodes don't overlap
    qreal randomX = QRandomGenerator::global()->bounded(-50, 50);
    qreal randomY = QRandomGenerator::global()->bounded(-50, 50);
    QPointF position = viewCenter + QPointF(randomX, randomY);
    
    // Create processor node using factory (XML-first approach)
    Node* node = m_factory->createNode("TRANSFORM", position);
    
    if (node) {
        qDebug() << "Created processor node at" << position;
    } else {
        qDebug() << "Failed to create processor node";
    }
}

void Window::createNodeFromPalette(const QPointF& scenePos, const QString& nodeType, 
                                  const QString& name, int inputSockets, int outputSockets)
{
    qDebug() << "========================================";
    qDebug() << "Window: RECEIVED nodeDropped signal";
    qDebug() << "Window: Creating node from palette:";
    qDebug() << "  - Name:" << name;
    qDebug() << "  - Type:" << nodeType;
    qDebug() << "  - Position:" << scenePos;
    qDebug() << "  - Input sockets:" << inputSockets;
    qDebug() << "  - Output sockets:" << outputSockets;
    qDebug() << "Window: Calling factory->createNode()";
    
    // Create node using factory with the exact specifications from the palette
    Node* node = m_factory->createNode(nodeType, scenePos, inputSockets, outputSockets);
    
    if (node) {
        qDebug() << "Window: Factory successfully created" << name << "node";
        qDebug() << "Window: Node created at scene position:" << scenePos;
        qDebug() << "Window: Updating status bar";
        
        // Update status bar to reflect the new node
        updateStatusBar();
        statusBar()->showMessage(QString("Created %1 node").arg(name), 2000);
        
        qDebug() << "Window: Node creation process completed successfully";
    } else {
        qDebug() << "Window: Factory FAILED to create" << name << "node";
        qDebug() << "Window: This may indicate factory or scene issues";
        statusBar()->showMessage(QString("Failed to create %1 node").arg(name), 3000);
    }
    qDebug() << "========================================";
}

// ============================================================================
// Enhanced UI Implementation - Lookatme + Inkscape Status Bar Patterns
// ============================================================================

void Window::setupUI()
{
    setCentralWidget(m_view);
    
    // Set application icon and improve window appearance
    setWindowIcon(QIcon(":/icons/app-icon.png")); // Optional - if you have icons
    
    // Enable dock widget features
    setDockOptions(QMainWindow::AllowNestedDocks | 
                   QMainWindow::AllowTabbedDocks | 
                   QMainWindow::AnimatedDocks);
}

void Window::setupMenus()
{
    createFileMenu();
    createEditMenu();
    createViewMenu();
    createToolsMenu();
    createHelpMenu();
}

void Window::createFileMenu()
{
    m_fileMenu = menuBar()->addMenu("&File");
    
    // New file
    QAction* newAction = new QAction("&New", this);
    newAction->setShortcut(QKeySequence::New);
    newAction->setStatusTip("Create a new graph");
    connect(newAction, &QAction::triggered, this, &Window::newFile);
    m_fileMenu->addAction(newAction);
    
    // Open file
    QAction* openAction = new QAction("&Open...", this);
    openAction->setShortcut(QKeySequence::Open);
    openAction->setStatusTip("Open an existing graph");
    connect(openAction, &QAction::triggered, this, &Window::openFile);
    m_fileMenu->addAction(openAction);
    
    m_fileMenu->addSeparator();
    
    // Save file
    QAction* saveAction = new QAction("&Save", this);
    saveAction->setShortcut(QKeySequence::Save);
    saveAction->setStatusTip("Save the current graph");
    connect(saveAction, &QAction::triggered, this, &Window::saveFile);
    m_fileMenu->addAction(saveAction);
    
    // Save As
    QAction* saveAsAction = new QAction("Save &As...", this);
    saveAsAction->setShortcut(QKeySequence::SaveAs);
    saveAsAction->setStatusTip("Save the graph with a new name");
    connect(saveAsAction, &QAction::triggered, this, &Window::saveAsFile);
    m_fileMenu->addAction(saveAsAction);
    
    m_fileMenu->addSeparator();
    
    // Export
    QAction* exportAction = new QAction("&Export...", this);
    exportAction->setStatusTip("Export graph to various formats");
    connect(exportAction, &QAction::triggered, this, &Window::exportGraph);
    m_fileMenu->addAction(exportAction);
    
    m_fileMenu->addSeparator();
    
    // Exit
    QAction* exitAction = new QAction("E&xit", this);
    exitAction->setShortcut(QKeySequence::Quit);
    exitAction->setStatusTip("Exit the application");
    connect(exitAction, &QAction::triggered, this, &QWidget::close);
    m_fileMenu->addAction(exitAction);
}

void Window::createEditMenu()
{
    m_editMenu = menuBar()->addMenu("&Edit");
    
    // Undo/Redo placeholders for future implementation
    QAction* undoAction = new QAction("&Undo", this);
    undoAction->setShortcut(QKeySequence::Undo);
    undoAction->setEnabled(false); // TODO: Implement undo system
    m_editMenu->addAction(undoAction);
    
    QAction* redoAction = new QAction("&Redo", this);
    redoAction->setShortcut(QKeySequence::Redo);
    redoAction->setEnabled(false); // TODO: Implement redo system
    m_editMenu->addAction(redoAction);
    
    m_editMenu->addSeparator();
    
    // Selection operations
    QAction* selectAllAction = new QAction("Select &All", this);
    selectAllAction->setShortcut(QKeySequence::SelectAll);
    selectAllAction->setStatusTip("Select all nodes and edges");
    m_editMenu->addAction(selectAllAction);
    
    QAction* deselectAction = new QAction("&Deselect All", this);
    deselectAction->setShortcut(QKeySequence("Ctrl+D"));
    deselectAction->setStatusTip("Clear selection");
    m_editMenu->addAction(deselectAction);
    
    m_editMenu->addSeparator();
    
    // Delete
    QAction* deleteAction = new QAction("&Delete Selected", this);
    deleteAction->setShortcut(QKeySequence::Delete);
    deleteAction->setStatusTip("Delete selected nodes and edges");
    m_editMenu->addAction(deleteAction);
}

void Window::createViewMenu()
{
    m_viewMenu = menuBar()->addMenu("&View");
    
    // Zoom operations
    QAction* zoomInAction = new QAction("Zoom &In", this);
    zoomInAction->setShortcut(QKeySequence::ZoomIn);
    zoomInAction->setStatusTip("Zoom in to the graph");
    connect(zoomInAction, &QAction::triggered, this, &Window::zoomIn);
    m_viewMenu->addAction(zoomInAction);
    
    QAction* zoomOutAction = new QAction("Zoom &Out", this);
    zoomOutAction->setShortcut(QKeySequence::ZoomOut);
    zoomOutAction->setStatusTip("Zoom out from the graph");
    connect(zoomOutAction, &QAction::triggered, this, &Window::zoomOut);
    m_viewMenu->addAction(zoomOutAction);
    
    QAction* zoomFitAction = new QAction("Zoom to &Fit", this);
    zoomFitAction->setShortcut(QKeySequence("Ctrl+0"));
    zoomFitAction->setStatusTip("Fit entire graph in view");
    connect(zoomFitAction, &QAction::triggered, this, &Window::zoomFit);
    m_viewMenu->addAction(zoomFitAction);
    
    QAction* zoomResetAction = new QAction("&Reset Zoom", this);
    zoomResetAction->setShortcut(QKeySequence("Ctrl+1"));
    zoomResetAction->setStatusTip("Reset zoom to 100%");
    connect(zoomResetAction, &QAction::triggered, this, &Window::zoomReset);
    m_viewMenu->addAction(zoomResetAction);
    
    m_viewMenu->addSeparator();
    
    // Dock widget toggles will be added after dock widgets are created
}

void Window::createToolsMenu()
{
    m_toolsMenu = menuBar()->addMenu("&Tools");
    
    // Node creation submenu
    QMenu* createNodeMenu = m_toolsMenu->addMenu("&Create Node");
    createNodeMenu->addAction(m_addInputAction);
    createNodeMenu->addAction(m_addOutputAction);
    createNodeMenu->addAction(m_addProcessorAction);
    
    m_toolsMenu->addSeparator();
    
    QAction* validateAction = new QAction("&Validate Graph", this);
    validateAction->setStatusTip("Check graph for errors and inconsistencies");
    m_toolsMenu->addAction(validateAction);
    
    QAction* statisticsAction = new QAction("Graph &Statistics", this);
    statisticsAction->setStatusTip("Show detailed graph statistics");
    m_toolsMenu->addAction(statisticsAction);
    
    // Note: JavaScript test menus removed - use CLI scripting instead:
    // ./NodeGraph --script path/to/script.js
    // ./NodeGraph --eval "JavaScript code here"
}

void Window::createHelpMenu()
{
    m_helpMenu = menuBar()->addMenu("&Help");
    
    QAction* aboutAction = new QAction("&About", this);
    aboutAction->setStatusTip("About this application");
    connect(aboutAction, &QAction::triggered, this, &Window::showAbout);
    m_helpMenu->addAction(aboutAction);
    
    QAction* aboutQtAction = new QAction("About &Qt", this);
    aboutQtAction->setStatusTip("About Qt Framework");
    connect(aboutQtAction, &QAction::triggered, qApp, &QApplication::aboutQt);
    m_helpMenu->addAction(aboutQtAction);
}

void Window::setupStatusBar()
{
    createStatusBarWidgets();
    connectStatusBarSignals();
}

void Window::createStatusBarWidgets()
{
    QStatusBar* statusBar = this->statusBar();
    statusBar->setStyleSheet(
        "QStatusBar {"
        "  border-top: 1px solid #bdc3c7;"
        "  background: #ecf0f1;"
        "}"
        "QStatusBar::item {"
        "  border: none;"
        "}"
    );
    
    // File info (leftmost)
    m_fileInfoLabel = new QLabel("No file loaded");
    m_fileInfoLabel->setStyleSheet("QLabel { color: #2c3e50; margin-right: 15px; }");
    statusBar->addWidget(m_fileInfoLabel);
    
    // Graph statistics
    m_graphStatsLabel = new QLabel("Nodes: 0 | Edges: 0");
    m_graphStatsLabel->setStyleSheet("QLabel { color: #27ae60; font-weight: bold; margin-right: 15px; }");
    statusBar->addWidget(m_graphStatsLabel);
    
    // Selection info
    m_selectionLabel = new QLabel("No selection");
    m_selectionLabel->setStyleSheet("QLabel { color: #8e44ad; margin-right: 15px; }");
    statusBar->addWidget(m_selectionLabel);
    
    // Add stretch to push remaining widgets to the right
    statusBar->addPermanentWidget(new QWidget(), 1);
    
    // Mouse position (right side)
    m_positionLabel = new QLabel("Position: (0, 0)");
    m_positionLabel->setStyleSheet("QLabel { color: #34495e; margin-right: 10px; }");
    statusBar->addPermanentWidget(m_positionLabel);
    
    // Zoom level (rightmost)
    m_zoomLabel = new QLabel("Zoom: 100%");
    m_zoomLabel->setStyleSheet("QLabel { color: #e74c3c; font-weight: bold; }");
    statusBar->addPermanentWidget(m_zoomLabel);
    
    // Operation progress (hidden by default)
    m_operationProgress = new QProgressBar();
    m_operationProgress->setVisible(false);
    m_operationProgress->setMaximumWidth(200);
    statusBar->addPermanentWidget(m_operationProgress);
}

void Window::connectStatusBarSignals()
{
    // Update status bar when scene changes
    connect(m_scene, &Scene::sceneChanged, this, &Window::updateStatusBar);
    
    // TODO: Connect view signals for mouse position and zoom updates
    // This would require extending the View class to emit these signals
}

void Window::setupDockWidgets()
{
    // Create node palette dock widget
    m_nodePaletteDock = new QDockWidget("Node Palette", this);
    m_nodePaletteDock->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    m_nodePaletteDock->setFeatures(QDockWidget::DockWidgetMovable | QDockWidget::DockWidgetFloatable);
    
    // Create palette widget
    m_nodePalette = new NodePaletteWidget();
    m_nodePaletteDock->setWidget(m_nodePalette);
    
    // Add dock widget to left side
    addDockWidget(Qt::LeftDockWidgetArea, m_nodePaletteDock);
    
    // Connect palette signals
    connect(m_nodePalette, &NodePaletteWidget::nodeCreationRequested, 
            this, &Window::onNodeCreationRequested);
    
}

void Window::updateStatusBar()
{
    if (!m_scene) return;
    
    // Update graph statistics
    int nodeCount = m_scene->getNodes().size();
    int edgeCount = m_scene->getEdges().size();
    m_graphStatsLabel->setText(QString("Nodes: %1 | Edges: %2").arg(nodeCount).arg(edgeCount));
    
    // Update file info
    if (m_currentFile.isEmpty()) {
        m_fileInfoLabel->setText("No file loaded");
    } else {
        QFileInfo fileInfo(m_currentFile);
        m_fileInfoLabel->setText(QString("File: %1").arg(fileInfo.fileName()));
    }
    
    // Update selection info (placeholder for now)
    QList<QGraphicsItem*> selectedItems = m_scene->selectedItems();
    if (selectedItems.isEmpty()) {
        m_selectionLabel->setText("No selection");
    } else {
        m_selectionLabel->setText(QString("Selected: %1 items").arg(selectedItems.size()));
    }
}

// ============================================================================
// Slot Implementations
// ============================================================================

void Window::onSceneChanged()
{
    updateStatusBar();
}

void Window::onSelectionChanged()
{
    updateSelectionInfo();
}

void Window::updateSelectionInfo()
{
    if (!m_scene) return;
    
    QList<QGraphicsItem*> selectedItems = m_scene->selectedItems();
    if (selectedItems.isEmpty()) {
        m_selectionLabel->setText("No selection");
    } else {
        int nodeCount = 0;
        int edgeCount = 0;
        
        for (QGraphicsItem* item : selectedItems) {
            if (qgraphicsitem_cast<Node*>(item)) {
                nodeCount++;
            } else if (qgraphicsitem_cast<Edge*>(item)) {
                edgeCount++;
            }
        }
        
        QString selectionText;
        if (nodeCount > 0 && edgeCount > 0) {
            selectionText = QString("Selected: %1 nodes, %2 edges").arg(nodeCount).arg(edgeCount);
        } else if (nodeCount > 0) {
            selectionText = QString("Selected: %1 nodes").arg(nodeCount);
        } else if (edgeCount > 0) {
            selectionText = QString("Selected: %1 edges").arg(edgeCount);
        }
        
        m_selectionLabel->setText(selectionText);
    }
}

// ============================================================================
// Menu Action Implementations (Placeholders)
// ============================================================================

void Window::newFile()
{
    // TODO: Clear current scene and reset
    qDebug() << "New file requested";
}

void Window::openFile()
{
    qDebug() << "=== FILE OPEN DIALOG ===";
    QString fileName = QFileDialog::getOpenFileName(this, "Open Graph", "", "XML Files (*.xml)");
    if (!fileName.isEmpty()) {
        qDebug() << "File selected:" << fileName;
        if (loadGraph(fileName)) {
            setCurrentFile(fileName);
            updateStatusBar();
            qDebug() << "File loaded successfully";
        } else {
            qDebug() << "File load FAILED";
        }
    } else {
        qDebug() << "File dialog cancelled";
    }
}

void Window::saveFile()
{
    qDebug() << "=== CTRL+S SAVE TRIGGERED ===";
    qDebug() << "Current file:" << (m_currentFile.isEmpty() ? "NONE (will show Save As dialog)" : m_currentFile);
    
    if (m_currentFile.isEmpty()) {
        qDebug() << "No current file - opening Save As dialog...";
        saveAsFile();
    } else {
        qDebug() << "Saving to current file:" << m_currentFile;
        if (saveGraph(m_currentFile)) {
            qDebug() << "Save successful";
            updateStatusBar();
        } else {
            qDebug() << "Save FAILED";
        }
    }
}

void Window::saveAsFile()
{
    QString fileName = QFileDialog::getSaveFileName(this, "Save Graph", "", "XML Files (*.xml)");
    if (!fileName.isEmpty()) {
        if (saveGraph(fileName)) {
            setCurrentFile(fileName);
            updateStatusBar();
        }
    }
}

void Window::exportGraph()
{
    // TODO: Implement export functionality
    QMessageBox::information(this, "Export", "Export functionality will be implemented in a future update.");
}

void Window::showAbout()
{
    QMessageBox::about(this, "About NodeGraph",
        "<h3>NodeGraph - Self-Serializing Node Editor</h3>"
        "<p>A professional node-based graph editor with self-serializing architecture.</p>"
        "<p><b>Features:</b></p>"
        "<ul>"
        "<li>Self-serializing nodes with libxml2 backend</li>"
        "<li>Observer pattern with automatic XML persistence</li>"
        "<li>Professional UI with docking panels</li>"
        "<li>Enhanced visual selection highlighting</li>"
        "<li>Drag-and-drop node creation</li>"
        "</ul>"
        "<p>Built with Qt5 and modern C++ patterns.</p>");
}

void Window::zoomIn()
{
    m_view->scale(1.2, 1.2);
    // TODO: Update zoom label
}

void Window::zoomOut()
{
    m_view->scale(0.8, 0.8);
    // TODO: Update zoom label
}

void Window::zoomFit()
{
    m_view->fitInView(m_scene->itemsBoundingRect(), Qt::KeepAspectRatio);
    // TODO: Update zoom label
}

void Window::zoomReset()
{
    m_view->resetTransform();
    // TODO: Update zoom label
}

/*
void Window::createNodeAtPosition(const QString& nodeType, const QPointF& scenePos)
{
    // Drag-and-drop node creation disabled for now
    // Focus on JavaScript integration
}
*/

// ============================================================================
// PHASE 3: Safe Shutdown Coordination
// ============================================================================

void Window::closeEvent(QCloseEvent* event)
{
    qDebug() << "PHASE1: Window shutdown initiated";
    
    // PHASE 1.2: Prepare scene for safe shutdown
    if (m_scene) {
        m_scene->prepareForShutdown();
    }
    
    // Accept the close event (no dirty state tracking yet)
    QMainWindow::closeEvent(event);
    
    qDebug() << "PHASE1: Window shutdown complete";
}

// Note: JavaScript test methods removed - use CLI scripting instead:
// ./NodeGraph --script path/to/script.js  
// ./NodeGraph --eval "JavaScript code here"

void Window::onNodeCreationRequested()
{
    // The signal includes the nodeTemplate, but we need to handle it via sender() for now
    // due to header file forward declaration limitations
    
    // For double-click from palette, create node at center of view
    QPointF centerPoint = m_view->mapToScene(m_view->rect().center());
    
    // We'll implement drag-and-drop separately - for now just handle the signal connection
    
    // Create a default input node for testing
    createNodeFromPalette(centerPoint, "IN", "Input", 0, 2);
}



=== scene.h ===

#pragma once

#include <QGraphicsScene>
#include <QHash>
#include <QUuid>
#include "graph_observer.h"

class Node;
class Edge;
class Socket;
class JavaScriptEngine;
class GhostEdge;

/**
 * Scene - QElectroTech-style typed scene management
 * 
 * Uses QHash collections for O(1) UUID lookups
 * Never use generic items() - always use typed collections
 * Follows QElectroTech/Fritzing patterns for professional node editors
 */
class Scene : public QGraphicsScene, public GraphSubject
{
    Q_OBJECT

signals:
    void sceneChanged();

public:
    explicit Scene(QObject* parent = nullptr);
    
    // Typed item management - QElectroTech style
    void addNode(Node* node);
    void addEdge(Edge* edge);
    void addSocket(Socket* socket);  // Deprecated - sockets managed by nodes
    
    void removeNode(const QUuid& nodeId);
    void removeEdge(const QUuid& edgeId);
    
    // Fast UUID-based lookups O(1) - no searching, no casting
    Node* getNode(const QUuid& nodeId) const;
    Edge* getEdge(const QUuid& edgeId) const;
    
    // Type-safe iteration - never need qgraphicsitem_cast
    const QHash<QUuid, Node*>& getNodes() const { return m_nodes; }
    const QHash<QUuid, Edge*>& getEdges() const { return m_edges; }
    // Clean design: sockets accessed via nodes, not scene
    
    // Deletion methods - maintain integrity
    void deleteNode(const QUuid& nodeId);
    void deleteEdge(const QUuid& edgeId);
    void deleteSelected();  // Delete all selected items
    
    // Clear both graphics items AND registries - prevents dangling pointers
    void clearGraph();
    
    // PHASE 1.2: Safe shutdown preparation
    void prepareForShutdown();
    bool isShutdownInProgress() const { return m_shutdownInProgress; }
    
    // Public observer notifications (for Node movement)
    using GraphSubject::notifyNodeMoved;
    
    // Ghost edge for visual connection feedback (right-click and drag)
    void startGhostEdge(Socket* fromSocket, const QPointF& startPos);
    void updateGhostEdge(const QPointF& currentPos);
    void finishGhostEdge(Socket* toSocket = nullptr);
    void cancelGhostEdge();
    bool ghostEdgeActive() const { return m_ghostEdgeActive; }
    
    // JavaScript engine access
    JavaScriptEngine* getJavaScriptEngine() const { return m_jsEngine; }
    QString executeJavaScript(const QString& script);
    void loadJavaScriptFile(const QString& filePath);
    
    // Critical destruction safety flag
    static bool isClearing() { return s_clearingGraph; }

protected:
    // Mouse event handling for ghost edge interactions
    void mouseMoveEvent(QGraphicsSceneMouseEvent* event) override;
    void mouseReleaseEvent(QGraphicsSceneMouseEvent* event) override;

private:
    // QElectroTech-style typed collections with UUID keys
    QHash<QUuid, Node*> m_nodes;
    QHash<QUuid, Edge*> m_edges;
    QHash<QUuid, Socket*> m_sockets;  // Deprecated - kept for compatibility
    
    // Ghost edge for visual feedback during right-click connection creation
    GhostEdge* m_ghostEdge;
    Socket* m_ghostFromSocket;
    bool m_ghostEdgeActive;
    
    // Helper method for ghost edge styling
    QPen ghostPen() const;
    void resetAllSocketStates();
    
    // Static flag to prevent socket cleanup during clearGraph
    static bool s_clearingGraph;
    
    // Shutdown coordination flag
    bool m_shutdownInProgress;
    
    // JavaScript engine integration
    JavaScriptEngine* m_jsEngine;
};

=== scene.cpp ===

#include "scene.h"
#include "node.h"
#include "edge.h"
#include "socket.h"
#include "javascript_engine.h"
#include "ghost_edge.h"
#include <QDebug>
#include <QTimer>
#include <QGraphicsPathItem>

Scene::Scene(QObject* parent)
    : QGraphicsScene(parent)
    , m_ghostEdge(nullptr)
    , m_ghostFromSocket(nullptr)
    , m_ghostEdgeActive(false)
    , m_shutdownInProgress(false)
    , m_jsEngine(new JavaScriptEngine(this))
{
    setSceneRect(-1000, -1000, 2000, 2000);
    
    // Initialize JavaScript engine with this scene
    if (m_jsEngine) {
        m_jsEngine->registerNodeAPI(this);
        m_jsEngine->registerGraphAPI();
        // GraphController will be registered when GraphFactory is available
    }
}

// QElectroTech-style QHash implementation with SIMPLE_FIX logging
void Scene::addNode(Node* node)
{
    if (!node) return;
    
    QUuid nodeId = node->getId();
    m_nodes.insert(nodeId, node);
    addItem(node);
    
    qDebug() << "+" << nodeId.toString(QUuid::WithoutBraces).left(8);
    
    // Notify observers of node addition
    notifyNodeAdded(*node);
    
    // Emit signal for UI updates
    emit sceneChanged();
}

void Scene::addEdge(Edge* edge)
{
    if (!edge) return;
    
    QUuid edgeId = edge->getId();
    m_edges.insert(edgeId, edge);
    addItem(edge);
    
    qDebug() << "+" << edgeId.toString(QUuid::WithoutBraces).left(8);
    
    // Notify observers of edge addition
    notifyEdgeAdded(*edge);
    
    // Emit signal for UI updates
    emit sceneChanged();
    
    // Clean design: edges manage their own socket connections via resolveConnections()
}

void Scene::addSocket(Socket* socket)
{
    if (!socket) return;
    
    // Clean design: sockets are managed by their parent nodes, not scene
    // Socket is automatically added to scene as child of parent node
}

void Scene::removeNode(const QUuid& nodeId)
{
    Node* node = m_nodes.value(nodeId, nullptr);
    if (!node) return;
    
    // Clean design: sockets are children of nodes - no separate tracking needed
    
    // Remove connected edges that reference this node
    QList<QUuid> edgesToRemove;
    QString nodeIdStr = nodeId.toString();
    for (Edge* edge : m_edges.values()) {
        if (edge->isConnectedToNode(nodeIdStr)) {
            edgesToRemove.append(edge->getId());
        }
    }
    
    // Clean up edges first (they may reference sockets)
    for (const QUuid& edgeId : edgesToRemove) {
        removeEdge(edgeId);
    }
    
    // Clean design: sockets cleaned up automatically as node children
    
    // Finally remove the node
    removeItem(node);
    m_nodes.remove(nodeId);
    delete node;
}

void Scene::removeEdge(const QUuid& edgeId)
{
    Edge* edge = m_edges.value(edgeId, nullptr);
    if (!edge) return;
    
    // Clean design: edges manage their own socket disconnection via direct pointers
    // Socket cleanup handled automatically when edge is destroyed
    
    // Remove from scene and registry
    removeItem(edge);
    m_edges.remove(edgeId);
    delete edge;
}

// Clean design: socket management methods removed - sockets handled by parent nodes

// O(1) UUID lookups
Node* Scene::getNode(const QUuid& nodeId) const
{
    return m_nodes.value(nodeId, nullptr);
}

Edge* Scene::getEdge(const QUuid& edgeId) const
{
    return m_edges.value(edgeId, nullptr);
}

void Scene::deleteNode(const QUuid& nodeId)
{
    Node* node = getNode(nodeId);
    if (!node) {
        qWarning() << "Scene::deleteNode - node not found:" << nodeId.toString(QUuid::WithoutBraces).left(8);
        return;
    }
    
    qDebug() << "Deleting node:" << nodeId.toString(QUuid::WithoutBraces).left(8);
    
    // First, find and delete all edges connected to this node
    QList<QUuid> edgesToDelete;
    for (auto it = m_edges.begin(); it != m_edges.end(); ++it) {
        Edge* edge = it.value();
        if (edge->isConnectedToNode(nodeId)) {
            edgesToDelete.append(it.key());
        }
    }
    
    // Delete connected edges
    for (const QUuid& edgeId : edgesToDelete) {
        deleteEdge(edgeId);
    }
    
    // Remove node from collections and scene
    m_nodes.remove(nodeId);
    removeItem(node);
    
    // Notify observers BEFORE deleting the node
    notifyNodeRemoved(nodeId);
    
    delete node;
    
    // Emit signal for UI updates
    emit sceneChanged();
    
    qDebug() << "Node deleted with" << edgesToDelete.size() << "connected edges - Observer notified";
}

void Scene::deleteEdge(const QUuid& edgeId)
{
    Edge* edge = getEdge(edgeId);
    if (!edge) {
        qWarning() << "Scene::deleteEdge - edge not found:" << edgeId.toString(QUuid::WithoutBraces).left(8);
        return;
    }
    
    qDebug() << "Deleting edge:" << edgeId.toString(QUuid::WithoutBraces).left(8);
    
    // Remove from collection and scene
    m_edges.remove(edgeId);
    removeItem(edge);
    
    // Notify observers BEFORE deleting the edge
    notifyEdgeRemoved(edgeId);
    
    delete edge;
    
    // Emit signal for UI updates
    emit sceneChanged();
    
    qDebug() << "Edge deleted - Observer notified";
}

void Scene::deleteSelected()
{
    qDebug() << "=== DELETE SELECTED START ===";
    QList<QGraphicsItem*> selectedItems = this->selectedItems();
    qDebug() << "Scene::deleteSelected() - Found" << selectedItems.size() << "selected items";
    
    if (selectedItems.isEmpty()) {
        qDebug() << "No items selected for deletion - DELETE ABORTED";
        qDebug() << "=== DELETE SELECTED END (ABORTED) ===";
        return;
    }
    
    // Log details about each selected item using Scene collections
    for (int i = 0; i < selectedItems.size(); i++) {
        QGraphicsItem* item = selectedItems[i];
        
        // Check if item is in our node collection
        Node* nodeMatch = nullptr;
        for (Node* node : m_nodes.values()) {
            if (node == item) {
                nodeMatch = node;
                break;
            }
        }
        
        // Check if item is in our edge collection
        Edge* edgeMatch = nullptr;
        for (Edge* edge : m_edges.values()) {
            if (edge == item) {
                edgeMatch = edge;
                break;
            }
        }
        
        if (nodeMatch) {
            qDebug() << "Selected item" << i << ": NODE" << nodeMatch->getId().toString(QUuid::WithoutBraces).left(8);
        } else if (edgeMatch) {
            qDebug() << "Selected item" << i << ": EDGE" << edgeMatch->getId().toString(QUuid::WithoutBraces).left(8);
        } else {
            qDebug() << "Selected item" << i << ": UNKNOWN (not in collections)";
        }
    }
    
    qDebug() << "DELETE KEY: Processing" << selectedItems.size() << "selected items for deletion";
    
    // Separate nodes and edges for proper deletion order using Scene collections
    QList<Node*> selectedNodes;
    QList<Edge*> selectedEdges;
    
    for (QGraphicsItem* item : selectedItems) {
        // Check if item is in our node collection
        for (Node* node : m_nodes.values()) {
            if (node == item) {
                selectedNodes.append(node);
                break;
            }
        }
        
        // Check if item is in our edge collection
        for (Edge* edge : m_edges.values()) {
            if (edge == item) {
                selectedEdges.append(edge);
                break;
            }
        }
    }
    
    qDebug() << "Categorized items - EDGES:" << selectedEdges.size() << "NODES:" << selectedNodes.size();
    
    // Delete selected edges first
    for (Edge* edge : selectedEdges) {
        deleteEdge(edge->getId());
    }
    
    // Then delete selected nodes (which will delete their remaining edges)
    for (Node* node : selectedNodes) {
        deleteNode(node->getId());
    }
    
    // Emit signal for UI updates
    emit sceneChanged();
    
    qDebug() << "DELETE COMPLETE: Deleted" << selectedEdges.size() << "edges and" << selectedNodes.size() << "nodes - Observers notified";
}

void Scene::clearGraph()
{
    qDebug() << "SIMPLE_FIX: Clearing graph - removing" << m_nodes.size() << "nodes and" << m_edges.size() << "edges";
    
    // SIMPLE FIX: Clear registries FIRST to prevent dangling pointers
    // This prevents hash lookups during Qt's destruction sequence
    qDebug() << "SIMPLE_FIX: Clearing hash registries first";
    m_nodes.clear();
    m_edges.clear();
    m_sockets.clear();  // Clear deprecated socket registry too
    
    // Then clear Qt graphics scene (safe now - no hash references)
    qDebug() << "SIMPLE_FIX: Clearing Qt scene items";
    QGraphicsScene::clear();
    
    // Notify observers of graph clearing
    notifyGraphCleared();
    
    // Emit signal for UI updates
    emit sceneChanged();
    
    qDebug() << "SIMPLE_FIX: Graph cleared safely - hash cleared before Qt cleanup";
}

// ============================================================================
// PHASE 1.2: Safe Shutdown Preparation
// ============================================================================

void Scene::prepareForShutdown()
{
    if (m_shutdownInProgress) {
        qDebug() << "SHUTDOWN: Already in progress, skipping";
        return;
    }
    
    qDebug() << "PHASE1: Shutdown preparation -" << m_edges.size() << "edges," << m_nodes.size() << "nodes";
    m_shutdownInProgress = true;
    
    // Step 1: Clean edge-socket connections BEFORE any destruction
    for (Edge* edge : m_edges.values()) {
        // Note: Socket connection cleanup disabled - methods not available in current implementation
    }
    
    qDebug() << "PHASE1: Socket connections cleared safely";
}

// ============================================================================
// Ghost Edge Implementation for Right-Click Socket Connections
// ============================================================================

// IUnknown UUID for ghost edge identification
static const QUuid GHOST_EDGE_UUID = QUuid("{00000000-0000-0000-C000-000000000046}");

void Scene::startGhostEdge(Socket* fromSocket, const QPointF& startPos)
{
    if (m_ghostEdge) {
        removeItem(m_ghostEdge);
        delete m_ghostEdge;
    }
    
    m_ghostFromSocket = fromSocket;
    
    m_ghostEdge = new GhostEdge();
    m_ghostEdge->setData(0, GHOST_EDGE_UUID); // IUnknown UUID marker
    
    addItem(m_ghostEdge);
    m_ghostEdgeActive = true;
    
    // Set source socket to connecting state
    fromSocket->setConnectionState(Socket::Connecting);
    
    updateGhostEdge(startPos);
    
    qDebug() << "GHOST: Started from socket" << fromSocket->getIndex() 
             << "(" << (fromSocket->getRole() == Socket::Input ? "Input" : "Output") << ")";
}

void Scene::updateGhostEdge(const QPointF& currentPos)
{
    if (!m_ghostEdge || !m_ghostFromSocket) return;
    
    QPointF start = m_ghostFromSocket->scenePos();
    QPainterPath path;
    path.moveTo(start);
    
    // Create curved ghost edge similar to real edges
    qreal dx = currentPos.x() - start.x();
    qreal controlOffset = qMin(qAbs(dx) * 0.5, 100.0);
    
    QPointF control1 = start + QPointF(controlOffset, 0);
    QPointF control2 = currentPos - QPointF(controlOffset, 0);
    path.cubicTo(control1, control2, currentPos);
    
    // Update ghost edge visual based on target validity
    QPen ghostPenCurrent = ghostPen();
    QGraphicsItem* itemUnderCursor = itemAt(currentPos, QTransform());
    Socket* targetSocket = qgraphicsitem_cast<Socket*>(itemUnderCursor);
    
    // Reset all socket visual states to normal first
    resetAllSocketStates();
    
    if (targetSocket) {
        // Check if this is a valid connection target
        bool isValidTarget = (targetSocket->getRole() == Socket::Input && 
                            targetSocket != m_ghostFromSocket &&
                            targetSocket->getParentNode() != m_ghostFromSocket->getParentNode());
        
        if (isValidTarget) {
            targetSocket->setConnectionState(Socket::Highlighted);
            ghostPenCurrent.setColor(QColor(0, 255, 0, 180)); // Green ghost edge
        } else {
            ghostPenCurrent.setColor(QColor(255, 0, 0, 180)); // Red ghost edge
        }
    } else {
        // No socket under cursor - default ghost edge color
        ghostPenCurrent.setColor(QColor(0, 255, 0, 150)); // Default green
    }
    
    m_ghostEdge->setPath(path);
}

void Scene::resetAllSocketStates()
{
    // Reset all sockets to normal state when not being targeted
    for (Node* node : m_nodes.values()) {
        for (QGraphicsItem* child : node->childItems()) {
            if (Socket* socket = qgraphicsitem_cast<Socket*>(child)) {
                if (socket != m_ghostFromSocket) {
                    socket->updateConnectionState(); // Reset to connected/disconnected
                }
            }
        }
    }
}

void Scene::finishGhostEdge(Socket* toSocket)
{
    if (m_ghostFromSocket && toSocket) {
        // Validate connection roles
        if (m_ghostFromSocket->getRole() == Socket::Output && 
            toSocket->getRole() == Socket::Input) {
            
            // Create real edge using existing system
            Edge* newEdge = new Edge(QUuid::createUuid(), QUuid(), QUuid());
            
            Node* fromNode = m_ghostFromSocket->getParentNode();
            Node* toNode = toSocket->getParentNode();
            
            if (fromNode && toNode) {
                newEdge->setConnectionData(
                    fromNode->getId().toString(QUuid::WithoutBraces),
                    toNode->getId().toString(QUuid::WithoutBraces),
                    m_ghostFromSocket->getIndex(),
                    toSocket->getIndex()
                );
                
                addEdge(newEdge);
                newEdge->resolveConnections(this);
                
                // Brief success feedback - flash the connected sockets green (disabled)
                // m_ghostFromSocket->setVisualState(Socket::ValidTarget);
                // toSocket->setVisualState(Socket::ValidTarget);
                // QTimer::singleShot(300, [this, toSocket]() {
                //     // Reset to normal appearance after brief success flash
                //     if (m_ghostFromSocket) m_ghostFromSocket->setVisualState(Socket::Normal);
                //     toSocket->setVisualState(Socket::Normal);
                // });
                
                qDebug() << "GHOST: Created edge" << m_ghostFromSocket->getIndex() << "->" << toSocket->getIndex();
            }
        } else {
            qDebug() << "GHOST: Invalid connection - wrong socket roles";
        }
    }
    
    // Reset all socket states before canceling
    resetAllSocketStates();
    cancelGhostEdge();
}

void Scene::cancelGhostEdge()
{
    // Reset all socket visual states
    resetAllSocketStates();
    
    if (m_ghostEdge) {
        removeItem(m_ghostEdge);
        delete m_ghostEdge;
        m_ghostEdge = nullptr;
    }
    m_ghostFromSocket = nullptr;
    m_ghostEdgeActive = false;
    
    qDebug() << "GHOST: Cancelled";
}

QPen Scene::ghostPen() const
{
    QPen pen(QColor(0, 255, 0, 150)); // Semi-transparent green
    pen.setWidth(3);
    pen.setStyle(Qt::DashLine);
    pen.setDashPattern({8, 4});
    pen.setCapStyle(Qt::RoundCap);
    pen.setJoinStyle(Qt::RoundJoin);
    return pen;
}

void Scene::mouseMoveEvent(QGraphicsSceneMouseEvent* event)
{
    if (m_ghostEdgeActive) {
        updateGhostEdge(event->scenePos());
        event->accept();
        return;
    }
    QGraphicsScene::mouseMoveEvent(event);
}

void Scene::mouseReleaseEvent(QGraphicsSceneMouseEvent* event)
{
    if (m_ghostEdgeActive && event->button() == Qt::RightButton) {
        // Find socket under mouse
        QGraphicsItem* item = itemAt(event->scenePos(), QTransform());
        Socket* targetSocket = qgraphicsitem_cast<Socket*>(item);
        finishGhostEdge(targetSocket);
        event->accept();
        return;
    }
    QGraphicsScene::mouseReleaseEvent(event);
}

// JavaScript engine integration methods
QString Scene::executeJavaScript(const QString& script)
{
    if (!m_jsEngine) {
        qDebug() << "Scene: JavaScript engine not initialized";
        return QString();
    }
    
    QJSValue result = m_jsEngine->evaluate(script);
    
    if (result.isError()) {
        qDebug() << "Scene: JavaScript error:" << result.toString();
        return QString();
    }
    
    return result.toString();
}

void Scene::loadJavaScriptFile(const QString& filePath)
{
    if (!m_jsEngine) {
        qDebug() << "Scene: JavaScript engine not initialized";
        return;
    }
    
    QJSValue result = m_jsEngine->evaluateFile(filePath);
    
    if (result.isError()) {
        qDebug() << "Scene: Failed to load JavaScript file:" << filePath << "Error:" << result.toString();
    } else {
        qDebug() << "Scene: Successfully loaded JavaScript file:" << filePath;
    }
}


=== node.h ===

#pragma once

#include <QGraphicsItem>
#include <QGraphicsScene>
#include <QPainter>
#include <QStyleOptionGraphicsItem>
#include <QWidget>
#include <QUuid>
#include <QPointF>
#include <QString>
#include <QVector>
#include <QRectF>
#include <QSizeF>
#include <QColor>
#include <QSet>
#include <libxml/tree.h>
#include "graph_item_types.h"

// Forward declarations to avoid circular includes
class Socket;
class Edge;

/**
 * Node - A self-serializing visual node
 * 
 * Core principles:
 * - Self-serialization via write()/read() methods
 * - Value semantics, no smart pointers
 * - No QObject inheritance or connect usage
 * - Sockets are children of nodes only
 * - Uses Qt containers instead of std library
 * - Explicit type system via IGraphItem interface
 */
class Node : public QGraphicsItem, public IGraphItem
{
public:
    Node(const QUuid& id = QUuid::createUuid(), 
         const QPointF& position = QPointF(100, 100));
    ~Node(); // Destructor for safe edge invalidation
    
    // Core identity
    const QUuid& getId() const { return m_id; }
    
    // IGraphItem interface implementation
    GraphItemType getGraphItemType() const override { return GraphItemType::Node; }
    QString getItemId() const override { return m_id.toString(QUuid::WithoutBraces); }
    
    // Self-serialization interface
    xmlNodePtr write(xmlDocPtr doc, xmlNodePtr repr = nullptr) const;
    virtual void read(xmlNodePtr node);
    
    // QGraphicsItem interface
    QRectF boundingRect() const override;
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) override;
    
    // Movement tracking for live XML updates
    QVariant itemChange(GraphicsItemChange change, const QVariant &value) override;
    
    // Node properties
    void setNodeSize(qreal width, qreal height);
    QSizeF getNodeSize() const { return QSizeF(m_width, m_height); }
    
    // Visual state - using Qt's selection system
    // Use QGraphicsItem::isSelected() and setSelected()
    
    // Socket management - O(1) performance
    Socket* getSocketByIndex(int index) const;
    int getSocketCount() const;
    void setNodeType(const QString& type);
    QString getNodeType() const { return m_nodeType; }
    
    // Socket registration for performance cache
    void registerSocket(Socket* socket, int index);
    
    // XML-driven socket creation
    void createSocketsFromXml(int inputCount, int outputCount);
    
    // Two-phase positioning: Position all sockets with complete information
    void positionAllSockets(int totalInputs, int totalOutputs);
    
    // Change notification - simple callback, no connect
    void setChangeCallback(void (*callback)(Node*));
    
    // Observer interface for GraphFactory - contract enforcement
    void setObserver(void* observer) { m_observer = observer; }
    bool hasObserver() const { return m_observer != nullptr; }
    void* getObserver() const { return m_observer; }
    
    // Edge connection management - O(degree) performance optimization
    void registerEdge(Edge* edge);
    void unregisterEdge(Edge* edge);
    void updateConnectedEdges();
    
    // Debug/testing helper
    int getIncidentEdgeCount() const { return m_incidentEdges.size(); }

private:
    QUuid m_id;
    QString m_nodeType;
    qreal m_width;
    qreal m_height;
    
    // Performance optimization: cache display string (created once, not every frame)
    mutable QString m_cachedDisplayId;
    
    // Socket cache for O(1) lookups - critical performance fix
    QVector<Socket*> m_sockets;  // Indexed by socket index for O(1) access
    
    // Edge adjacency set for O(degree) edge updates - performance optimization
    QSet<Edge*> m_incidentEdges;  // Edges touching this node (cleaned up by Edge destructor)
    
    // Simple callback - no QObject connect
    void (*m_changeCallback)(Node*);
    
    // Observer for contract enforcement
    void* m_observer;
    
    // Per-node position tracking (fixes global static bug)
    QPointF m_lastPos;
    
    // Dynamic node sizing based on socket count
    void calculateNodeSize(int inputCount, int outputCount);
    
    // Socket creation
    // createStaticSockets() ELIMINATED - unified XML-first creation only
    
    // Visual styling helpers
    void paintSockets(QPainter* painter) const;
};

=== node.cpp ===

#include "node.h"
#include "socket.h"
#include "edge.h"
#include "scene.h"
#include <QPainter>
#include <QStyleOptionGraphicsItem>
#include <QWidget>
#include <QDebug>
#include <QTimer>
#include <libxml/tree.h>

Node::Node(const QUuid& id, const QPointF& position)
    : m_id(id)
    , m_nodeType("DEFAULT")
    , m_width(80.0)
    , m_height(50.0)
    , m_changeCallback(nullptr)
    , m_observer(nullptr)
    , m_lastPos(position)
{
    setPos(position);
    setFlag(QGraphicsItem::ItemIsMovable, true);
    setFlag(QGraphicsItem::ItemIsSelectable, true);
    setFlag(QGraphicsItem::ItemSendsGeometryChanges, true);
    
    // Node creation logging removed - working correctly
}

Node::~Node()
{
    // SAFETY: Invalidate all connected edges before destruction
    // Copy the set to avoid modification during iteration
    QSet<Edge*> edgesCopy = m_incidentEdges;
    for (Edge* edge : edgesCopy) {
        edge->invalidateNode(this);
    }
    
    // Node destruction logging removed - working correctly
}

QRectF Node::boundingRect() const
{
    return QRectF(0, 0, m_width, m_height);
}

void Node::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
    Q_UNUSED(option)
    Q_UNUSED(widget)
    
    QRectF rect = boundingRect();
    
    // Draw node body with rounded corners and gradient
    painter->setRenderHint(QPainter::Antialiasing);
    
    // Enhanced selection highlight using Qt's selection system
    if (isSelected()) {
        // Draw selection glow effect
        painter->setPen(QPen(QColor(255, 69, 0), 6)); // Thick orange border
        painter->setBrush(QColor(255, 245, 205)); // Light orange background
        
        // Add outer glow
        QRectF glowRect = rect.adjusted(-3, -3, 3, 3);
        painter->setPen(QPen(QColor(255, 69, 0, 100), 8));
        painter->drawRoundedRect(glowRect, 10.0, 10.0);
        
        // Restore main border
        painter->setPen(QPen(QColor(255, 69, 0), 4));
    } else {
        painter->setPen(QPen(Qt::darkGray, 2));
        painter->setBrush(QColor(240, 240, 240)); // Light gray background
    }
    
    painter->drawRoundedRect(rect, 8.0, 8.0);
    
    // Draw node type with improved typography
    painter->setPen(Qt::black);
    
    // Performance optimization: static font (created once, not every frame)
    static const QFont nodeFont("Arial", 8, QFont::Bold);
    painter->setFont(nodeFont);
    
    // Draw node type instead of UUID
    QString displayText = m_nodeType;
    painter->drawText(rect, Qt::AlignCenter, displayText);
    
    // Draw subtle node ID below type (smaller)
    if (rect.height() > 35) {
        // Performance optimization: cache display string (created once, not every frame)
        if (m_cachedDisplayId.isEmpty()) {
            m_cachedDisplayId = m_id.toString(QUuid::WithoutBraces).left(6);
        }
        
        static const QFont idFont("Arial", 6);
        painter->setFont(idFont);
        painter->setPen(QColor(120, 120, 120));
        
        QRectF idRect = rect.adjusted(0, rect.height() * 0.6, 0, 0);
        painter->drawText(idRect, Qt::AlignCenter, m_cachedDisplayId);
    }
}

QVariant Node::itemChange(GraphicsItemChange change, const QVariant &value)
{
    if (change == ItemSelectedHasChanged) {
        // Selection tracking logging - what has been selected
        bool isNowSelected = value.toBool();
        qDebug() << "Node" << m_id.toString(QUuid::WithoutBraces).left(8) 
                 << (isNowSelected ? "SELECT" : "DESELECT") << m_nodeType;
        
        // Trigger visual update when selection changes
        update();
    } else if (change == ItemPositionHasChanged) {
        // Only update edges when position actually changes significantly
        QPointF currentPos = value.toPointF();
        if ((currentPos - m_lastPos).manhattanLength() > 5.0) {
            QPointF oldPos = m_lastPos;
            m_lastPos = currentPos;
            
            // Re-enabled with safer edge updates
            updateConnectedEdges();
            
            // Notify observers of node movement via scene
            if (Scene* typedScene = static_cast<Scene*>(scene())) {
                typedScene->notifyNodeMoved(m_id, oldPos, currentPos);
            }
        }
        
        if (m_changeCallback) {
            m_changeCallback(this);
        }
    }
    return QGraphicsItem::itemChange(change, value);
}

void Node::setNodeSize(qreal width, qreal height)
{
    prepareGeometryChange();
    m_width = width;
    m_height = height;
    update();
}

// Removed manual setSelected - using Qt's selection system

void Node::setNodeType(const QString& type)
{
    m_nodeType = type;
    // Socket creation handled by XML-first pipeline - no need to recreate sockets here
    update();
    
    qDebug() << "Node" << m_id.toString(QUuid::WithoutBraces).left(8) << "type:" << type;
}

// createStaticSockets() ELIMINATED - dual pathways removed
// All socket creation now goes through XML-first unified pipeline via createSocketsFromXml()

void Node::createSocketsFromXml(int inputCount, int outputCount)
{
    // CRITICAL: Delete edges connected to this node BEFORE deleting sockets
    // Otherwise edges keep stale Socket* pointers and crash on updatePath()
    Scene* typedScene = static_cast<Scene*>(scene());
    if (typedScene) {
        QList<QUuid> edgesToDelete;
        for (auto it = typedScene->getEdges().begin(); it != typedScene->getEdges().end(); ++it) {
            Edge* edge = it.value();
            if (edge->isConnectedToNode(m_id)) {
                edgesToDelete.append(it.key());
            }
        }
        // Delete edges that reference old sockets
        for (const QUuid& edgeId : edgesToDelete) {
            typedScene->deleteEdge(edgeId);
        }
        qDebug() << "Node::createSocketsFromXml - removed" << edgesToDelete.size() 
                 << "edges before socket recreation for node" << m_id.toString(QUuid::WithoutBraces).left(8);
    }
    
    // Clear existing sockets - both graphics items AND cache
    for (QGraphicsItem* child : childItems()) {
        if (qgraphicsitem_cast<Socket*>(child)) {
            delete child;  // Qt removes from parent automatically
        }
    }
    m_sockets.clear();  // Clear cache to prevent dangling pointers
    
    // Calculate dynamic node size based on socket count
    calculateNodeSize(inputCount, outputCount);
    
    // Phase 1: Create all socket objects (no positioning yet)
    int socketIndex = 0;
    
    // Create input sockets (indexes 0, 1, 2, ...)
    for (int i = 0; i < inputCount; ++i) {
        Socket* inputSocket = new Socket(Socket::Input, this, socketIndex++);
        // Register socket with scene if node has observer (GraphFactory)
        if (hasObserver()) {
            Scene* scene = static_cast<Scene*>(this->scene());
            if (scene) {
                scene->addSocket(inputSocket);
            }
        }
    }
    
    // Create output sockets (continuing index sequence)
    for (int i = 0; i < outputCount; ++i) {
        Socket* outputSocket = new Socket(Socket::Output, this, socketIndex++);
        // Register socket with scene if node has observer (GraphFactory)
        if (hasObserver()) {
            Scene* scene = static_cast<Scene*>(this->scene());
            if (scene) {
                scene->addSocket(outputSocket);
            }
        }
    }
    
    // Phase 2: Position all sockets with complete information
    positionAllSockets(inputCount, outputCount);
    
    qDebug() << "Node" << m_id.toString(QUuid::WithoutBraces).left(8) << inputCount << "IN" << outputCount << "OUT";
}

void Node::positionAllSockets(int totalInputs, int totalOutputs)
{
    // Parse-then-position architecture: Position all sockets with complete information
    // Uses K/O formula: max((2*K + 1), (2*O + 1)) × socketSize with BALANCED CENTERING
    
    // Get actual socket size from existing socket - no fallbacks or magic numbers
    if (m_sockets.isEmpty()) {
        qWarning() << "Node::positionAllSockets() called with no sockets available";
        return;
    }
    
    QSizeF actualSocketSize = m_sockets[0]->getSocketSize();
    qreal socketSize = qMax(actualSocketSize.width(), actualSocketSize.height());
    
    const qreal socketOffset = 4.0; // Distance from node edge
    const qreal socketSpacing = 32.0; // Match calculateNodeSize spacing
    
    QRectF nodeRect = boundingRect();
    int inputIndex = 0;
    int outputIndex = 0;
    
    // VIRTUAL BOUNDING BOX APPROACH: Create centered virtual boxes for socket placement
    qreal nodeHeight = nodeRect.height();
    qreal nodeCenterY = nodeHeight * 0.6; // Visual center, moved down from geometric center
    
    // Create virtual bounding boxes for each socket group using (2*n + 1) * socketSize formula
    qreal inputBoxHeight = (totalInputs > 0) ? (2 * totalInputs + 1) * socketSize : 0;
    qreal outputBoxHeight = (totalOutputs > 0) ? (2 * totalOutputs + 1) * socketSize : 0;
    
    // Align the horizontal center lines: socket box center = node center
    qreal inputBoxCenterY = nodeCenterY;
    qreal outputBoxCenterY = nodeCenterY;
    qreal inputBoxStartY = inputBoxCenterY - (inputBoxHeight / 2.0);
    qreal outputBoxStartY = outputBoxCenterY - (outputBoxHeight / 2.0);
    
    // Calculate socket positions using balanced centering
    for (Socket* socket : m_sockets) {
        if (!socket) continue;
        
        if (socket->getRole() == Socket::Input) {
            // Place socket within the centered virtual input bounding box
            qreal x = -socketOffset;  // Left side of node
            qreal y = inputBoxStartY + socketSize * (2 * inputIndex + 1); // Position at center of each slot
            
            socket->setDirectPosition(x, y);
            inputIndex++;
            
            qDebug() << "VIRTUAL BOX INPUT socket" << inputIndex-1 << "positioned at" << QPointF(x, y);
        } else {
            // Place socket within the centered virtual output bounding box  
            qreal x = nodeRect.width() + socketOffset;  // Right side of node
            qreal y = outputBoxStartY + socketSize * (2 * outputIndex + 1); // Position at center of each slot
            
            socket->setDirectPosition(x, y);
            outputIndex++;
            
            qDebug() << "VIRTUAL BOX OUTPUT socket" << outputIndex-1 << "positioned at" << QPointF(x, y);
        }
    }
    
    // Verify balanced positioning
    qreal requiredInputHeight = (totalInputs > 0) ? (2 * totalInputs + 1) * socketSize : 0;
    qreal requiredOutputHeight = (totalOutputs > 0) ? (2 * totalOutputs + 1) * socketSize : 0;
    qreal requiredHeight = qMax(requiredInputHeight, requiredOutputHeight);
    
    qDebug() << "VIRTUAL BOX POSITIONING: K=" << totalInputs << "inputs (box start:" << inputBoxStartY 
             << "), O=" << totalOutputs << "outputs (box start:" << outputBoxStartY << ")"
             << "| Node height:" << nodeHeight << "| Required:" << requiredHeight
             << "for node" << m_id.toString(QUuid::WithoutBraces).left(8);
}

Socket* Node::getSocketByIndex(int index) const
{
    // O(1) socket lookup using cache - with safety validation
    if (index >= 0 && index < m_sockets.size()) {
        Socket* socket = m_sockets[index];
        if (!socket) {
            qCritical() << "Node::getSocketByIndex() - null socket at index" << index 
                       << "in node" << m_id.toString(QUuid::WithoutBraces).left(8);
            return nullptr;
        }
        // Belt-and-suspenders: check if socket has been deleted
        if (socket->scene() == nullptr) {
            qWarning() << "Node::getSocketByIndex() - socket at index" << index 
                      << "has been deleted (not in scene) in node" << m_id.toString(QUuid::WithoutBraces).left(8);
            return nullptr;
        }
        return socket;
    }
    qWarning() << "Node::getSocketByIndex() - index" << index << "out of bounds [0," 
               << m_sockets.size() << ") in node" << m_id.toString(QUuid::WithoutBraces).left(8);
    return nullptr;
}

int Node::getSocketCount() const
{
    // O(1) socket count using cache
    return m_sockets.size();
}

void Node::registerSocket(Socket* socket, int index)
{
    if (!socket) {
        qCritical() << "Node::registerSocket() - null socket passed for index" << index;
        return;
    }
    
    // Enforce contiguous indices - prevent sparse arrays with nullptr gaps
    if (index != m_sockets.size()) {
        qCritical() << "Node::registerSocket() - index" << index 
                   << "is not contiguous. Expected index" << m_sockets.size() 
                   << "for node" << m_id.toString(QUuid::WithoutBraces).left(8);
        Q_ASSERT(index == m_sockets.size());
        return;
    }
    
    // Append socket to maintain contiguous array
    m_sockets.append(socket);
    
    qDebug() << "Node" << m_id.toString(QUuid::WithoutBraces).left(8) << "socket" << index 
             << (socket->getRole() == Socket::Input ? "IN" : "OUT");
}

void Node::setChangeCallback(void (*callback)(Node*))
{
    m_changeCallback = callback;
}

// ============================================================================
// Edge Management - O(degree) Performance Optimization
// ============================================================================

void Node::registerEdge(Edge* edge)
{
    if (!edge) {
        qWarning() << "Node::registerEdge() - null edge pointer for node" << m_id.toString(QUuid::WithoutBraces).left(8);
        return;
    }
    
    // Debug assertion in development builds
    #ifdef QT_DEBUG
    if (m_incidentEdges.contains(edge)) {
        qWarning() << "Node::registerEdge() - edge already registered with node" << m_id.toString(QUuid::WithoutBraces).left(8);
        return;
    }
    #endif
    
    m_incidentEdges.insert(edge);
    // Edge registration logging removed - working correctly
}

void Node::unregisterEdge(Edge* edge)
{
    if (!edge) {
        qWarning() << "Node::unregisterEdge() - null edge pointer for node" << m_id.toString(QUuid::WithoutBraces).left(8);
        return;
    }
    
    // Debug assertion in development builds
    #ifdef QT_DEBUG
    if (!m_incidentEdges.contains(edge)) {
        qWarning() << "Node::unregisterEdge() - edge not found in node" << m_id.toString(QUuid::WithoutBraces).left(8);
        return;
    }
    #endif
    
    m_incidentEdges.remove(edge);
    // Edge unregistration logging removed - working correctly
}

void Node::updateConnectedEdges()
{
    // NEW: O(degree) performance - only update edges actually connected to this node
    for (Edge* edge : m_incidentEdges) {
        edge->updatePath();
    }
    
    // Edge update logging removed - working correctly
}


// Sockets now paint themselves as QGraphicsItems - no need for this method

xmlNodePtr Node::write(xmlDocPtr doc, xmlNodePtr repr) const
{
    xmlNodePtr node = xmlNewNode(nullptr, BAD_CAST "node");
    
    // Core attributes
    xmlSetProp(node, BAD_CAST "id", BAD_CAST m_id.toString(QUuid::WithoutBraces).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "x", BAD_CAST QString::number(pos().x()).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "y", BAD_CAST QString::number(pos().y()).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "type", BAD_CAST m_nodeType.toUtf8().constData());
    
    // Count sockets by role
    int inputCount = 0, outputCount = 0;
    for (QGraphicsItem* child : childItems()) {
        if (Socket* socket = qgraphicsitem_cast<Socket*>(child)) {
            if (socket->getRole() == Socket::Input) inputCount++;
            else if (socket->getRole() == Socket::Output) outputCount++;
        }
    }
    
    // Save socket configuration as XML attributes
    xmlSetProp(node, BAD_CAST "inputs", BAD_CAST QString::number(inputCount).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "outputs", BAD_CAST QString::number(outputCount).toUtf8().constData());
    
    if (repr) {
        xmlAddChild(repr, node);
    } else {
        xmlDocSetRootElement(doc, node);
    }
    
    return node;
}

void Node::read(xmlNodePtr node)
{
    if (!node) return;
    
    // Read UUID
    xmlChar* idStr = xmlGetProp(node, BAD_CAST "id");
    if (idStr) {
        m_id = QUuid(QString::fromUtf8((char*)idStr));
        xmlFree(idStr);
    }
    
    // Read node type 
    xmlChar* typeStr = xmlGetProp(node, BAD_CAST "type");
    if (typeStr) {
        m_nodeType = QString::fromUtf8((char*)typeStr);
        xmlFree(typeStr);
    }
    
    // Read socket configuration from XML attributes
    int inputCount = 1;  // Default
    int outputCount = 1; // Default
    
    xmlChar* inputsStr = xmlGetProp(node, BAD_CAST "inputs");
    if (inputsStr) {
        inputCount = QString::fromUtf8((char*)inputsStr).toInt();
        xmlFree(inputsStr);
    }
    
    xmlChar* outputsStr = xmlGetProp(node, BAD_CAST "outputs");
    if (outputsStr) {
        outputCount = QString::fromUtf8((char*)outputsStr).toInt();
        xmlFree(outputsStr);
    }
    
    // Create sockets based on XML configuration
    createSocketsFromXml(inputCount, outputCount);
    
    // Read position
    xmlChar* xStr = xmlGetProp(node, BAD_CAST "x");
    xmlChar* yStr = xmlGetProp(node, BAD_CAST "y");
    if (xStr && yStr) {
        qreal x = QString::fromUtf8((char*)xStr).toDouble();
        qreal y = QString::fromUtf8((char*)yStr).toDouble();
        setPos(x, y);
        xmlFree(xStr);
        xmlFree(yStr);
    }
    
    update();
}

void Node::calculateNodeSize(int inputCount, int outputCount)
{
    // Calculate required height based on socket count
    int maxSockets = qMax(inputCount, outputCount);
    
    // Constants matching socket configuration
    const qreal socketSpacing = 32.0;  // Must match socket.cpp
    const qreal minNodeHeight = 50.0;  // Minimum height for node text
    const qreal topPadding = 14.0;     // Top padding (socket width)
    const qreal bottomPadding = 14.0;  // Bottom padding (socket width)
    const qreal minNodeWidth = 100.0;  // Minimum width for node text
    
    // Calculate height based on socket count
    if (maxSockets > 0) {
        // Height = top padding + (sockets * spacing) + bottom padding
        qreal requiredHeight = topPadding + (maxSockets - 1) * socketSpacing + 14.0 + bottomPadding;
        m_height = qMax(minNodeHeight, requiredHeight);
    } else {
        m_height = minNodeHeight;
    }
    
    // Calculate width based on node type and content
    QString displayText = m_nodeType + " " + m_id.toString(QUuid::WithoutBraces).left(8);
    QFont font("Arial", 10);
    QFontMetrics metrics(font);
    qreal textWidth = metrics.horizontalAdvance(displayText) + 20; // Add padding
    
    m_width = qMax(minNodeWidth, textWidth);
    
    // Ensure node is wide enough to accommodate sockets with proper spacing
    const qreal socketOffset = 8.0; // Space for socket offset from edges
    m_width = qMax(m_width, socketOffset * 2 + 20); // Minimum width for sockets
    
    // Notify Qt graphics system of geometry change
    prepareGeometryChange();
    
    qDebug() << "Node" << m_id.toString(QUuid::WithoutBraces).left(8) 
             << "resized to" << m_width << "x" << m_height 
             << "for" << inputCount << "inputs," << outputCount << "outputs";
}

=== socket.h ===

#pragma once

#include <QGraphicsItem>
#include <QPainter>
#include <QStyleOptionGraphicsItem>
#include <QWidget>
#include <QGraphicsSceneMouseEvent>
#include <QUuid>
#include <QPointF>
#include <QString>
#include <QColor>
#include <QRectF>
#include <libxml/tree.h>

class Node;
class Edge;

/**
 * Socket - QGraphicsItem connection point on a node
 * 
 * Core principles:
 * - QGraphicsItem child of Node QGraphicsItem
 * - Self-serializing like its parent node
 * - Handles mouse events for connection creation
 * - Position managed by Qt parent-child system
 * - Index-based identification within parent node
 */
class Socket : public QGraphicsItem
{
public:
    enum Role {
        Input,
        Output
    };
    
    enum ConnectionState {
        Disconnected,
        Connecting,    // During ghost edge drag
        Connected,     // Has connected edge
        Highlighted    // Target of ghost edge
    };
    
    // Helper for debugging
    static const char* roleToString(Role role) {
        switch (role) {
            case Input: return "INPUT";
            case Output: return "OUTPUT";
            default: return "UNKNOWN";
        }
    }
    
    Socket(Role role, Node* parentNode, int index);
    
    // Core identity - NO UUID, just index within parent node
    int getIndex() const { return m_index; }
    Role getRole() const { return m_role; }
    // Access parent node via Qt's system  
    Node* getParentNode() const;
    
    // Self-serialization interface
    xmlNodePtr write(xmlDocPtr doc, xmlNodePtr repr = nullptr) const;
    void read(xmlNodePtr node);
    
    // QGraphicsItem interface
    QRectF boundingRect() const override;
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) override;
    
    // Mouse events for connection creation
    void mousePressEvent(QGraphicsSceneMouseEvent *event) override;
    void mouseReleaseEvent(QGraphicsSceneMouseEvent *event) override;
    void hoverEnterEvent(QGraphicsSceneHoverEvent *event) override;
    void hoverLeaveEvent(QGraphicsSceneHoverEvent *event) override;
    
    // Connection state
    bool isConnected() const { return m_connectedEdge != nullptr; }
    void setConnectedEdge(Edge* edge) { m_connectedEdge = edge; updateConnectionState(); }
    Edge* getConnectedEdge() const { return m_connectedEdge; }
    
    // Visual connection state
    ConnectionState getConnectionState() const { return m_connectionState; }
    void setConnectionState(ConnectionState state) { m_connectionState = state; update(); }
    void updateConnectionState() { 
        setConnectionState(m_connectedEdge ? Connected : Disconnected); 
    }
    
    // Direct position assignment - no calculations, just assignment
    void setDirectPosition(qreal x, qreal y) { setPos(x, y); }
    
    // Size properties for edge connection calculations
    qreal getRadius() const { return m_radius; }
    QSizeF getSocketSize() const { return boundingRect().size(); }
    
    // Visual state for drag-and-drop feedback (disabled)
    // VisualState getVisualState() const { return m_visualState; }
    // void setVisualState(VisualState state) { m_visualState = state; update(); }

private:
    Role m_role;
    int m_index;                 // Socket index within parent node (0, 1, 2...)
    Edge* m_connectedEdge;       // Connected edge (if any)  
    ConnectionState m_connectionState; // Visual connection state
    qreal m_radius;
    bool m_hovered;
    qreal m_hoverOpacity; // Smooth hover opacity transition
    bool m_pressed; // Click feedback state
    
    // Performance optimization: cache index string (created once, not every frame)
    mutable QString m_cachedIndexString;
    
};

=== socket.cpp ===

#include "socket.h"
#include "node.h"
#include "edge.h"
#include "scene.h"
#include <QPainter>
#include <QGraphicsSceneMouseEvent>
#include <QDebug>
#include <QDateTime>
#include <QtMath>

Socket::Socket(Role role, Node* parentNode, int index)
    : QGraphicsItem(parentNode)
    , m_role(role)
    , m_index(index)
    , m_connectedEdge(nullptr)
    , m_connectionState(Disconnected)
    , m_radius(8.0)
    , m_hovered(false)
    , m_hoverOpacity(0.0)
    , m_pressed(false)
{
    setAcceptHoverEvents(true);
    setFlag(QGraphicsItem::ItemIsSelectable, true);
    
    // Set socket z-order: above nodes (0) but below edges (2)
    setZValue(1);
    
    // NO positioning in constructor - will be positioned later with complete information
    
    // Register with parent node for O(1) lookups
    if (parentNode) {
        parentNode->registerSocket(this, m_index);
    }
    
    qDebug() << "+Socket" << m_index << (m_role == Input ? "IN" : "OUT");
}

Node* Socket::getParentNode() const
{
    return qgraphicsitem_cast<Node*>(parentItem());
}

QRectF Socket::boundingRect() const
{
    // Smaller rounded square sockets with better proportions
    return QRectF(-7, -7, 14, 14);
}

void Socket::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
    Q_UNUSED(option)
    Q_UNUSED(widget)
    
    painter->setRenderHint(QPainter::Antialiasing);
    
    // Color-coded sockets like upper level system
    QColor socketColor;
    QColor borderColor;
    
    if (m_role == Input) {
        socketColor = QColor(100, 149, 237); // Cornflower blue
        borderColor = QColor(70, 130, 180);  // Steel blue
    } else {
        socketColor = QColor(220, 20, 60);    // Crimson red
        borderColor = QColor(178, 34, 34);    // Fire brick
    }
    
    // Add smooth hover effect with opacity
    if (m_hovered || m_hoverOpacity > 0.0) {
        qreal hoverAmount = m_hovered ? 1.0 : m_hoverOpacity;
        socketColor = QColor::fromRgb(
            socketColor.red() + (50 * hoverAmount),
            socketColor.green() + (50 * hoverAmount),
            socketColor.blue() + (50 * hoverAmount)
        );
        borderColor = QColor::fromRgb(
            borderColor.red() + (30 * hoverAmount),
            borderColor.green() + (30 * hoverAmount),
            borderColor.blue() + (30 * hoverAmount)
        );
    }
    
    // Draw socket as circular with enhanced styling
    QRectF rect = boundingRect();
    
    // Apply pressed state effect
    if (m_pressed) {
        socketColor = socketColor.darker(120);
        borderColor = borderColor.darker(120);
        rect = rect.adjusted(1, 1, -1, -1); // Slight inset when pressed
    }
    
    // Add connection state visual feedback
    switch (m_connectionState) {
        case Connected:
            {
                // ENHANCED: Clear visual feedback for connected sockets
                
                // Draw socket body (slightly dimmed to show "occupied" state)
                painter->setBrush(socketColor.darker(110));
                painter->setPen(QPen(borderColor, 2));
                painter->drawRoundedRect(rect, 3.0, 3.0);
                
                // Draw prominent BLACK connection dot in center
                QRectF dotRect = rect.adjusted(3, 3, -3, -3); // Larger dot for visibility
                painter->setBrush(QBrush(Qt::black));
                painter->setPen(QPen(Qt::black, 1));
                painter->drawEllipse(dotRect); // Black circular dot
                
                // Optional: Add subtle glow around socket
                if (m_hovered) {
                    painter->setBrush(Qt::NoBrush);
                    painter->setPen(QPen(borderColor.lighter(150), 1));
                    painter->drawRoundedRect(rect.adjusted(-1, -1, 1, 1), 4.0, 4.0);
                }
            }
            break;
            
        case Highlighted:
            {
                // Draw pulsing highlight for valid connection targets
                // Use time-based pulsing effect
                qreal pulse = 0.5 + 0.5 * qSin(QDateTime::currentMSecsSinceEpoch() * 0.01);
                QColor highlightColor = QColor(0, 255, 0, 80 + 40 * pulse);
                painter->setBrush(QBrush(highlightColor));
                painter->setPen(QPen(QColor(0, 255, 0, 150 + 50 * pulse), 2));
                painter->drawRoundedRect(rect.adjusted(-2, -2, 2, 2), 4.0, 4.0);
                
                painter->setBrush(socketColor.lighter(130));
                painter->setPen(QPen(borderColor, 2));
                painter->drawRoundedRect(rect, 3.0, 3.0);
            }
            break;
            
        case Connecting:
            // Draw connecting state (for source socket during drag)
            painter->setBrush(QBrush(socketColor.lighter(110)));
            painter->setPen(QPen(borderColor.darker(120), 3));
            painter->drawRoundedRect(rect, 3.0, 3.0);
            break;
            
        case Disconnected:
        default:
            // Normal socket appearance - rounded square
            painter->setBrush(socketColor);
            painter->setPen(QPen(borderColor, 2));
            painter->drawRoundedRect(rect, 3.0, 3.0);
            break;
    }
    
    // Draw socket index number with better contrast
    if (rect.width() > 8) { // Only draw index if socket is large enough
        painter->setPen(Qt::white);
        
        // Performance optimization: static font (created once, not every frame)
        static const QFont socketFont("Arial", 7, QFont::Bold);
        painter->setFont(socketFont);
        
        // Performance optimization: cache index string (created once, not every frame)
        if (m_cachedIndexString.isEmpty()) {
            m_cachedIndexString = QString::number(m_index);
        }
        painter->drawText(rect, Qt::AlignCenter, m_cachedIndexString);
    }
}

void Socket::mousePressEvent(QGraphicsSceneMouseEvent *event)
{
    m_pressed = true;
    update(); // Show pressed state immediately
    
    // DISABLE dragging from connected sockets
    if (isConnected()) {
        qDebug() << "Socket" << m_index << "is connected - dragging disabled";
        event->ignore(); // Don't start drag operations on connected sockets
        return;
    }
    
    if (event->button() == Qt::LeftButton) {
        qDebug() << "Socket clicked: index:" << m_index << "role:" << (m_role == Input ? "Input" : "Output");
        // TODO: Start edge creation drag
        event->accept();
    } else if (event->button() == Qt::RightButton && m_role == Output) {
        qDebug() << "Socket right-clicked: index:" << m_index << "role:" << (m_role == Input ? "Input" : "Output");
        // Start ghost edge from output socket
        Scene* scene = qobject_cast<Scene*>(this->scene());
        if (scene) {
            scene->startGhostEdge(this, event->scenePos());
        }
        event->accept();
    }
    QGraphicsItem::mousePressEvent(event);
}

void Socket::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)
{
    m_pressed = false;
    update(); // Remove pressed state
    
    if (event->button() == Qt::LeftButton) {
        qDebug() << "Socket released: index:" << m_index;
        // TODO: Complete edge connection
        event->accept();
    }
    QGraphicsItem::mouseReleaseEvent(event);
}

void Socket::hoverEnterEvent(QGraphicsSceneHoverEvent *event)
{
    Q_UNUSED(event)
    m_hovered = true;
    m_hoverOpacity = 1.0; // Animate to full opacity
    update();
}

void Socket::hoverLeaveEvent(QGraphicsSceneHoverEvent *event)
{
    Q_UNUSED(event)
    m_hovered = false;
    m_hoverOpacity = 0.0; // Animate to no opacity
    update();
}


xmlNodePtr Socket::write(xmlDocPtr doc, xmlNodePtr repr) const
{
    Q_UNUSED(doc)
    Q_UNUSED(repr)
    // Sockets are written as part of their parent node
    return nullptr;
}

void Socket::read(xmlNodePtr node)
{
    Q_UNUSED(node)
    // Socket properties read from parent node's socket definitions
    // Position is set by parent node's positionAllSockets() method
}




=== edge.h ===

#pragma once

#include <QGraphicsItem>
#include <QPainter>
#include <QStyleOptionGraphicsItem>
#include <QWidget>
#include <QUuid>
#include <QString>
#include <QColor>
#include <QPainterPath>
#include <QPainterPathStroker>
#include <QPointF>
#include <functional>
#include <libxml/tree.h>

class Socket;
class Node;

/**
 * Edge - Connection between two sockets
 * 
 * Core principles:
 * - Self-serializing connection between socket UUIDs
 * - No QObject inheritance or connect usage
 * - Draws path from socket to socket
 * - References sockets by UUID, not pointers
 */
class Edge : public QGraphicsItem
{
public:
    Edge(const QUuid& id = QUuid::createUuid(),
         const QUuid& fromSocketId = QUuid(),
         const QUuid& toSocketId = QUuid());
    ~Edge(); // Destructor for node unregistration
    
    // Core identity
    const QUuid& getId() const { return m_id; }
    
    // Self-serialization interface
    xmlNodePtr write(xmlDocPtr doc, xmlNodePtr repr = nullptr) const;
    void read(xmlNodePtr node);
    
    // QGraphicsItem interface
    QRectF boundingRect() const override;
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) override;
    QPainterPath shape() const override;
    QVariant itemChange(GraphicsItemChange change, const QVariant &value) override;
    
    // Connection management - clean design uses node+index only
    // No socket UUIDs - edges resolved via resolveConnections() method
    
    // Visual state uses Qt's selection system
    // Use QGraphicsItem::isSelected() and setSelected()
    
    // Path update - call when socket positions change
    void updatePath();
    
    // Mouse event debugging and interaction
    void mousePressEvent(QGraphicsSceneMouseEvent *event) override;
    void mouseReleaseEvent(QGraphicsSceneMouseEvent *event) override;
    void hoverEnterEvent(QGraphicsSceneHoverEvent *event) override;
    void hoverLeaveEvent(QGraphicsSceneHoverEvent *event) override;
    
    // Connection checking
    bool isConnectedToNode(const QString& nodeId) const;
    bool isConnectedToNode(const QUuid& nodeId) const;  // Optimized UUID version
    
    // Socket resolution after all nodes are loaded
    bool resolveConnections(class Scene* scene);
    
    // Direct connection methods (optimization for GraphFactory)
    void setConnectionData(const QString& fromNodeId, const QString& toNodeId, 
                          int fromSocketIndex, int toSocketIndex);
    void setResolvedSockets(Socket* fromSocket, Socket* toSocket);
    
    // Manual weak pointer system for safe destruction
    void invalidateNode(const Node* node);
    
    // Public accessors for layout engine
    Node* getFromNode() const { return m_fromNode; }
    Node* getToNode() const { return m_toNode; }
    Socket* getFromSocket() const { return m_fromSocket; }
    Socket* getToSocket() const { return m_toSocket; }
    
    // Connection data accessors (for validation)
    QString getFromNodeId() const { return m_fromNodeId; }
    QString getToNodeId() const { return m_toNodeId; }
    int getFromSocketIndex() const { return m_fromSocketIndex; }
    int getToSocketIndex() const { return m_toSocketIndex; }

private:
    QUuid m_id;
    QString m_fromNodeId;     // Store node IDs from XML (for serialization)
    QString m_toNodeId;
    QUuid m_fromNodeUuid;     // Cached UUIDs for fast comparison
    QUuid m_toNodeUuid;
    int m_fromSocketIndex;    // Store socket indices from XML
    int m_toSocketIndex;
    Socket* m_fromSocket;     // Resolved socket pointers
    Socket* m_toSocket;
    
    // Manual weak pointers for safe destruction (nulled by Node::~Node)
    Node* m_fromNode;         // Source node (may be nullptr during destruction)
    Node* m_toNode;           // Destination node (may be nullptr during destruction)
    
    // Cached path for rendering
    QPainterPath m_path;
    QRectF m_boundingRect;
    
    // Interaction state
    bool m_hovered;
    
    #ifdef QT_DEBUG
    // Per-edge debug counter (thread-safe, per-instance)
    mutable int m_shapeCallCount;
    #endif
    
    // Visual styling
    void buildPath(const QPointF& start, const QPointF& end);
};

=== edge.cpp ===

#include "edge.h"
#include "socket.h"
#include "node.h"
#include "scene.h"
#include <QPainter>
#include <QStyleOptionGraphicsItem>
#include <QWidget>
#include <QDebug>
#include <libxml/tree.h>
#include <cmath>

Edge::Edge(const QUuid& id, const QUuid& fromSocketId, const QUuid& toSocketId)
    : m_id(id)
    , m_fromNodeId()
    , m_toNodeId()
    , m_fromNodeUuid()
    , m_toNodeUuid()
    , m_fromSocketIndex(-1)
    , m_toSocketIndex(-1)
    , m_fromSocket(nullptr)
    , m_toSocket(nullptr)
    , m_fromNode(nullptr)
    , m_toNode(nullptr)
    , m_hovered(false)
    #ifdef QT_DEBUG
    , m_shapeCallCount(0)
    #endif
{
    Q_UNUSED(fromSocketId)  // Legacy parameter, not used in clean design
    Q_UNUSED(toSocketId)    // Legacy parameter, not used in clean design
    setFlag(QGraphicsItem::ItemIsSelectable, true);
    setFlag(QGraphicsItem::ItemHasNoContents, false); // Ensure we control our own drawing
    setAcceptHoverEvents(true);  // Enable hover events for better interaction
    
    // Z-order hierarchy: Nodes(0) < Sockets(1) < Edges(2)
    // Edges appear on top of sockets for "plugged-in" visual effect
    setZValue(2);
    
    qDebug() << "+Edge" << m_id.toString(QUuid::WithoutBraces).left(8);
    // Don't call updatePath() here - sockets not resolved yet
}

Edge::~Edge()
{
    // SAFETY: Only touch nodes that are still valid (not nulled by invalidateNode)
    if (m_fromNode) {
        m_fromNode->unregisterEdge(this);
    }
    if (m_toNode) {
        m_toNode->unregisterEdge(this);
    }
    
    qDebug() << "~Edge" << m_id.toString(QUuid::WithoutBraces).left(8);
}

void Edge::invalidateNode(const Node* node)
{
    // Manual weak pointer nulling - called by Node::~Node()
    if (node == m_fromNode) {
        m_fromNode = nullptr;
    }
    if (node == m_toNode) {
        m_toNode = nullptr;
    }
}

QRectF Edge::boundingRect() const
{
    return m_boundingRect;
}

void Edge::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
    Q_UNUSED(widget)
    Q_UNUSED(option) // Don't use Qt's default drawing options
    
    painter->setRenderHint(QPainter::Antialiasing);
    
    // Save painter state to ensure no side effects
    painter->save();
    
    // Make sure no brush is set (no fill)
    painter->setBrush(Qt::NoBrush);
    
    // IMPROVED: Multi-layer cable-like rendering with depth
    if (isSelected()) {
        // Selection: bright orange with glow effect
        QPen glowPen(QColor(255, 69, 0, 100), 12);
        glowPen.setCapStyle(Qt::RoundCap);
        painter->setPen(glowPen);
        painter->drawPath(m_path);
        
        QPen selectionPen(QColor(255, 69, 0), 6);
        selectionPen.setCapStyle(Qt::RoundCap);
        painter->setPen(selectionPen);
        painter->drawPath(m_path);
    } else if (m_hovered) {
        // Hover: blue with subtle glow
        QPen hoverGlowPen(QColor(100, 150, 255, 80), 8);
        hoverGlowPen.setCapStyle(Qt::RoundCap);
        painter->setPen(hoverGlowPen);
        painter->drawPath(m_path);
        
        QPen hoverPen(QColor(100, 150, 255), 4);
        hoverPen.setCapStyle(Qt::RoundCap);
        painter->setPen(hoverPen);
        painter->drawPath(m_path);
    } else {
        // Normal: layered cable appearance with depth
        // Layer 1: Shadow for depth
        QPen shadowPen(QColor(0, 0, 0, 60), 5);
        shadowPen.setCapStyle(Qt::RoundCap);
        painter->setPen(shadowPen);
        QPainterPath shadowPath = m_path;
        shadowPath.translate(1.5, 1.5);
        painter->drawPath(shadowPath);
        
        // Layer 2: Dark outline for definition
        QPen outlinePen(QColor(40, 40, 40), 4);
        outlinePen.setCapStyle(Qt::RoundCap);
        painter->setPen(outlinePen);
        painter->drawPath(m_path);
        
        // Layer 3: Main cable body with subtle gradient effect
        QPen mainPen(QColor(85, 85, 85), 3);
        mainPen.setCapStyle(Qt::RoundCap);
        painter->setPen(mainPen);
        painter->drawPath(m_path);
        
        // Layer 4: Highlight for 3D cable effect
        QPen highlightPen(QColor(120, 120, 120), 1);
        highlightPen.setCapStyle(Qt::RoundCap);
        painter->setPen(highlightPen);
        painter->drawPath(m_path);
    }
    
    // Restore painter state
    painter->restore();
}

QPainterPath Edge::shape() const
{
    // Create a much wider path for easier selection - very generous selection area
    QPainterPathStroker stroker;
    stroker.setWidth(20);  // Very wide selection area for easy clicking
    stroker.setCapStyle(Qt::RoundCap);
    stroker.setJoinStyle(Qt::RoundJoin);
    QPainterPath selectionPath = stroker.createStroke(m_path);
    
    #ifdef QT_DEBUG
    // Debug: Log when shape is queried (indicates potential interaction)
    // Per-edge counter avoids thread safety issues with global static
    ++m_shapeCallCount;
    if (m_shapeCallCount % 100 == 0) {  // Throttled logging to avoid spam
        qDebug() << "Edge" << m_id.toString(QUuid::WithoutBraces).left(8) 
                 << "shape() called" << m_shapeCallCount << "times";
    }
    #endif
    
    return selectionPath;
}

// Removed manual setSelected - using Qt's selection system

QVariant Edge::itemChange(GraphicsItemChange change, const QVariant &value)
{
    if (change == ItemSelectedHasChanged) {
        // Selection tracking logging - what has been selected
        bool wasSelected = isSelected();
        bool willBeSelected = value.toBool();
        qDebug() << "=== EDGE SELECTION CHANGE ===";
        qDebug() << "Edge" << m_id.toString(QUuid::WithoutBraces).left(8) 
                 << "changing from" << (wasSelected ? "SELECTED" : "NOT_SELECTED")
                 << "to" << (willBeSelected ? "SELECTED" : "NOT_SELECTED");
        qDebug() << "Edge will" << (willBeSelected ? "turn ORANGE" : "turn NORMAL");
        
        // Trigger visual update when selection changes
        update();
        qDebug() << "=== EDGE SELECTION CHANGE COMPLETE ===";
    }
    return QGraphicsItem::itemChange(change, value);
}

void Edge::mousePressEvent(QGraphicsSceneMouseEvent *event)
{
    qDebug() << "=== EDGE MOUSE PRESS START ===";
    qDebug() << "Edge" << m_id.toString(QUuid::WithoutBraces).left(8) << "mousePressEvent at" << event->pos();
    qDebug() << "Edge was selected BEFORE mouse press:" << isSelected();
    qDebug() << "Mouse button:" << (event->button() == Qt::LeftButton ? "LEFT" : "OTHER");
    qDebug() << "Modifiers:" << event->modifiers();
    
    QGraphicsItem::mousePressEvent(event);
    
    qDebug() << "Edge is selected AFTER mouse press:" << isSelected();
    qDebug() << "=== EDGE MOUSE PRESS END ===";
}

void Edge::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)
{
    qDebug() << "=== EDGE MOUSE RELEASE START ===";
    qDebug() << "Edge" << m_id.toString(QUuid::WithoutBraces).left(8) << "mouseReleaseEvent at" << event->pos();
    qDebug() << "Edge is selected BEFORE mouse release:" << isSelected();
    
    QGraphicsItem::mouseReleaseEvent(event);
    
    qDebug() << "Edge is selected AFTER mouse release:" << isSelected();
    qDebug() << "Edge turns orange (selected):" << (isSelected() ? "YES" : "NO");
    qDebug() << "=== EDGE MOUSE RELEASE END ===";
}

void Edge::hoverEnterEvent(QGraphicsSceneHoverEvent *event)
{
    Q_UNUSED(event)
    m_hovered = true;
    qDebug() << "Edge" << m_id.toString(QUuid::WithoutBraces).left(8) << "HOVER ENTER";
    update();  // Redraw to show hover effect
    QGraphicsItem::hoverEnterEvent(event);
}

void Edge::hoverLeaveEvent(QGraphicsSceneHoverEvent *event)
{
    Q_UNUSED(event)
    m_hovered = false;
    qDebug() << "Edge" << m_id.toString(QUuid::WithoutBraces).left(8) << "HOVER LEAVE";
    update();  // Redraw to remove hover effect
    QGraphicsItem::hoverLeaveEvent(event);
}

void Edge::updatePath()
{
    // Simple and clean: use direct socket pointers
    if (!m_fromSocket || !m_toSocket) {
        // Edge not resolved yet - notify BSP cache before clearing
        prepareGeometryChange();
        m_path = QPainterPath();
        m_boundingRect = QRectF();
        return;
    }
    
    // FIXED: Connect to exact socket centers in scene coordinates
    // Use mapToScene to get the socket's center point in scene coordinates
    QRectF fromRect = m_fromSocket->boundingRect();
    QRectF toRect = m_toSocket->boundingRect();
    
    // Get the center of each socket in its local coordinates, then map to scene
    QPointF start = m_fromSocket->mapToScene(fromRect.center());
    QPointF end = m_toSocket->mapToScene(toRect.center());
    
    buildPath(start, end);
}



void Edge::buildPath(const QPointF& start, const QPointF& end)
{
    // Validate input points
    if (start.isNull() || end.isNull() || !qIsFinite(start.x()) || !qIsFinite(start.y()) || 
        !qIsFinite(end.x()) || !qIsFinite(end.y())) {
        // Notify BSP cache before clearing
        prepareGeometryChange();
        m_path = QPainterPath();
        m_boundingRect = QRectF();
        return;
    }
    
    // Clear and rebuild path safely
    m_path.clear();
    
    // ENHANCED: Connect directly to socket centers (no adjustment needed)
    // Since updatePath() now provides socket centers, use them directly
    QPointF adjustedStart = start;
    QPointF adjustedEnd = end;
    
    m_path.moveTo(adjustedStart);
    
    // IMPROVED: Dynamic curve calculation based on distance and orientation
    qreal dx = adjustedEnd.x() - adjustedStart.x();
    qreal dy = adjustedEnd.y() - adjustedStart.y();
    qreal distance = std::sqrt(dx * dx + dy * dy);
    
    // Adaptive control point calculation for better curves
    qreal horizontalFactor = qAbs(dx) / qMax(distance, 1.0);
    qreal verticalFactor = qAbs(dy) / qMax(distance, 1.0);
    
    // Dynamic control offset based on distance and direction
    qreal controlOffset;
    if (horizontalFactor > 0.8) {
        // Mostly horizontal: use classic Bezier with distance-based offset
        controlOffset = qMax(qAbs(dx) * 0.4, qMin(distance * 0.3, 150.0));
    } else {
        // More vertical: tighter curves for better routing
        controlOffset = qMax(40.0, qMin(distance * 0.2, 80.0));
    }
    
    // Enhanced control point positioning for natural cable-like curves
    QPointF control1, control2;
    
    if (dx >= 0) {
        // Left-to-right: standard horizontal Bezier
        control1 = adjustedStart + QPointF(controlOffset, 0);
        control2 = adjustedEnd - QPointF(controlOffset, 0);
    } else {
        // Right-to-left: S-curve for better visual routing
        qreal verticalOffset = qAbs(dy) * 0.3;
        control1 = adjustedStart + QPointF(controlOffset * 0.6, dy > 0 ? verticalOffset : -verticalOffset);
        control2 = adjustedEnd - QPointF(controlOffset * 0.6, dy > 0 ? verticalOffset : -verticalOffset);
    }
    
    // Create smooth cubic Bezier curve
    m_path.cubicTo(control1, control2, adjustedEnd);
    
    // Notify Qt's BSP cache before changing bounding rectangle
    prepareGeometryChange();
    
    // Update bounding rectangle with validation
    QRectF pathBounds = m_path.boundingRect();
    if (pathBounds.isValid()) {
        // Inflate by strokeWidth/2 = 10 to match stroker.setWidth(20)
        m_boundingRect = pathBounds.adjusted(-10, -10, 10, 10);
    } else {
        // Inflate by strokeWidth/2 = 10 to match stroker.setWidth(20)
        m_boundingRect = QRectF(start, end).normalized().adjusted(-10, -10, 10, 10);
    }
}


xmlNodePtr Edge::write(xmlDocPtr doc, xmlNodePtr repr) const
{
    xmlNodePtr node = xmlNewNode(nullptr, BAD_CAST "edge");
    
    // Core attributes - clean design uses node+index format
    xmlSetProp(node, BAD_CAST "id", BAD_CAST m_id.toString(QUuid::WithoutBraces).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "fromNode", BAD_CAST m_fromNodeId.toUtf8().constData());
    xmlSetProp(node, BAD_CAST "toNode", BAD_CAST m_toNodeId.toUtf8().constData());
    xmlSetProp(node, BAD_CAST "fromSocketIndex", BAD_CAST QString::number(m_fromSocketIndex).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "toSocketIndex", BAD_CAST QString::number(m_toSocketIndex).toUtf8().constData());
    
    if (repr) {
        xmlAddChild(repr, node);
    } else {
        xmlDocSetRootElement(doc, node);
    }
    
    return node;
}

void Edge::read(xmlNodePtr node)
{
    if (!node) return;
    
    // Read UUID
    xmlChar* idStr = xmlGetProp(node, BAD_CAST "id");
    if (idStr) {
        m_id = QUuid(QString::fromUtf8((char*)idStr));
        xmlFree(idStr);
    }
    
    // Read node+index references - store for later resolution
    // Support both formats: new (fromNode/toNode) and legacy (from/to)
    xmlChar* fromNodeStr = xmlGetProp(node, BAD_CAST "fromNode");
    if (!fromNodeStr) fromNodeStr = xmlGetProp(node, BAD_CAST "from");
    
    xmlChar* toNodeStr = xmlGetProp(node, BAD_CAST "toNode");
    if (!toNodeStr) toNodeStr = xmlGetProp(node, BAD_CAST "to");
    
    xmlChar* fromIndexStr = xmlGetProp(node, BAD_CAST "fromSocketIndex");
    if (!fromIndexStr) fromIndexStr = xmlGetProp(node, BAD_CAST "from-socket");
    
    xmlChar* toIndexStr = xmlGetProp(node, BAD_CAST "toSocketIndex");
    if (!toIndexStr) toIndexStr = xmlGetProp(node, BAD_CAST "to-socket");
    
    if (!fromNodeStr || !toNodeStr || !fromIndexStr || !toIndexStr) {
        qCritical() << "Edge::read() - Missing required node+index attributes";
        if (fromNodeStr) xmlFree(fromNodeStr);
        if (toNodeStr) xmlFree(toNodeStr);
        if (fromIndexStr) xmlFree(fromIndexStr);
        if (toIndexStr) xmlFree(toIndexStr);
        return;
    }
    
    // Store data for later resolution - don't try to resolve now
    m_fromNodeId = QString::fromUtf8((char*)fromNodeStr);
    m_toNodeId = QString::fromUtf8((char*)toNodeStr);
    m_fromSocketIndex = QString::fromUtf8((char*)fromIndexStr).toInt();
    m_toSocketIndex = QString::fromUtf8((char*)toIndexStr).toInt();
    
    // Performance optimization: cache UUIDs for fast comparison
    m_fromNodeUuid = QUuid(m_fromNodeId);
    m_toNodeUuid = QUuid(m_toNodeId);
    
    qDebug() << "Edge: Stored connection data fromNode" << m_fromNodeId.left(8) 
             << "socket" << m_fromSocketIndex << "-> toNode" << m_toNodeId.left(8) 
             << "socket" << m_toSocketIndex;
    
    xmlFree(fromNodeStr);
    xmlFree(toNodeStr);
    xmlFree(fromIndexStr);
    xmlFree(toIndexStr);
    
    // DON'T call updatePath() here - scene may not be ready
    // Socket resolution will happen later via resolveConnections()
}

bool Edge::isConnectedToNode(const QString& nodeId) const
{
    return (m_fromNodeId == nodeId || m_toNodeId == nodeId);
}

bool Edge::isConnectedToNode(const QUuid& nodeId) const
{
    // Optimized: Fast UUID comparison (no string conversion)
    return (m_fromNodeUuid == nodeId || m_toNodeUuid == nodeId);
}

bool Edge::resolveConnections(Scene* scene)
{
    if (!scene) {
        qCritical() << "Edge::resolveConnections - null scene";
        return false;
    }
    
    if (m_fromNodeId.isEmpty() || m_toNodeId.isEmpty()) {
        qCritical() << "Edge::resolveConnections - empty node IDs";
        return false;
    }
    
    // Find nodes by UUID
    Node* fromNode = scene->getNode(QUuid(m_fromNodeId));
    Node* toNode = scene->getNode(QUuid(m_toNodeId));
    
    if (!fromNode) {
        qCritical() << "Edge::resolveConnections - fromNode not found:" << m_fromNodeId.left(8);
        return false;
    }
    if (!toNode) {
        qCritical() << "Edge::resolveConnections - toNode not found:" << m_toNodeId.left(8);
        return false;
    }
    
    // Find sockets by index
    Socket* fromSocket = fromNode->getSocketByIndex(m_fromSocketIndex);
    Socket* toSocket = toNode->getSocketByIndex(m_toSocketIndex);
    
    qDebug() << "Edge resolve: fromNode" << m_fromNodeId.left(8) << "type:" << fromNode->getNodeType()
             << "socket" << m_fromSocketIndex << "role:" << (fromSocket ? Socket::roleToString(fromSocket->getRole()) : "NULL");
    qDebug() << "Edge resolve: toNode" << m_toNodeId.left(8) << "type:" << toNode->getNodeType()
             << "socket" << m_toSocketIndex << "role:" << (toSocket ? Socket::roleToString(toSocket->getRole()) : "NULL");
    
    if (!fromSocket) {
        qCritical() << "Edge::resolveConnections - fromSocket index" << m_fromSocketIndex 
                   << "not found in node" << m_fromNodeId.left(8) 
                   << "with" << fromNode->getSocketCount() << "sockets";
        return false;
    }
    if (!toSocket) {
        qCritical() << "Edge::resolveConnections - toSocket index" << m_toSocketIndex 
                   << "not found in node" << m_toNodeId.left(8) 
                   << "with" << toNode->getSocketCount() << "sockets";
        return false;
    }
    
    // Validate connection rules
    if (fromSocket->getRole() != Socket::Output) {
        qCritical() << "ERROR: Edge::resolveConnections - fromSocket must be Output role"
                   << "- fromNode:" << m_fromNodeId.left(8) << "socket" << m_fromSocketIndex 
                   << "has role:" << Socket::roleToString(fromSocket->getRole());
        return false;
    }
    if (toSocket->getRole() != Socket::Input) {
        qCritical() << "ERROR: Edge::resolveConnections - toSocket must be Input role"
                   << "- toNode:" << m_toNodeId.left(8) << "socket" << m_toSocketIndex 
                   << "has role:" << Socket::roleToString(toSocket->getRole());
        return false;
    }
    
    // Store socket references directly - NO UUIDs
    m_fromSocket = fromSocket;
    m_toSocket = toSocket;
    
    // Cache node pointers for safe destruction
    m_fromNode = fromNode;
    m_toNode = toNode;
    
    // PERFORMANCE OPTIMIZATION: Register this edge with both connected nodes
    // This enables O(degree) edge updates instead of O(totalEdges)
    fromNode->registerEdge(this);
    toNode->registerEdge(this);
    
    qDebug() << "Edge" << m_id.toString(QUuid::WithoutBraces).left(8) << "resolved" 
             << m_fromSocketIndex << "->" << m_toSocketIndex;
    
    updatePath();
    return true;
}

void Edge::setConnectionData(const QString& fromNodeId, const QString& toNodeId, 
                            int fromSocketIndex, int toSocketIndex)
{
    m_fromNodeId = fromNodeId;
    m_toNodeId = toNodeId;
    m_fromSocketIndex = fromSocketIndex;
    m_toSocketIndex = toSocketIndex;
    
    // Performance optimization: cache UUIDs for fast comparison
    m_fromNodeUuid = QUuid(fromNodeId);
    m_toNodeUuid = QUuid(toNodeId);
    
    qDebug() << "Edge: Set connection data" << fromNodeId.left(8) 
             << "socket" << fromSocketIndex << "-> " << toNodeId.left(8) 
             << "socket" << toSocketIndex;
}

void Edge::setResolvedSockets(Socket* fromSocket, Socket* toSocket)
{
    if (!fromSocket || !toSocket) {
        qCritical() << "Edge::setResolvedSockets - null socket(s) provided";
        return;
    }
    
    // Validate socket roles
    if (fromSocket->getRole() != Socket::Output) {
        qCritical() << "Edge::setResolvedSockets - fromSocket must be Output role";
        return;
    }
    if (toSocket->getRole() != Socket::Input) {
        qCritical() << "Edge::setResolvedSockets - toSocket must be Input role";
        return;
    }
    
    m_fromSocket = fromSocket;
    m_toSocket = toSocket;
    
    // Cache node pointers for safe destruction
    Node* fromNode = fromSocket->getParentNode();
    Node* toNode = toSocket->getParentNode();
    m_fromNode = fromNode;
    m_toNode = toNode;
    
    // PERFORMANCE OPTIMIZATION: Register this edge with both connected nodes
    // This enables O(degree) edge updates instead of O(totalEdges)
    if (fromNode) fromNode->registerEdge(this);
    if (toNode) toNode->registerEdge(this);
    
    qDebug() << "Edge: Set resolved sockets directly (optimization)";
    updatePath();
}

=== javascript_engine.h ===

#pragma once

#include <QJSEngine>
#include <QJSValue>
#include <QObject>
#include <QString>
#include <QVariant>
#include <QDebug>
#include "script_executor.h"

class Node;
class Edge;
class Scene;
class GraphController;
class GraphFactory;

/**
 * JavaScriptEngine - Modern JavaScript integration for NodeGraph
 * 
 * Provides QJSEngine integration for:
 * - Node scripting and behavior logic
 * - Graph processing algorithms
 * - Custom node types in JavaScript
 * - Real-time graph operations
 */
class JavaScriptEngine : public QObject
{
    Q_OBJECT

public:
    explicit JavaScriptEngine(QObject* parent = nullptr);
    ~JavaScriptEngine();

    // JavaScript execution
    QJSValue evaluate(const QString& script);
    QJSValue evaluateFile(const QString& filePath);
    
    // API registration
    void registerNodeAPI(Scene* scene);
    void registerGraphAPI();
    void registerGraphController(Scene* scene, GraphFactory* factory);
    
    // Node scripting support
    QJSValue createNodeScript(const QString& nodeType, const QString& script);
    bool executeNodeScript(Node* node, const QString& script, const QVariantMap& inputs = QVariantMap());
    
    // Graph processing
    QJSValue processGraph(const QString& algorithm, const QVariantMap& parameters = QVariantMap());
    
    // Utility methods
    bool hasErrors() const;
    QString getLastError() const;
    void clearErrors();
    
    // Engine information
    QString getEngineInfo() const;
    void logEngineCapabilities() const;
    
    // Execution verification
    bool runMandatoryExecutionTest();
    
    // Script management
    void loadScriptModule(const QString& moduleName, const QString& scriptContent);
    QJSValue getModule(const QString& moduleName);

signals:
    void scriptExecuted(const QString& script, const QJSValue& result);
    void scriptError(const QString& error);
    void nodeScriptChanged(const QString& nodeId, const QString& script);

public slots:
    // Console API callbacks
    void qt_console_log(const QString& message);
    void qt_console_info(const QString& message);
    void qt_console_warn(const QString& message);
    void qt_console_error(const QString& message);

private slots:
    void handleJavaScriptException(const QJSValue& exception);

private:
    void setupGlobalAPI();
    void registerConsoleAPI();
    void registerUtilityAPI();
    void setupQtBridgeWithGraphController();
    void loadEnhancedAPIs();
    
    QJSValue nodeToJSValue(Node* node);
    QJSValue edgeToJSValue(Edge* edge);
    
    QJSEngine* m_engine;
    Scene* m_scene;
    GraphController* m_graphController;
    QString m_lastError;
    QMap<QString, QJSValue> m_scriptModules;
};

=== javascript_engine.cpp ===

#include "javascript_engine.h"
#include "node.h"
#include "edge.h"
#include "scene.h"
#include "graph_controller.h"
#include "graph_factory.h"
#include <QFile>
#include <QTextStream>
#include <QJsonDocument>
#include <QJsonObject>
#include <QElapsedTimer>

JavaScriptEngine::JavaScriptEngine(QObject* parent)
    : QObject(parent)
    , m_engine(new QJSEngine(this))
    , m_scene(nullptr)
    , m_graphController(nullptr)
{
    setupGlobalAPI();
    registerConsoleAPI();
    registerUtilityAPI();
    
    // Auto-load enhanced APIs disabled for now - will load scripts manually
    // loadEnhancedAPIs();
    
    qDebug() << "JavaScriptEngine: Simple JavaScript engine initialized";
}

JavaScriptEngine::~JavaScriptEngine()
{
    qDebug() << "JavaScriptEngine: Shutting down";
}

QJSValue JavaScriptEngine::evaluate(const QString& script)
{
    clearErrors();
    
    qDebug() << "JS_EXEC_START: Using safe execution with error isolation";
    qDebug() << "JS_EXEC_START: Script length:" << script.length();
    qDebug() << "JS_EXEC_CONTENT:" << script.left(200) << "...";
    
    // Configure safe execution options
    ScriptExecutor::ExecutionOptions options;
    options.timeoutMs = 10000;        // 10 second timeout
    options.enableConsole = true;     // Keep console API
    options.enableDebugging = true;   // Enable detailed logging
    options.maxRecursionDepth = 100;  // Prevent stack overflow
    
    // Execute script with full error isolation
    ScriptExecutor::ExecutionResult execResult = ScriptExecutor::safeExecute(m_engine, script, options);
    
    // Process execution results
    if (execResult.success) {
        qDebug() << "JS_SUCCESS: Safe execution completed in" << execResult.executionTimeMs << "ms";
        qDebug() << "JS_SUCCESS: Phase:" << execResult.executionPhase;
        QString resultStr = execResult.result.isUndefined() ? "undefined" : execResult.result.toString();
        qDebug() << "JS_RESULT:" << resultStr;
        emit scriptExecuted(script, execResult.result);
        return execResult.result;
    } else {
        // Handle execution failure with detailed error reporting
        qCritical() << "JS_ERROR: Safe execution failed in" << execResult.executionTimeMs << "ms";
        qCritical() << "JS_ERROR: Phase:" << execResult.executionPhase;
        qCritical() << "JS_ERROR: Message:" << execResult.error;
        
        if (execResult.timedOut) {
            qCritical() << "JS_ERROR: TIMEOUT - Script execution exceeded time limit";
        }
        if (execResult.crashed) {
            qCritical() << "JS_ERROR: CRASH - Script caused C++ exception";
        }
        
        qCritical() << "JS_ERROR: Script content:" << script.left(500);
        
        m_lastError = execResult.error;
        emit scriptError(m_lastError);
        
        // Return error result
        QJSValue errorResult = m_engine->newErrorObject(QJSValue::GenericError, execResult.error);
        return errorResult;
    }
}

QJSValue JavaScriptEngine::evaluateFile(const QString& filePath)
{
    qDebug() << "JS_EXECUTION: Loading script file:" << filePath;
    
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        m_lastError = QString("Cannot open script file: %1").arg(filePath);
        emit scriptError(m_lastError);
        qDebug() << "JS_ERROR: Failed to open script file:" << filePath;
        return QJSValue();
    }
    
    QTextStream in(&file);
    QString script = in.readAll();
    
    qDebug() << "JS_EXECUTION: Loaded script file:" << filePath;
    qDebug() << "JS_EXECUTION: Script size:" << script.length() << "characters";
    
    return evaluate(script);
}

void JavaScriptEngine::registerNodeAPI(Scene* scene)
{
    m_scene = scene;
    
    // Register Node API
    QJSValue nodeAPI = m_engine->newObject();
    
    // Node creation functions - Qt5 compatible
    QJSValue createFunc = m_engine->evaluate(R"(
        (function(type, x, y) {
            if (arguments.length < 3) {
                throw new Error("Node.create() requires type, x, y parameters");
            }
            console.log("JavaScript: Creating node " + type + " at " + x + "," + y);
            return {}; // Placeholder
        })
    )");
    nodeAPI.setProperty("create", createFunc);
    
    // Node query functions - Qt5 compatible
    QJSValue findByIdFunc = m_engine->evaluate(R"(
        (function(id) {
            if (arguments.length < 1) {
                throw new Error("Node.findById() requires id parameter");
            }
            console.log("JavaScript: Finding node by ID: " + id);
            return null; // Placeholder
        })
    )");
    nodeAPI.setProperty("findById", findByIdFunc);
    
    // Enhanced node manipulation functions
    QJSValue moveNodeFunc = m_engine->evaluate(R"(
        (function(nodeId, x, y) {
            if (arguments.length < 3) {
                throw new Error("Node.move() requires nodeId, x, y parameters");
            }
            console.log("JavaScript: Moving node " + nodeId + " to " + x + "," + y);
            return true; // Placeholder
        })
    )");
    nodeAPI.setProperty("move", moveNodeFunc);
    
    QJSValue getPropertiesFunc = m_engine->evaluate(R"(
        (function(nodeId) {
            if (arguments.length < 1) {
                throw new Error("Node.getProperties() requires nodeId parameter");
            }
            console.log("JavaScript: Getting properties for node " + nodeId);
            return {}; // Placeholder
        })
    )");
    nodeAPI.setProperty("getProperties", getPropertiesFunc);
    
    m_engine->globalObject().setProperty("Node", nodeAPI);
    
    // Register Graph API
    QJSValue graphAPI = m_engine->newObject();
    
    // Graph API functions - Qt5 compatible
    QJSValue getNodesFunc = m_engine->evaluate(R"(
        (function() {
            console.log("JavaScript: Getting all nodes");
            return []; // Placeholder
        })
    )");
    graphAPI.setProperty("getNodes", getNodesFunc);
    
    QJSValue getEdgesFunc = m_engine->evaluate(R"(
        (function() {
            console.log("JavaScript: Getting all edges");
            return []; // Placeholder
        })
    )");
    graphAPI.setProperty("getEdges", getEdgesFunc);
    
    // Add the missing createNode function
    QJSValue createNodeFunc = m_engine->evaluate(R"(
        (function(nodeType, x, y) {
            if (arguments.length < 3) {
                throw new Error("Graph.createNode() requires nodeType, x, y parameters");
            }
            console.log("JavaScript: Creating node type=" + nodeType + " at x=" + x + " y=" + y);
            return {id: "temp_id", type: nodeType, x: x, y: y};
        })
    )");
    graphAPI.setProperty("createNode", createNodeFunc);
    
    // Enhanced graph operations
    QJSValue clearGraphFunc = m_engine->evaluate(R"(
        (function() {
            console.log("JavaScript: Clearing graph");
            return true; // Placeholder
        })
    )");
    graphAPI.setProperty("clear", clearGraphFunc);
    
    QJSValue connectNodesFunc = m_engine->evaluate(R"(
        (function(fromNodeId, fromSocket, toNodeId, toSocket) {
            if (arguments.length < 4) {
                throw new Error("Graph.connect() requires fromNodeId, fromSocket, toNodeId, toSocket parameters");
            }
            console.log("JavaScript: Connecting " + fromNodeId + "[" + fromSocket + "] to " + toNodeId + "[" + toSocket + "]");
            
            // Call the C++ GraphController connect method
            return Qt.connectNodesViaCpp(fromNodeId, fromSocket, toNodeId, toSocket);
        })
    )");
    graphAPI.setProperty("connect", connectNodesFunc);
    
    QJSValue getStatsFunc = m_engine->evaluate(R"(
        (function() {
            console.log("JavaScript: Getting graph statistics");
            return {nodes: 0, edges: 0}; // Placeholder
        })
    )");
    graphAPI.setProperty("getStats", getStatsFunc);
    
    QJSValue graphMoveNodeFunc = m_engine->evaluate(R"(
        (function(nodeId, x, y) {
            if (arguments.length < 3) {
                throw new Error("Graph.moveNode() requires nodeId, x, y parameters");
            }
            console.log("JavaScript: Moving node " + nodeId + " to " + x + "," + y);
            return true; // Placeholder
        })
    )");
    graphAPI.setProperty("moveNode", graphMoveNodeFunc);
    
    QJSValue saveXmlFunc = m_engine->evaluate(R"(
        (function(filename) {
            if (arguments.length < 1) {
                throw new Error("Graph.saveXml() requires filename parameter");
            }
            console.log("JavaScript: Saving graph to " + filename);
            return true; // Placeholder
        })
    )");
    graphAPI.setProperty("saveXml", saveXmlFunc);
    
    QJSValue loadXmlFunc = m_engine->evaluate(R"(
        (function(filename) {
            if (arguments.length < 1) {
                throw new Error("Graph.loadXml() requires filename parameter");
            }
            console.log("JavaScript: Loading graph from " + filename);
            return true; // Placeholder
        })
    )");
    graphAPI.setProperty("loadXml", loadXmlFunc);
    
    m_engine->globalObject().setProperty("Graph", graphAPI);
    
    qDebug() << "JavaScriptEngine: Node and Graph APIs registered";
}

void JavaScriptEngine::registerGraphAPI()
{
    QJSValue algorithms = m_engine->newObject();
    
    // Layout algorithms - Qt5 compatible
    QJSValue forceDirectedFunc = m_engine->evaluate(R"(
        (function() {
            console.log("JavaScript: Running force-directed layout");
            return {}; // Placeholder
        })
    )");
    algorithms.setProperty("forceDirected", forceDirectedFunc);
    
    QJSValue hierarchicalFunc = m_engine->evaluate(R"(
        (function() {
            console.log("JavaScript: Running hierarchical layout");
            return {}; // Placeholder
        })
    )");
    algorithms.setProperty("hierarchical", hierarchicalFunc);
    
    m_engine->globalObject().setProperty("Algorithms", algorithms);
    
    qDebug() << "JavaScriptEngine: Graph algorithms registered";
}

void JavaScriptEngine::registerGraphController(Scene* scene, GraphFactory* factory)
{
    m_scene = scene;
    
    // Create GraphController instance
    m_graphController = new GraphController(scene, factory, this);
    
    // Register as global Graph object
    QJSValue controllerValue = m_engine->newQObject(m_graphController);
    m_engine->globalObject().setProperty("Graph", controllerValue);
    
    // Connect signals for debugging
    connect(m_graphController, &GraphController::nodeCreated, [](const QString& uuid) {
        qDebug() << "JavaScript: Node created:" << uuid;
    });
    
    connect(m_graphController, &GraphController::nodeDeleted, [](const QString& uuid) {
        qDebug() << "JavaScript: Node deleted:" << uuid;
    });
    
    connect(m_graphController, &GraphController::edgeCreated, [](const QString& uuid) {
        qDebug() << "JavaScript: Edge created:" << uuid;
    });
    
    connect(m_graphController, &GraphController::edgeDeleted, [](const QString& uuid) {
        qDebug() << "JavaScript: Edge deleted:" << uuid;
    });
    
    connect(m_graphController, &GraphController::error, [](const QString& message) {
        qDebug() << "JavaScript Graph Error:" << message;
    });
    
    // Phase 1: Set up Qt bridge now that GraphController exists
    setupQtBridgeWithGraphController();
    
    qDebug() << "JavaScriptEngine: GraphController registered as 'Graph' global object";
}

QJSValue JavaScriptEngine::createNodeScript(const QString& nodeType, const QString& script)
{
    QString wrappedScript = QString(R"(
        (function(nodeType, inputs, outputs) {
            %1
        })
    )").arg(script);
    
    QJSValue nodeFunction = evaluate(wrappedScript);
    
    if (!nodeFunction.isError()) {
        m_scriptModules[nodeType] = nodeFunction;
        qDebug() << "JavaScriptEngine: Created node script for type:" << nodeType;
    }
    
    return nodeFunction;
}

bool JavaScriptEngine::executeNodeScript(Node* node, const QString& script, const QVariantMap& inputs)
{
    if (!node) {
        m_lastError = "Cannot execute script on null node";
        return false;
    }
    
    // Convert inputs to JavaScript object
    QJSValue jsInputs = m_engine->newObject();
    for (auto it = inputs.begin(); it != inputs.end(); ++it) {
        jsInputs.setProperty(it.key(), m_engine->toScriptValue(it.value()));
    }
    
    // Set up node context
    QJSValue nodeObj = nodeToJSValue(node);
    m_engine->globalObject().setProperty("currentNode", nodeObj);
    m_engine->globalObject().setProperty("inputs", jsInputs);
    
    QJSValue result = evaluate(script);
    
    return !result.isError();
}

QJSValue JavaScriptEngine::processGraph(const QString& algorithm, const QVariantMap& parameters)
{
    QJSValue params = m_engine->newObject();
    for (auto it = parameters.begin(); it != parameters.end(); ++it) {
        params.setProperty(it.key(), m_engine->toScriptValue(it.value()));
    }
    
    QString script = QString("Algorithms.%1(arguments[0])").arg(algorithm);
    QJSValue algorithmFunc = evaluate(script);
    
    if (algorithmFunc.isCallable()) {
        return algorithmFunc.call(QJSValueList() << params);
    }
    
    return QJSValue();
}

bool JavaScriptEngine::hasErrors() const
{
    return !m_lastError.isEmpty();
}

QString JavaScriptEngine::getLastError() const
{
    return m_lastError;
}

void JavaScriptEngine::clearErrors()
{
    m_lastError.clear();
}

QString JavaScriptEngine::getEngineInfo() const
{
    QJSValue info = m_engine->evaluate(R"(
        JSON.stringify({
            engine: 'QJSEngine',
            qtVersion: ')" + QString(QT_VERSION_STR) + R"(',
            ecmaScript: 'ES5+',
            timestamp: new Date().toISOString(),
            features: {
                objects: typeof Object !== 'undefined',
                arrays: typeof Array !== 'undefined',
                functions: typeof Function !== 'undefined',
                json: typeof JSON !== 'undefined',
                console: typeof console !== 'undefined',
                math: typeof Math !== 'undefined',
                date: typeof Date !== 'undefined'
            }
        }, null, 2)
    )");
    
    return info.isError() ? "Error getting engine info" : info.toString();
}

void JavaScriptEngine::logEngineCapabilities() const
{
    qDebug() << "=== JavaScript Engine Information ===";
    qDebug() << "Engine Type: QJSEngine (Qt JavaScript Engine)";
    qDebug() << "Qt Version:" << QT_VERSION_STR;
    qDebug() << "ECMAScript Level: ES5+ (limited ES6 support)";
    
    QString info = getEngineInfo();
    qDebug() << "Detailed Capabilities:" << info;
    
    // Test specific features
    QJSValue testModernJS = m_engine->evaluate("const test = {a: 1, b: 2}; test.a + test.b");
    qDebug() << "Modern JS (const) support:" << (testModernJS.isError() ? "NO" : "YES");
    
    QJSValue testArrowFunction = m_engine->evaluate("((x) => x * 2)(5)");
    qDebug() << "Arrow function support:" << (testArrowFunction.isError() ? "NO" : "YES");
    
    qDebug() << "======================================";
}

void JavaScriptEngine::loadScriptModule(const QString& moduleName, const QString& scriptContent)
{
    QString moduleScript = QString(R"(
        (function() {
            var module = { exports: {} };
            var exports = module.exports;
            
            %1
            
            return module.exports;
        })()
    )").arg(scriptContent);
    
    QJSValue moduleResult = evaluate(moduleScript);
    
    if (!moduleResult.isError()) {
        m_scriptModules[moduleName] = moduleResult;
        qDebug() << "JavaScriptEngine: Loaded module:" << moduleName;
    }
}

QJSValue JavaScriptEngine::getModule(const QString& moduleName)
{
    return m_scriptModules.value(moduleName, QJSValue());
}

void JavaScriptEngine::handleJavaScriptException(const QJSValue& exception)
{
    m_lastError = QString("JavaScript Exception: %1").arg(exception.toString());
    emit scriptError(m_lastError);
    qDebug() << m_lastError;
}

void JavaScriptEngine::setupGlobalAPI()
{
    // Set up global JavaScript environment
    QJSValue globalObject = m_engine->globalObject();
    
    // Add setTimeout/setInterval placeholders - Qt5 compatible
    QJSValue setTimeoutFunc = m_engine->evaluate(
        "(function(func, delay) {"
        "    console.log('JavaScript: setTimeout called (not implemented)');"
        "    return 0;"
        "})"
    );
    globalObject.setProperty("setTimeout", setTimeoutFunc);
    
    QJSValue setIntervalFunc = m_engine->evaluate(
        "(function(func, delay) {"
        "    console.log('JavaScript: setInterval called (not implemented)');"
        "    return 0;"
        "})"
    );
    globalObject.setProperty("setInterval", setIntervalFunc);
}

void JavaScriptEngine::registerConsoleAPI()
{
    QJSValue console = m_engine->newObject();
    
    // Console API - Qt5 compatible with C++ callback
    QJSValue consoleLog = m_engine->evaluate(R"(
        (function() {
            var args = Array.prototype.slice.call(arguments);
            qt_console_log(args.join(" "));
        })
    )");
    console.setProperty("log", consoleLog);
    
    QJSValue consoleInfo = m_engine->evaluate(R"(
        (function() {
            var args = Array.prototype.slice.call(arguments);
            qt_console_info(args.join(" "));
        })
    )");
    console.setProperty("info", consoleInfo);
    
    QJSValue consoleWarn = m_engine->evaluate(R"(
        (function() {
            var args = Array.prototype.slice.call(arguments);
            qt_console_warn(args.join(" "));
        })
    )");
    console.setProperty("warn", consoleWarn);
    
    QJSValue consoleError = m_engine->evaluate(R"(
        (function() {
            var args = Array.prototype.slice.call(arguments);
            qt_console_error(args.join(" "));
        })
    )");
    console.setProperty("error", consoleError);
    
    // Register the entire JavaScriptEngine object so its public slots are accessible
    QJSValue engineObject = m_engine->newQObject(this);
    m_engine->globalObject().setProperty("qt_console_log", engineObject.property("qt_console_log"));
    m_engine->globalObject().setProperty("qt_console_info", engineObject.property("qt_console_info"));
    m_engine->globalObject().setProperty("qt_console_warn", engineObject.property("qt_console_warn"));
    m_engine->globalObject().setProperty("qt_console_error", engineObject.property("qt_console_error"));
    
    m_engine->globalObject().setProperty("console", console);
}

void JavaScriptEngine::qt_console_log(const QString& message)
{
    // Use explicit JavaScript prefix to ensure file logging integration
    qDebug() << "JavaScript:" << message;
}

void JavaScriptEngine::qt_console_info(const QString& message)
{
    // Use qInfo for informational JavaScript messages
    qInfo() << "JavaScript INFO:" << message;
}

void JavaScriptEngine::qt_console_warn(const QString& message)
{
    // Use qWarning for JavaScript warnings
    qWarning() << "JavaScript WARN:" << message;
}

void JavaScriptEngine::qt_console_error(const QString& message)
{
    // Use qCritical for JavaScript errors to ensure proper categorization
    qCritical() << "JavaScript ERROR:" << message;
}

void JavaScriptEngine::registerUtilityAPI()
{
    QJSValue utils = m_engine->newObject();
    
    // JSON utilities - Qt5 compatible using built-in JSON
    QJSValue parseJSONFunc = m_engine->evaluate(R"(
        (function(jsonString) {
            if (arguments.length < 1) {
                throw new Error("parseJSON() requires a string parameter");
            }
            try {
                return JSON.parse(jsonString);
            } catch (e) {
                throw new Error("Invalid JSON string");
            }
        })
    )");
    utils.setProperty("parseJSON", parseJSONFunc);
    
    QJSValue stringifyJSONFunc = m_engine->evaluate(R"(
        (function(obj) {
            if (arguments.length < 1) {
                throw new Error("stringifyJSON() requires an object parameter");
            }
            try {
                return JSON.stringify(obj);
            } catch (e) {
                throw new Error("Cannot stringify object");
            }
        })
    )");
    utils.setProperty("stringifyJSON", stringifyJSONFunc);
    
    m_engine->globalObject().setProperty("Utils", utils);
}

QJSValue JavaScriptEngine::nodeToJSValue(Node* node)
{
    if (!node) {
        return QJSValue();
    }
    
    QJSValue nodeObj = m_engine->newObject();
    
    // Basic node properties
    nodeObj.setProperty("id", node->getId().toString());
    nodeObj.setProperty("type", node->getNodeType());
    nodeObj.setProperty("x", node->pos().x());
    nodeObj.setProperty("y", node->pos().y());
    
    // Socket information
    QJSValue sockets = m_engine->newArray();
    // TODO: Populate with actual socket data
    nodeObj.setProperty("sockets", sockets);
    
    return nodeObj;
}

QJSValue JavaScriptEngine::edgeToJSValue(Edge* edge)
{
    if (!edge) {
        return QJSValue();
    }
    
    QJSValue edgeObj = m_engine->newObject();
    
    // Basic edge properties
    edgeObj.setProperty("id", edge->getId().toString());
    
    // TODO: Add from/to node information
    
    return edgeObj;
}

void JavaScriptEngine::loadEnhancedAPIs()
{
    // List of enhanced API scripts to auto-load
    QStringList apiScripts = {
        "scripts/enhanced_graph_api.js",
        "scripts/custom_nodes.js",
        "scripts/node_algorithms.js",
        "scripts/node_execution_engine.js",
        "scripts/demo_interactive.js"
    };
    
    for (const QString& scriptPath : apiScripts) {
        QFile file(scriptPath);
        if (file.exists() && file.open(QIODevice::ReadOnly | QIODevice::Text)) {
            QTextStream in(&file);
            QString script = in.readAll();
            
            QJSValue result = evaluate(script);
            if (!result.isError()) {
                qDebug() << "JavaScriptEngine: Loaded enhanced API:" << scriptPath;
            } else {
                qDebug() << "JavaScriptEngine: Failed to load API:" << scriptPath << "-" << result.toString();
            }
        } else {
            qDebug() << "JavaScriptEngine: API script not found:" << scriptPath;
        }
    }
}

void JavaScriptEngine::setupQtBridgeWithGraphController()
{
    if (!m_graphController) {
        qWarning() << "JavaScriptEngine: Cannot setup Qt bridge - GraphController not available";
        return;
    }
    
    // Phase 1: Set up Qt bridge with real GraphController access
    QJSValue qt = m_engine->newObject();
    
    // Expose GraphController directly for advanced usage
    QJSValue graphControllerObj = m_engine->newQObject(m_graphController);
    qt.setProperty("GraphController", graphControllerObj);
    
    // Create bridge functions that call real GraphController methods
    QJSValue createNodeViaCppFunc = m_engine->evaluate(R"(
        (function(nodeType, x, y) {
            console.log("Qt bridge: calling real GraphController.createNode with:", nodeType, x, y);
            var nodeId = Qt.GraphController.createNode(nodeType, x, y);
            console.log("Qt bridge: GraphController returned nodeId:", nodeId);
            return {id: nodeId, type: nodeType, x: x, y: y};
        })
    )");
    qt.setProperty("createNodeViaCpp", createNodeViaCppFunc);
    
    QJSValue connectNodesViaCppFunc = m_engine->evaluate(R"(
        (function(fromNodeId, fromSocket, toNodeId, toSocket) {
            console.log("Qt bridge: calling real GraphController.connect with:", fromNodeId, fromSocket, toNodeId, toSocket);
            var edgeId = Qt.GraphController.connect(fromNodeId, fromSocket, toNodeId, toSocket);
            console.log("Qt bridge: GraphController returned edgeId:", edgeId);
            return {id: edgeId, from: fromNodeId, to: toNodeId, fromSocket: fromSocket, toSocket: toSocket};
        })
    )");
    qt.setProperty("connectNodesViaCpp", connectNodesViaCppFunc);
    
    // Set the Qt object BEFORE registering it to global object
    m_engine->globalObject().setProperty("Qt", qt);
    
    // Now override the Graph API functions to use real GraphController
    QJSValue graphAPI = m_engine->globalObject().property("Graph");
    if (!graphAPI.isUndefined() && graphAPI.isObject()) {
        // Replace Graph.createNode with real implementation that calls GraphController
        QJSValue realCreateNodeFunc = m_engine->evaluate(R"(
            (function(nodeType, x, y) {
                if (arguments.length < 3) {
                    throw new Error("Graph.createNode() requires nodeType, x, y parameters");
                }
                console.log("Graph.createNode: delegating to Qt bridge for:", nodeType, x, y);
                return Qt.createNodeViaCpp(nodeType, x, y);
            })
        )");
        graphAPI.setProperty("createNode", realCreateNodeFunc);
        
        // Replace Graph.connect with real implementation
        QJSValue realConnectFunc = m_engine->evaluate(R"(
            (function(fromNodeId, fromSocket, toNodeId, toSocket) {
                if (arguments.length < 4) {
                    throw new Error("Graph.connect() requires fromNodeId, fromSocket, toNodeId, toSocket parameters");
                }
                console.log("Graph.connect: delegating to Qt bridge");
                return Qt.connectNodesViaCpp(fromNodeId, fromSocket, toNodeId, toSocket);
            })
        )");
        graphAPI.setProperty("connect", realConnectFunc);
        
        // Replace Graph.saveXml with real implementation
        QJSValue realSaveXmlFunc = m_engine->evaluate(R"(
            (function(filename) {
                if (arguments.length < 1) {
                    throw new Error("Graph.saveXml() requires filename parameter");
                }
                console.log("Graph.saveXml: delegating to Qt.GraphController.saveXml for:", filename);
                try {
                    Qt.GraphController.saveXml(filename);
                    return true;
                } catch (error) {
                    console.log("Graph.saveXml error:", error.message);
                    return false;
                }
            })
        )");
        graphAPI.setProperty("saveXml", realSaveXmlFunc);
        
        qDebug() << "JavaScriptEngine: Graph API functions replaced with real GraphController implementations";
    }
    
    qDebug() << "JavaScriptEngine: Qt bridge connected to real GraphController - Phase 1 complete";
}

bool JavaScriptEngine::runMandatoryExecutionTest()
{
    qDebug() << "=== MANDATORY JS EXECUTION TEST ===";
    
    QString testScript = R"(
        console.log("JavaScript execution verified!");
        var result = 2 + 2;
        console.log("Math test: 2 + 2 =", result);
        
        // Test console API
        console.info("Console API test: INFO level");
        console.warn("Console API test: WARN level");
        
        // Test object creation
        var testObject = {
            status: "success",
            mathResult: result,
            message: "Mandatory execution test completed"
        };
        
        console.log("Test object created:", JSON.stringify(testObject));
        result;
    )";
    
    QJSValue result = evaluate(testScript);
    
    if (result.isError()) {
        qCritical() << "JS_TEST: FAILED - Engine error:" << result.toString();
        return false;
    }
    
    if (result.toInt() == 4) {
        qDebug() << "JS_TEST: PASSED - Engine is functional";
        qDebug() << "JS_TEST: Math result correct, console API working, object creation successful";
        return true;
    } else {
        qCritical() << "JS_TEST: FAILED - Expected 4, got:" << result.toString();
        return false;
    }
}

=== graph_controller.h ===

#pragma once

#include <QObject>
#include <QString>
#include <QVariantMap>
#include <QUuid>

class Scene;
class GraphFactory;
class XmlLiveSync;
class Node;
class Edge;

/**
 * GraphController - JavaScript-accessible graph control interface
 * 
 * Provides runtime control over the node graph system via JavaScript:
 * - Create/delete nodes and edges
 * - Save/load XML 
 * - Query graph statistics
 * - Trigger XML synchronization
 * 
 * This class is exposed to QJSEngine as the "Graph" global object
 */
class GraphController : public QObject
{
    Q_OBJECT

public:
    explicit GraphController(Scene* scene, GraphFactory* factory, QObject* parent = nullptr);
    ~GraphController() = default;

public slots:
    // Node operations
    QString createNode(const QString& type, qreal x, qreal y);
    bool deleteNode(const QString& uuid);
    bool moveNode(const QString& uuid, qreal dx, qreal dy);
    QVariantMap getNode(const QString& uuid);
    QVariantList getNodes();
    
    // Socket introspection operations
    QVariantList getInputSockets(const QString& nodeId);
    QVariantList getOutputSockets(const QString& nodeId);
    QVariantMap getSocketInfo(const QString& nodeId, int socketIndex);
    bool canConnect(const QString& fromNodeId, int fromIndex, const QString& toNodeId, int toIndex);
    
    // Edge operations  
    QString connect(const QString& fromNodeId, int fromIndex, 
                   const QString& toNodeId, int toIndex);
    bool deleteEdge(const QString& uuid);
    QVariantList getEdges();
    
    // Graph-wide operations
    void clear();
    void saveXml(const QString& path);
    void loadXml(const QString& path);
    void rebuildXml();
    QString getXmlString();
    QVariantMap getStats();
    
    // Utility functions
    bool isValidNodeType(const QString& type);
    QStringList getValidNodeTypes();
    
signals:
    void nodeCreated(const QString& uuid);
    void nodeDeleted(const QString& uuid);
    void edgeCreated(const QString& uuid);
    void edgeDeleted(const QString& uuid);
    void graphCleared();
    void xmlSaved(const QString& path);
    void xmlLoaded(const QString& path);
    void error(const QString& message);

private:
    Scene* m_scene;
    GraphFactory* m_factory;
    
    // Helper methods
    Node* findNode(const QString& uuid);
    Edge* findEdge(const QString& uuid);
    QVariantMap nodeToVariant(Node* node);
    QVariantMap edgeToVariant(Edge* edge);
};

=== graph_controller.cpp ===

#include "graph_controller.h"
#include "scene.h"
#include "graph_factory.h"
#include "node.h"
#include "edge.h"
#include "socket.h"
#include "node_registry.h"
#include <QDebug>
#include <QFile>
#include <QTextStream>
#include <libxml/tree.h>
#include <libxml/parser.h>

GraphController::GraphController(Scene* scene, GraphFactory* factory, QObject* parent)
    : QObject(parent)
    , m_scene(scene)
    , m_factory(factory)
{
    qDebug() << "GraphController: JavaScript interface initialized";
}

QString GraphController::createNode(const QString& type, qreal x, qreal y)
{
    if (!m_scene || !m_factory) {
        emit error("GraphController: Scene or factory not initialized");
        return QString();
    }
    
    // Log node type validation
    QStringList validTypes = getValidNodeTypes();
    qDebug() << __FUNCTION__ << ": Validating node type" << type;
    qDebug() << __FUNCTION__ << ": Available types:" << validTypes;
    
    if (!isValidNodeType(type)) {
        qDebug() << __FUNCTION__ << ": INVALID node type:" << type;
        emit error(QString("GraphController: Invalid node type: %1").arg(type));
        return QString();
    } else {
        qDebug() << __FUNCTION__ << ": VALID node type:" << type;
    }
    
    qDebug() << __FUNCTION__ << ": Creating node" << type << "at" << x << "," << y;
    
    try {
        Node* node = m_factory->createNode(type, QPointF(x, y));
        if (node) {
            QString uuid = node->getId().toString();
            qDebug() << __FUNCTION__ << ": Node created successfully!";
            qDebug() << __FUNCTION__ << ": Node UUID:" << uuid;
            qDebug() << __FUNCTION__ << ": Node type:" << node->getNodeType();
            qDebug() << __FUNCTION__ << ": Node position:" << node->pos();
            emit nodeCreated(uuid);
            return uuid;
        } else {
            qDebug() << __FUNCTION__ << ": Factory returned null node";
            emit error("GraphController: Factory failed to create node");
        }
    } catch (const std::exception& e) {
        qDebug() << __FUNCTION__ << ": Exception during node creation:" << e.what();
        emit error(QString("GraphController: Error creating node: %1").arg(e.what()));
    }
    
    qDebug() << __FUNCTION__ << ": Node creation failed - returning empty string";
    return QString();
}

bool GraphController::deleteNode(const QString& uuid)
{
    if (!m_scene) {
        emit error("GraphController: Scene not initialized");
        return false;
    }
    
    Node* node = findNode(uuid);
    if (!node) {
        emit error(QString("GraphController: Node not found: %1").arg(uuid));
        return false;
    }
    
    qDebug() << "GraphController: Deleting node" << uuid;
    
    try {
        QUuid nodeId = QUuid::fromString(uuid);
        m_scene->deleteNode(nodeId);
        emit nodeDeleted(uuid);
        return true;
    } catch (const std::exception& e) {
        emit error(QString("GraphController: Error deleting node: %1").arg(e.what()));
        return false;
    }
}

bool GraphController::moveNode(const QString& uuid, qreal dx, qreal dy)
{
    Node* node = findNode(uuid);
    if (!node) {
        emit error(QString("GraphController: Node not found: %1").arg(uuid));
        return false;
    }
    
    QPointF currentPos = node->pos();
    QPointF newPos = currentPos + QPointF(dx, dy);
    
    qDebug() << "GraphController: Moving node" << uuid << "by" << dx << "," << dy;
    
    node->setPos(newPos);
    return true;
}

QVariantMap GraphController::getNode(const QString& uuid)
{
    Node* node = findNode(uuid);
    if (!node) {
        return QVariantMap();
    }
    
    return nodeToVariant(node);
}

QVariantList GraphController::getNodes()
{
    QVariantList nodes;
    
    if (!m_scene) {
        return nodes;
    }
    
    const auto& nodeMap = m_scene->getNodes();
    for (Node* node : nodeMap.values()) {
        nodes.append(nodeToVariant(node));
    }
    
    return nodes;
}

QString GraphController::connect(const QString& fromNodeId, int fromIndex, 
                                const QString& toNodeId, int toIndex)
{
    qDebug() << "GraphController::connect() called - from:" << fromNodeId.left(8) 
             << "[" << fromIndex << "] to:" << toNodeId.left(8) << "[" << toIndex << "]";
             
    if (!m_scene || !m_factory) {
        emit error("GraphController: Scene or factory not initialized");
        return QString();
    }
    
    Node* fromNode = findNode(fromNodeId);
    Node* toNode = findNode(toNodeId);
    
    if (!fromNode || !toNode) {
        emit error(QString("GraphController: Node not found for connection: %1 -> %2")
                  .arg(fromNodeId).arg(toNodeId));
        return QString();
    }
    
    // Validate connection before attempting
    emit error(QString("DEBUG: About to call canConnect() for %1[%2] -> %3[%4]")
              .arg(fromNodeId.left(8)).arg(fromIndex).arg(toNodeId.left(8)).arg(toIndex));
    if (!canConnect(fromNodeId, fromIndex, toNodeId, toIndex)) {
        qDebug() << "GraphController: Connection validation failed";
        emit error("DEBUG: canConnect() returned FALSE - connection blocked!");
        return QString();
    }
    emit error("DEBUG: canConnect() returned TRUE - proceeding with connection");
    
    qDebug() << "GraphController: Connecting" << fromNodeId << "[" << fromIndex << "] ->" 
             << toNodeId << "[" << toIndex << "]";
    
    try {
        // Find the appropriate sockets
        Socket* fromSocket = nullptr;
        Socket* toSocket = nullptr;
        
        // Get child sockets from nodes
        const auto& fromItems = fromNode->childItems();
        const auto& toItems = toNode->childItems();
        
        for (QGraphicsItem* item : fromItems) {
            if (Socket* socket = qgraphicsitem_cast<Socket*>(item)) {
                if (socket->getIndex() == fromIndex && socket->getRole() == Socket::Output) {
                    fromSocket = socket;
                    break;
                }
            }
        }
        
        for (QGraphicsItem* item : toItems) {
            if (Socket* socket = qgraphicsitem_cast<Socket*>(item)) {
                if (socket->getIndex() == toIndex && socket->getRole() == Socket::Input) {
                    toSocket = socket;
                    break;
                }
            }
        }
        
        if (!fromSocket || !toSocket) {
            emit error(QString("GraphController: Socket not found for connection"));
            return QString();
        }
        
        Edge* edge = m_factory->createEdge(fromNode, fromIndex, toNode, toIndex);
        if (edge) {
            QString uuid = edge->getId().toString();
            emit edgeCreated(uuid);
            qDebug() << "GraphController: Created edge" << uuid;
            return uuid;
        }
    } catch (const std::exception& e) {
        emit error(QString("GraphController: Error creating connection: %1").arg(e.what()));
    }
    
    return QString();
}

bool GraphController::deleteEdge(const QString& uuid)
{
    if (!m_scene) {
        emit error("GraphController: Scene not initialized");
        return false;
    }
    
    Edge* edge = findEdge(uuid);
    if (!edge) {
        emit error(QString("GraphController: Edge not found: %1").arg(uuid));
        return false;
    }
    
    qDebug() << "GraphController: Deleting edge" << uuid;
    
    try {
        QUuid edgeId = QUuid::fromString(uuid);
        m_scene->deleteEdge(edgeId);
        emit edgeDeleted(uuid);
        return true;
    } catch (const std::exception& e) {
        emit error(QString("GraphController: Error deleting edge: %1").arg(e.what()));
        return false;
    }
}

QVariantList GraphController::getEdges()
{
    QVariantList edges;
    
    if (!m_scene) {
        return edges;
    }
    
    const auto& edgeMap = m_scene->getEdges();
    for (Edge* edge : edgeMap.values()) {
        edges.append(edgeToVariant(edge));
    }
    
    return edges;
}

void GraphController::clear()
{
    if (!m_scene) {
        emit error("GraphController: Scene not initialized");
        return;
    }
    
    qDebug() << "GraphController: Clearing graph";
    
    m_scene->clearGraph();
    emit graphCleared();
}

void GraphController::saveXml(const QString& path)
{
    if (!m_scene) {
        emit error("GraphController: Scene not initialized");
        return;
    }
    
    qDebug() << "GraphController: Saving XML to" << path;
    
    try {
        // Create XML document
        xmlDocPtr doc = xmlNewDoc(BAD_CAST "1.0");
        xmlNodePtr root = xmlNewNode(NULL, BAD_CAST "graph");
        xmlDocSetRootElement(doc, root);
        xmlNewProp(root, BAD_CAST "version", BAD_CAST "1.0");
        
        // Add nodes
        const auto& nodes = m_scene->getNodes();
        for (Node* node : nodes.values()) {
            node->write(doc, root);
        }
        
        // Add edges
        const auto& edges = m_scene->getEdges();
        for (Edge* edge : edges.values()) {
            edge->write(doc, root);
        }
        
        // Save to file
        int result = xmlSaveFileEnc(path.toUtf8().constData(), doc, "UTF-8");
        xmlFreeDoc(doc);
        
        if (result != -1) {
            emit xmlSaved(path);
            qDebug() << "GraphController: XML saved successfully";
        } else {
            emit error(QString("GraphController: Failed to save XML to %1").arg(path));
        }
    } catch (const std::exception& e) {
        emit error(QString("GraphController: Error saving XML: %1").arg(e.what()));
    }
}

void GraphController::loadXml(const QString& path)
{
    if (!m_scene || !m_factory) {
        emit error("GraphController: Scene or factory not initialized");
        return;
    }
    
    qDebug() << "GraphController: Loading XML from" << path;
    
    try {
        // Clear existing graph
        m_scene->clearGraph();
        
        // Parse XML file
        xmlDocPtr doc = xmlParseFile(path.toUtf8().constData());
        if (!doc) {
            emit error(QString("GraphController: Failed to parse XML file: %1").arg(path));
            return;
        }
        
        xmlNodePtr root = xmlDocGetRootElement(doc);
        if (!root) {
            xmlFreeDoc(doc);
            emit error(QString("GraphController: Invalid XML structure in: %1").arg(path));
            return;
        }
        
        // Load nodes and edges through factory
        m_factory->loadFromXmlFile(path);
        
        xmlFreeDoc(doc);
        emit xmlLoaded(path);
        qDebug() << "GraphController: XML loaded successfully";
    } catch (const std::exception& e) {
        emit error(QString("GraphController: Error loading XML: %1").arg(e.what()));
    }
}

void GraphController::rebuildXml()
{
    qDebug() << "GraphController: Rebuilding XML from scene";
    
    // This would trigger XmlLiveSync to rebuild the XML from the current scene state
    // For now, we'll just log the action
    qDebug() << "GraphController: XML rebuild requested";
}

QString GraphController::getXmlString()
{
    if (!m_scene) {
        return QString();
    }
    
    try {
        // Create XML document
        xmlDocPtr doc = xmlNewDoc(BAD_CAST "1.0");
        xmlNodePtr root = xmlNewNode(NULL, BAD_CAST "graph");
        xmlDocSetRootElement(doc, root);
        xmlNewProp(root, BAD_CAST "version", BAD_CAST "1.0");
        
        // Add nodes
        const auto& nodes = m_scene->getNodes();
        for (Node* node : nodes.values()) {
            node->write(doc, root);
        }
        
        // Add edges
        const auto& edges = m_scene->getEdges();
        for (Edge* edge : edges.values()) {
            edge->write(doc, root);
        }
        
        // Convert to string
        xmlChar* xmlStr;
        int size;
        xmlDocDumpFormatMemoryEnc(doc, &xmlStr, &size, "UTF-8", 1);
        
        QString result = QString::fromUtf8(reinterpret_cast<const char*>(xmlStr));
        
        xmlFree(xmlStr);
        xmlFreeDoc(doc);
        
        return result;
    } catch (const std::exception& e) {
        emit error(QString("GraphController: Error generating XML string: %1").arg(e.what()));
        return QString();
    }
}

QVariantMap GraphController::getStats()
{
    QVariantMap stats;
    
    if (!m_scene) {
        stats["nodes"] = 0;
        stats["edges"] = 0;
        return stats;
    }
    
    const auto& nodes = m_scene->getNodes();
    const auto& edges = m_scene->getEdges();
    
    stats["nodes"] = nodes.size();
    stats["edges"] = edges.size();
    
    // Count by node type
    QVariantMap nodeTypes;
    for (Node* node : nodes.values()) {
        QString type = node->getNodeType();
        nodeTypes[type] = nodeTypes[type].toInt() + 1;
    }
    stats["nodeTypes"] = nodeTypes;
    
    return stats;
}

bool GraphController::isValidNodeType(const QString& type)
{
    QStringList registeredTypes = NodeRegistry::instance().getRegisteredTypes();
    bool isValid = registeredTypes.contains(type);
    qDebug() << "GraphController: Type validation:" << type << "→" << (isValid ? "VALID" : "INVALID");
    return isValid;
}

QStringList GraphController::getValidNodeTypes()
{
    QStringList types = NodeRegistry::instance().getRegisteredTypes();
    qDebug() << "GraphController: Available node types:" << types;
    return types;
}

Node* GraphController::findNode(const QString& uuid)
{
    if (!m_scene) {
        return nullptr;
    }
    
    QUuid nodeId = QUuid::fromString(uuid);
    return m_scene->getNode(nodeId);
}

Edge* GraphController::findEdge(const QString& uuid)
{
    if (!m_scene) {
        return nullptr;
    }
    
    QUuid edgeId = QUuid::fromString(uuid);
    return m_scene->getEdge(edgeId);
}

QVariantMap GraphController::nodeToVariant(Node* node)
{
    QVariantMap nodeData;
    
    if (!node) {
        return nodeData;
    }
    
    nodeData["id"] = node->getId().toString();
    nodeData["type"] = node->getNodeType();
    nodeData["x"] = node->pos().x();
    nodeData["y"] = node->pos().y();
    
    // Add node dimensions
    QRectF bounds = node->boundingRect();
    nodeData["width"] = bounds.width();
    nodeData["height"] = bounds.height();
    
    // Add selection state
    nodeData["selected"] = node->isSelected();
    
    // Add socket information with enhanced details
    QVariantList sockets;
    int inputCount = 0;
    int outputCount = 0;
    
    for (QGraphicsItem* item : node->childItems()) {
        if (Socket* socket = qgraphicsitem_cast<Socket*>(item)) {
            QVariantMap socketData;
            socketData["index"] = socket->getIndex();
            socketData["type"] = (socket->getRole() == Socket::Input) ? "input" : "output";
            socketData["connected"] = socket->isConnected();
            
            // Add socket position relative to node
            QPointF socketPos = socket->pos();
            socketData["relativeX"] = socketPos.x();
            socketData["relativeY"] = socketPos.y();
            
            sockets.append(socketData);
            
            if (socket->getRole() == Socket::Input) {
                inputCount++;
            } else {
                outputCount++;
            }
        }
    }
    
    nodeData["sockets"] = sockets;
    nodeData["inputCount"] = inputCount;
    nodeData["outputCount"] = outputCount;
    nodeData["totalSockets"] = sockets.size();
    
    // Add edge connection information
    nodeData["connectedEdges"] = node->getIncidentEdgeCount();
    
    return nodeData;
}

QVariantMap GraphController::edgeToVariant(Edge* edge)
{
    QVariantMap edgeData;
    
    if (!edge) {
        return edgeData;
    }
    
    edgeData["id"] = edge->getId().toString();
    
    // Add connection information
    Socket* fromSocket = edge->getFromSocket();
    Socket* toSocket = edge->getToSocket();
    
    if (fromSocket && toSocket) {
        edgeData["fromNode"] = fromSocket->getParentNode()->getId().toString();
        edgeData["fromIndex"] = fromSocket->getIndex();
        edgeData["toNode"] = toSocket->getParentNode()->getId().toString();
        edgeData["toIndex"] = toSocket->getIndex();
    }
    
    return edgeData;
}

QVariantList GraphController::getInputSockets(const QString& nodeId)
{
    QVariantList inputSockets;
    Node* node = findNode(nodeId);
    if (!node) {
        emit error(QString("GraphController: Node not found: %1").arg(nodeId));
        return inputSockets;
    }
    
    for (QGraphicsItem* item : node->childItems()) {
        if (Socket* socket = qgraphicsitem_cast<Socket*>(item)) {
            if (socket->getRole() == Socket::Input) {
                QVariantMap socketInfo;
                socketInfo["index"] = socket->getIndex();
                socketInfo["connected"] = socket->isConnected();
                socketInfo["type"] = "input";
                inputSockets.append(socketInfo);
            }
        }
    }
    
    return inputSockets;
}

QVariantList GraphController::getOutputSockets(const QString& nodeId)
{
    QVariantList outputSockets;
    Node* node = findNode(nodeId);
    if (!node) {
        emit error(QString("GraphController: Node not found: %1").arg(nodeId));
        return outputSockets;
    }
    
    for (QGraphicsItem* item : node->childItems()) {
        if (Socket* socket = qgraphicsitem_cast<Socket*>(item)) {
            if (socket->getRole() == Socket::Output) {
                QVariantMap socketInfo;
                socketInfo["index"] = socket->getIndex();
                socketInfo["connected"] = socket->isConnected();
                socketInfo["type"] = "output";
                outputSockets.append(socketInfo);
            }
        }
    }
    
    return outputSockets;
}

QVariantMap GraphController::getSocketInfo(const QString& nodeId, int socketIndex)
{
    QVariantMap socketInfo;
    Node* node = findNode(nodeId);
    if (!node) {
        emit error(QString("GraphController: Node not found: %1").arg(nodeId));
        return socketInfo;
    }
    
    for (QGraphicsItem* item : node->childItems()) {
        if (Socket* socket = qgraphicsitem_cast<Socket*>(item)) {
            if (socket->getIndex() == socketIndex) {
                socketInfo["index"] = socket->getIndex();
                socketInfo["type"] = (socket->getRole() == Socket::Input) ? "input" : "output";
                socketInfo["connected"] = socket->isConnected();
                socketInfo["role"] = socket->getRole();
                
                // Add position info
                QPointF pos = socket->pos();
                socketInfo["x"] = pos.x();
                socketInfo["y"] = pos.y();
                
                return socketInfo;
            }
        }
    }
    
    emit error(QString("GraphController: Socket %1 not found on node %2").arg(socketIndex).arg(nodeId));
    return socketInfo;
}

bool GraphController::canConnect(const QString& fromNodeId, int fromIndex, const QString& toNodeId, int toIndex)
{
    // Find nodes
    Node* fromNode = findNode(fromNodeId);
    Node* toNode = findNode(toNodeId);
    
    if (!fromNode || !toNode) {
        emit error(QString("GraphController: Node not found for connection validation: %1 -> %2")
                  .arg(fromNodeId).arg(toNodeId));
        return false;
    }
    
    // Find sockets
    Socket* fromSocket = nullptr;
    Socket* toSocket = nullptr;
    
    for (QGraphicsItem* item : fromNode->childItems()) {
        if (Socket* socket = qgraphicsitem_cast<Socket*>(item)) {
            if (socket->getIndex() == fromIndex && socket->getRole() == Socket::Output) {
                fromSocket = socket;
                break;
            }
        }
    }
    
    for (QGraphicsItem* item : toNode->childItems()) {
        if (Socket* socket = qgraphicsitem_cast<Socket*>(item)) {
            if (socket->getIndex() == toIndex && socket->getRole() == Socket::Input) {
                toSocket = socket;
                break;
            }
        }
    }
    
    if (!fromSocket || !toSocket) {
        emit error(QString("GraphController: Socket not found - from:%1[%2] to:%3[%4]")
                  .arg(fromNodeId).arg(fromIndex).arg(toNodeId).arg(toIndex));
        return false;
    }
    
    // Validate connection rules
    if (fromSocket->getRole() != Socket::Output) {
        emit error(QString("GraphController: Source socket must be OUTPUT, got %1")
                  .arg(fromSocket->getRole() == Socket::Input ? "INPUT" : "UNKNOWN"));
        return false;
    }
    
    if (toSocket->getRole() != Socket::Input) {
        emit error(QString("GraphController: Target socket must be INPUT, got %1")
                  .arg(toSocket->getRole() == Socket::Output ? "OUTPUT" : "UNKNOWN"));
        return false;
    }
    
    // Check if sockets are already connected
    if (fromSocket->isConnected() || toSocket->isConnected()) {
        emit error(QString("GraphController: Socket already connected - from:%1[%2]=%3 to:%4[%5]=%6")
                  .arg(fromNodeId).arg(fromIndex).arg(fromSocket->isConnected() ? "CONN" : "FREE")
                  .arg(toNodeId).arg(toIndex).arg(toSocket->isConnected() ? "CONN" : "FREE"));
        return false;
    }
    
    // Additional check: scan existing edges to prevent race conditions during rapid creation
    if (m_scene) {
        Scene* typedScene = static_cast<Scene*>(m_scene);
        const auto& existingEdges = typedScene->getEdges();
        emit error(QString("DEBUG: Scanning %1 existing edges for conflicts").arg(existingEdges.size()));
        for (Edge* existingEdge : existingEdges.values()) {
            // Debug: Show what we're comparing
            emit error(QString("DEBUG: Checking edge %1: from %2[%3] to %4[%5]")
                      .arg(existingEdge->getId().toString().left(8))
                      .arg(existingEdge->getFromNodeId().left(8))
                      .arg(existingEdge->getFromSocketIndex())
                      .arg(existingEdge->getToNodeId().left(8))
                      .arg(existingEdge->getToSocketIndex()));
            emit error(QString("DEBUG: Target comparison: existing='%1' vs new='%2', socket: existing=%3 vs new=%4")
                      .arg(existingEdge->getToNodeId())
                      .arg(toNodeId)
                      .arg(existingEdge->getToSocketIndex())
                      .arg(toIndex));
            
            // Check if an existing edge already connects to the target input socket
            // Normalize UUIDs by removing braces for comparison
            QString existingNodeId = existingEdge->getToNodeId();
            QString newNodeId = toNodeId;
            if (existingNodeId.startsWith("{")) existingNodeId.remove(0, 1);
            if (existingNodeId.endsWith("}")) existingNodeId.chop(1);
            if (newNodeId.startsWith("{")) newNodeId.remove(0, 1);
            if (newNodeId.endsWith("}")) newNodeId.chop(1);
            
            emit error(QString("DEBUG: Normalized comparison: existing='%1' vs new='%2'")
                      .arg(existingNodeId).arg(newNodeId));
            if (existingNodeId == newNodeId && existingEdge->getToSocketIndex() == toIndex) {
                qWarning() << "GraphController: BLOCKING double connection! Target socket already has connection";
                qWarning() << "  Existing edge:" << existingEdge->getId().toString().left(8) 
                          << "connects to" << toNodeId.left(8) << "[" << toIndex << "]";
                emit error(QString("DEBUG: BLOCKING double connection! Existing edge %1 connects to %2[%3]")
                          .arg(existingEdge->getId().toString().left(8)).arg(toNodeId.left(8)).arg(toIndex));
                return false;
            }
            // For completeness, check source socket too (though output sockets can have multiple connections in some designs)
            // Uncomment if you want to prevent multiple connections from the same output socket:
            // if (existingEdge->getFromNodeId() == fromNodeId && existingEdge->getFromSocketIndex() == fromIndex) {
            //     emit error(QString("GraphController: Source socket already has connection"));
            //     return false;
            // }
        }
        emit error("DEBUG: No existing edge conflicts found - connection allowed");
    }
    
    // Prevent self-connection
    if (fromNodeId == toNodeId) {
        emit error("GraphController: Cannot connect node to itself");
        return false;
    }
    
    return true;
}

=== CMakelists.txt ===

cmake_minimum_required(VERSION 3.16)
project(NodeGraph VERSION 1.0.0 LANGUAGES CXX)

# ─────────────────────────────────────
# NOTE: Code Review Compendium Script
# ─────────────────────────────────────
# generate_code_compendium.sh - Creates complete code review package
# This script is NOT part of the build - it's for reviewer delivery only
# Run: ./generate_code_compendium.sh to create reviewer package

# ─────────────────────────────────────
# 1.  C++ standard
# ─────────────────────────────────────
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# ─────────────────────────────────────
# 2.  Windows-specific defines
# ─────────────────────────────────────
if(WIN32)
    set(CMAKE_SYSTEM_VERSION 10.0)
    add_definitions(-DWIN32_LEAN_AND_MEAN -DNOMINMAX)
endif()

# ─────────────────────────────────────
# 3.  Default build-type
# ─────────────────────────────────────
if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Debug)
endif()

# ─────────────────────────────────────
# 4.  Qt search paths (adapt to your install)
# ─────────────────────────────────────
if(WIN32)
    list(APPEND CMAKE_PREFIX_PATH
        "E:/Qt/5.15.16/Release_x64"
        "E:/Qt/5.15.16/Debug_x64"
        "C:/Qt/5.15.2/msvc2019_64"
        "C:/Qt/5.15.2/msvc2019"
        "C:/Qt/5.12.12/msvc2017_64"
    )
else()
    # Linux/WSL: Auto-detect Qt installations in /usr/local/qt-*
    file(GLOB QT_INSTALL_DIRS "/usr/local/qt*")
    
    # Sort directories to prefer newer versions (reverse alphabetical)
    list(SORT QT_INSTALL_DIRS)
    list(REVERSE QT_INSTALL_DIRS)
    
    # Add found Qt installations to search path
    foreach(QT_DIR ${QT_INSTALL_DIRS})
        if(IS_DIRECTORY "${QT_DIR}")
            # Check for common Qt directory structures
            if(EXISTS "${QT_DIR}/lib/cmake/Qt5")
                list(APPEND CMAKE_PREFIX_PATH "${QT_DIR}")
                message(STATUS "Found Qt installation: ${QT_DIR}")
            endif()
            
            # Check for debug/release subdirectories
            if(EXISTS "${QT_DIR}/debug" AND EXISTS "${QT_DIR}/debug/lib/cmake/Qt5")
                list(APPEND CMAKE_PREFIX_PATH "${QT_DIR}/debug")
                message(STATUS "Found Qt Debug build: ${QT_DIR}/debug")
            endif()
            
            if(EXISTS "${QT_DIR}/release" AND EXISTS "${QT_DIR}/release/lib/cmake/Qt5")
                list(APPEND CMAKE_PREFIX_PATH "${QT_DIR}/release")
                message(STATUS "Found Qt Release build: ${QT_DIR}/release")
            endif()
        endif()
    endforeach()
    
    # Prefer debug builds for Debug configuration, release builds for Release
    if(CMAKE_BUILD_TYPE STREQUAL "Debug")
        message(STATUS "Debug build: Preferring Qt debug libraries")
    else()
        message(STATUS "Release build: Preferring Qt release libraries")
    endif()
endif()

# ─────────────────────────────────────
# 5.  Find Qt5 modules
# ─────────────────────────────────────
find_package(Qt5 REQUIRED COMPONENTS Core Widgets Gui Test Qml)

# ─────────────────────────────────────
# Find or build libxml2 for cross-platform XML handling
# ─────────────────────────────────────

# Try to use system libxml2 first (Linux/Unix only), fallback to FetchContent
set(USE_SYSTEM_LIBXML2 FALSE)

if(NOT WIN32)
    find_package(PkgConfig QUIET)
    if(PkgConfig_FOUND)
        pkg_check_modules(LIBXML2 QUIET libxml-2.0>=2.9.0)
        if(LIBXML2_FOUND AND LIBXML2_INCLUDE_DIRS)
            # Verify that we can actually find the headers
            find_path(LIBXML2_HEADER_TEST libxml/tree.h PATHS ${LIBXML2_INCLUDE_DIRS} NO_DEFAULT_PATH)
            if(LIBXML2_HEADER_TEST)
                set(USE_SYSTEM_LIBXML2 TRUE)
            endif()
        endif()
    endif()
endif()

if(USE_SYSTEM_LIBXML2)
    message(STATUS "Using system libxml2: ${LIBXML2_VERSION}")
    # Create an imported target for consistency
    add_library(LibXml2::LibXml2 INTERFACE IMPORTED)
    target_link_libraries(LibXml2::LibXml2 INTERFACE ${LIBXML2_LIBRARIES})
    target_include_directories(LibXml2::LibXml2 INTERFACE ${LIBXML2_INCLUDE_DIRS})
    target_compile_options(LibXml2::LibXml2 INTERFACE ${LIBXML2_CFLAGS_OTHER})
else()
    # Use FetchContent with persistent global cache
    include(FetchContent)
    
    # Set a global cache directory that persists across builds (separate for Debug/Release)
    set(FETCHCONTENT_BASE_DIR "${CMAKE_SOURCE_DIR}/.cmake-cache/${CMAKE_BUILD_TYPE}" CACHE PATH "FetchContent cache directory")
    
    # Check if libxml2 is already populated to avoid rebuilding
    FetchContent_GetProperties(libxml2)
    if(NOT libxml2_POPULATED)
        if(WIN32)
            message(STATUS "Windows: Building libxml2 from source (cached) - downloading and building...")
        else()
            message(STATUS "libxml2 not found in persistent cache - downloading and building...")
        endif()
        
        FetchContent_Declare(
            libxml2
            GIT_REPOSITORY https://github.com/GNOME/libxml2.git
            GIT_TAG        v2.12.5  # Stable version
            GIT_SHALLOW    TRUE
            SOURCE_DIR     "${FETCHCONTENT_BASE_DIR}/libxml2-src"
            BINARY_DIR     "${FETCHCONTENT_BASE_DIR}/libxml2-build"
        )
        
        # Configure libxml2 build options - minimal features for performance
        set(BUILD_SHARED_LIBS OFF CACHE BOOL "Build shared libraries" FORCE)
        set(LIBXML2_WITH_ICONV OFF CACHE BOOL "Build with iconv support" FORCE)
        set(LIBXML2_WITH_LZMA OFF CACHE BOOL "Build with lzma support" FORCE) 
        set(LIBXML2_WITH_ZLIB OFF CACHE BOOL "Build with zlib support" FORCE)
        set(LIBXML2_WITH_PYTHON OFF CACHE BOOL "Build Python bindings" FORCE)
        set(LIBXML2_WITH_TESTS OFF CACHE BOOL "Build tests" FORCE)
        set(LIBXML2_WITH_PROGRAMS OFF CACHE BOOL "Build programs" FORCE)
        set(LIBXML2_WITH_HTTP OFF CACHE BOOL "Build with HTTP support" FORCE)
        set(LIBXML2_WITH_FTP OFF CACHE BOOL "Build with FTP support" FORCE)
        
        FetchContent_MakeAvailable(libxml2)
        message(STATUS "libxml2 build complete - cached in ${FETCHCONTENT_BASE_DIR}")
    else()
        message(STATUS "libxml2 found in persistent cache - skipping rebuild")
    endif()
endif()

# ─────────────────────────────────────
# Note: Graaf integration disabled for now due to heavy dependencies
# Will use lightweight custom layout implementation instead
# ─────────────────────────────────────

# Enable libxml2 for all platforms
add_definitions(-DUSE_LIBXML2)

# auto-moc for QObject / signals
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)

# ─────────────────────────────────────
# 6.  MSVC compiler options
# ─────────────────────────────────────
if(MSVC)
    add_compile_options(/W3 /MP)
    add_definitions(-D_CRT_SECURE_NO_WARNINGS -DUNICODE -D_UNICODE)
endif()

# ─────────────────────────────────────
# 7.  Shared core library to avoid double building
# ─────────────────────────────────────
set(CORE_SOURCES
    # Self-serializing architecture
    node.h
    node.cpp
    socket.h
    socket.cpp
    edge.h
    edge.cpp
    ghost_edge.h
    ghost_edge.cpp
    
    # Phase 11: Type-erasure facade system
    node_facade.h
    edge_facade.h
    
    # Node registry system
    node_registry.h
    node_registry.cpp
    
    # XML-first factory
    graph_factory.h
    graph_factory.cpp
    
    # Template-driven scriptable node types
    node_type_templates.h
    node_type_templates.cpp
    
    # Layout engine using Graaf (disabled for now)
    # layout_engine.h
    # layout_engine.cpp
    
    # UI classes
    window.h
    window.cpp
    view.h
    view.cpp
    scene.h
    scene.cpp
    
    # Professional drag-and-drop palette
    node_palette_widget.h
    node_palette_widget.cpp
    
    # JavaScript engine integration
    javascript_engine.h
    javascript_engine.cpp
    # javascript_console.h
    # javascript_console.cpp
    graph_controller.h
    graph_controller.cpp
    script_executor.h
    script_executor.cpp
    
    # Template system
    template_registry.h
    template_registry.cpp
    
    # Observer pattern implementation
    graph_observer.h
    graph_observer.cpp
    xml_autosave_observer.h
    xml_autosave_observer.cpp
    
    # Live XML synchronization (not implemented yet)
    # xml_live_sync.h
    # xml_live_sync.cpp
)

# Main application sources (only main.cpp + resources)
set(MAIN_SOURCES
    main.cpp
    icons.qrc
)

# Test application sources (only test files)
set(TEST_SOURCES
    tst_main.h
    tst_main.cpp
)


# Facade test sources (Phase 11 experimental)
set(FACADE_TEST_SOURCES
    test_facade_core.cpp
)

# ─────────────────────────────────────
# 8.  Shared core library - compile once, use twice
# ─────────────────────────────────────
add_library(NodeGraphCore STATIC ${CORE_SOURCES})

# ─────────────────────────────────────
# 9.  Main executable target
# ─────────────────────────────────────
add_executable(NodeGraph WIN32 ${MAIN_SOURCES})
target_link_libraries(NodeGraph NodeGraphCore)

# ─────────────────────────────────────
# 10. Test executable target
# ─────────────────────────────────────
add_executable(NodeGraphTests ${TEST_SOURCES})
target_link_libraries(NodeGraphTests NodeGraphCore)

# ─────────────────────────────────────
# 11. Phase 11 Facade Test executable (optional)
# ─────────────────────────────────────
option(BUILD_FACADE_TESTS "Build Phase 11 facade tests" OFF)
if(BUILD_FACADE_TESTS)
    add_executable(TestFacadeCore ${FACADE_TEST_SOURCES})
    target_link_libraries(TestFacadeCore NodeGraphCore)
    message(STATUS "Building Phase 11 facade tests")
endif()

# ─────────────────────────────────────
# 12. Automatic Testing Setup
# ─────────────────────────────────────
option(ENABLE_AUTOMATIC_TESTS "Enable automatic test execution" ON)
if(ENABLE_AUTOMATIC_TESTS)
    enable_testing()
    
    # Add main test suite (now includes JavaScript engine tests)
    add_test(NAME MainTests COMMAND NodeGraphTests)
    
    # Add facade tests if enabled
    if(BUILD_FACADE_TESTS)
        add_test(NAME FacadeTests COMMAND TestFacadeCore)
    endif()
    
    message(STATUS "Automatic testing enabled - run 'ctest' to execute all tests")
    message(STATUS "JavaScript engine tests integrated into MainTests")
endif()

# Always use FetchContent libxml2 - Core library (shared by both main and test)
target_link_libraries(NodeGraphCore
    Qt5::Core
    Qt5::Widgets
    Qt5::Gui
    Qt5::Test
    Qt5::Qml
    LibXml2::LibXml2
)

# ─────────────────────────────────────
# 12. VS / Windows extras
# ─────────────────────────────────────
if(WIN32)
    # Main application settings
    set_target_properties(NodeGraph PROPERTIES
        WIN32_EXECUTABLE TRUE
        VS_DPI_AWARE "PerMonitor"
        RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}"
        
        # Separate Debug and Release Qt paths
        VS_DEBUGGER_ENVIRONMENT_DEBUG
            "PATH=E:/Qt/5.15.16/Debug_x64/bin;%PATH%"
        VS_DEBUGGER_ENVIRONMENT_RELEASE
            "PATH=E:/Qt/5.15.16/Release_x64/bin;%PATH%"
            
        # No command arguments - removed test_working_graph.xml
        VS_DEBUGGER_WORKING_DIRECTORY
            "${CMAKE_CURRENT_SOURCE_DIR}"
    )
    
    # Test application settings  
    set_target_properties(NodeGraphTests PROPERTIES
        WIN32_EXECUTABLE FALSE
        RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}"
        
        # Separate Debug and Release Qt paths for tests
        VS_DEBUGGER_ENVIRONMENT_DEBUG
            "PATH=E:/Qt/5.15.16/Debug_x64/bin;%PATH%"
        VS_DEBUGGER_ENVIRONMENT_RELEASE
            "PATH=E:/Qt/5.15.16/Release_x64/bin;%PATH%"
            
        VS_DEBUGGER_WORKING_DIRECTORY
            "${CMAKE_CURRENT_SOURCE_DIR}"
    )
    
    set_property(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
                 PROPERTY VS_STARTUP_PROJECT NodeGraph)
endif()

# ─────────────────────────────────────
# 13. Install rules (optional on Win)
# ─────────────────────────────────────
if(WIN32)
    install(TARGETS NodeGraph NodeGraphTests RUNTIME DESTINATION .)
    install(FILES
        $<TARGET_FILE:Qt5::Core>
        $<TARGET_FILE:Qt5::Widgets>
        $<TARGET_FILE:Qt5::Gui>
        DESTINATION .
    )
endif()

# ─────────────────────────────────────
# 14. Info
# ─────────────────────────────────────
message(STATUS "Build type       : ${CMAKE_BUILD_TYPE}")
message(STATUS "Qt5 found        : ${Qt5_FOUND}")
message(STATUS "Qt5 version      : ${Qt5_VERSION}")
message(STATUS "Qt5 location     : ${Qt5_DIR}")

# Cache information
if(USE_SYSTEM_LIBXML2)
    message(STATUS "libxml2 source   : System package")
else()
    FetchContent_GetProperties(libxml2)
    if(libxml2_POPULATED)
        message(STATUS "libxml2 source   : FetchContent (cached)")
    else()
        if(WIN32)
            message(STATUS "libxml2 source   : FetchContent (will build for Windows)")
        else()
            message(STATUS "libxml2 source   : FetchContent (will download)")
        endif()
    endif()
endif()



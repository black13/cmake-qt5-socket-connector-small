// === Concatenated Top-Level C++ Code Files ===
// Created on Mon Jul 14 09:20:06 CDT 2025

// ====================================
// FILE: edge.h
// LAST MODIFIED: 2025-07-14 08:28:45
// ====================================

#pragma once

#include <QGraphicsItem>
#include <QPainter>
#include <QStyleOptionGraphicsItem>
#include <QWidget>
#include <QUuid>
#include <QString>
#include <QColor>
#include <QPainterPath>
#include <QPainterPathStroker>
#include <QPointF>
#include <functional>
#include <libxml/tree.h>

class Socket;
class Node;

/**
 * Edge - Connection between two sockets
 * 
 * Core principles:
 * - Self-serializing connection between socket UUIDs
 * - No QObject inheritance or connect usage
 * - Draws path from socket to socket
 * - References sockets by UUID, not pointers
 */
class Edge : public QGraphicsItem
{
public:
    Edge(const QUuid& id = QUuid::createUuid(),
         const QUuid& fromSocketId = QUuid(),
         const QUuid& toSocketId = QUuid());
    ~Edge(); // Destructor for node unregistration
    
    // Core identity
    const QUuid& getId() const { return m_id; }
    
    // Self-serialization interface
    xmlNodePtr write(xmlDocPtr doc, xmlNodePtr repr = nullptr) const;
    void read(xmlNodePtr node);
    
    // QGraphicsItem interface
    QRectF boundingRect() const override;
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) override;
    QPainterPath shape() const override;
    int type() const override { return UserType + 1; } // Edge type identifier
    QVariant itemChange(GraphicsItemChange change, const QVariant &value) override;
    
    // Connection management - clean design uses node+index only
    // No socket UUIDs - edges resolved via resolveConnections() method
    
    // Visual state uses Qt's selection system
    // Use QGraphicsItem::isSelected() and setSelected()
    
    // Path update - call when socket positions change
    void updatePath();
    
    // Mouse event debugging and interaction
    void mousePressEvent(QGraphicsSceneMouseEvent *event) override;
    void mouseReleaseEvent(QGraphicsSceneMouseEvent *event) override;
    void hoverEnterEvent(QGraphicsSceneHoverEvent *event) override;
    void hoverLeaveEvent(QGraphicsSceneHoverEvent *event) override;
    
    // Connection checking
    bool isConnectedToNode(const QString& nodeId) const;
    bool isConnectedToNode(const QUuid& nodeId) const;  // Optimized UUID version
    
    // Socket resolution after all nodes are loaded
    bool resolveConnections(class Scene* scene);
    
    // Direct connection methods (optimization for GraphFactory)
    void setConnectionData(const QString& fromNodeId, const QString& toNodeId, 
                          int fromSocketIndex, int toSocketIndex);
    void setResolvedSockets(Socket* fromSocket, Socket* toSocket);
    
    // Built-in destruction safety - called by Node destructor
    void onNodeDestroying(const Node* node);
    
    // Public accessors for layout engine (with safety checks)
    Node* getFromNode() const { return m_fromNodeValid ? m_fromNode : nullptr; }
    Node* getToNode() const { return m_toNodeValid ? m_toNode : nullptr; }
    Socket* getFromSocket() const { return m_fromSocket; }
    Socket* getToSocket() const { return m_toSocket; }
    
    // Socket index accessors for XML serialization
    int getFromSocketIndex() const { return m_fromSocketIndex; }
    int getToSocketIndex() const { return m_toSocketIndex; }

private:
    QUuid m_id;
    QString m_fromNodeId;     // Store node IDs from XML (for serialization)
    QString m_toNodeId;
    QUuid m_fromNodeUuid;     // Cached UUIDs for fast comparison
    QUuid m_toNodeUuid;
    int m_fromSocketIndex;    // Store socket indices from XML
    int m_toSocketIndex;
    Socket* m_fromSocket;     // Resolved socket pointers
    Socket* m_toSocket;
    
    // Built-in destruction safety with validity flags
    Node* m_fromNode;                  // Source node (raw pointer)
    Node* m_toNode;                    // Destination node (raw pointer)
    bool m_fromNodeValid;              // Track if fromNode is still alive
    bool m_toNodeValid;                // Track if toNode is still alive
    
    // Cached path for rendering
    QPainterPath m_path;
    QRectF m_boundingRect;
    
    // Interaction state
    bool m_hovered;
    
    #ifdef QT_DEBUG
    // Per-edge debug counter (thread-safe, per-instance)
    mutable int m_shapeCallCount;
    #endif
    
    // Visual styling
    void buildPath(const QPointF& start, const QPointF& end);
};

// ====================================
// FILE: graph_factory.h
// LAST MODIFIED: 2025-07-07 12:06:19
// ====================================

#pragma once

#include <QGraphicsScene>
#include <QUuid>
#include <QString>
#include <QPointF>
#include <QDebug>
#include <libxml/tree.h>
#include "socket.h"

class Node;
class Edge;

/**
 * GraphFactory - XML-First Object Creation with NodeRegistry
 * 
 * Simplified factory that uses NodeRegistry for type-based creation.
 * Enforces XML-first discipline while allowing extensible node types.
 */
class GraphFactory
{
public:
    // Initialize factory with scene and XML document
    GraphFactory(QGraphicsScene* scene, xmlDocPtr xmlDoc);
    
    // XML-first creation methods
    Node* createNodeFromXml(xmlNodePtr xmlNode);
    Edge* createEdgeFromXml(xmlNodePtr xmlEdge);
    
    // Runtime creation (creates XML first, then objects)
    Node* createNode(const QString& nodeType, const QPointF& position, int inputs = 1, int outputs = 1);
    Edge* createEdge(Node* fromNode, int fromSocketIndex, Node* toNode, int toSocketIndex);
    
    // Atomic edge connection - enforces proper edge creation
    Edge* connectSockets(Socket* fromSocket, Socket* toSocket);
    
    // Post-load validation
    bool validateGraphIntegrity() const;
    
    // XML file loading
    bool loadFromXmlFile(const QString& filePath);
    
    // Clean design: socket resolution handled by edges internally
    
    // Socket factory method - prevents manual socket creation
    Socket* createSocket(Socket::Role role, Node* parentNode, int index);
    
    // Utility to get XML property
    static QString getXmlProperty(xmlNodePtr node, const QString& name);

private:
    QGraphicsScene* m_scene;
    xmlDocPtr m_xmlDocument;
    
    // Helper methods
    xmlNodePtr createXmlNode(const QString& nodeType, const QPointF& position, int inputs = 1, int outputs = 1);
    xmlNodePtr createXmlEdgeNodeIndex(const QUuid& fromNodeId, int fromSocketIndex, const QUuid& toNodeId, int toSocketIndex);
    
    // Get nodes/edges parent elements in XML
    xmlNodePtr getNodesElement();
    xmlNodePtr getEdgesElement();
};

// ====================================
// FILE: graph_observer.h
// LAST MODIFIED: 2025-07-12 02:11:27
// ====================================

#pragma once

#include <QSet>
#include <QUuid>
#include <QPointF>

// Forward declarations
class Node;
class Edge;

/**
 * GraphObserver - Interface for observing graph changes
 * 
 * Pure virtual interface that observers implement to receive
 * notifications about graph mutations.
 */
class GraphObserver
{
public:
    virtual ~GraphObserver() = default;

    // Node lifecycle events
    virtual void onNodeAdded(const Node& node) {}
    virtual void onNodeRemoved(const QUuid& nodeId) {}
    virtual void onNodeMoved(const QUuid& nodeId, QPointF oldPos, QPointF newPos) {}
    
    // Edge lifecycle events  
    virtual void onEdgeAdded(const Edge& edge) {}
    virtual void onEdgeRemoved(const QUuid& edgeId) {}
    
    // Graph-level events
    virtual void onGraphCleared() {}
    virtual void onGraphLoaded(const QString& filename) {}
    virtual void onGraphSaved(const QString& filename) {}
};

/**
 * GraphSubject - Base class for observable graph entities
 * 
 * Manages observer registration and provides notification helpers
 * for subclasses (Scene, GraphModel, etc.)
 */
class GraphSubject
{
public:
    virtual ~GraphSubject();
    
    // Observer management
    void attach(GraphObserver* observer);
    void detach(GraphObserver* observer);
    
    // Batch mode for bulk operations (prevents observer storm)
    static void beginBatch();
    static void endBatch();
    static bool isInBatch() { return s_batchDepth > 0; }
    
protected:
    // Notification helpers for subclasses
    void notifyNodeAdded(const Node& node);
    void notifyNodeRemoved(const QUuid& nodeId);
    void notifyNodeMoved(const QUuid& nodeId, QPointF oldPos, QPointF newPos);
    void notifyEdgeAdded(const Edge& edge);
    void notifyEdgeRemoved(const QUuid& edgeId);
    void notifyGraphCleared();
    void notifyGraphLoaded(const QString& filename);
    void notifyGraphSaved(const QString& filename);
    
private:
    QSet<GraphObserver*> m_observers;
    
    // Static batch control
    static int s_batchDepth;
};

// ====================================
// FILE: layout_engine.h
// LAST MODIFIED: 2025-07-11 16:17:01
// ====================================

#pragma once

#include <QPointF>
#include <QUuid>
#include <QString>
#include <QHash>
#include <QList>
#include <QPair>
#include <QDebug>
#include <QVector>

class Node;
class Edge;
class Scene;

/**
 * Layout Engine - Lightweight graph layout algorithms
 * 
 * Provides multiple layout algorithms for node graph positioning
 * without external dependencies beyond Qt5.
 */
class LayoutEngine
{
public:
    enum LayoutType {
        Grid,
        ForceDirected,
        Hierarchical,
        Circular,
        Random
    };
    
    struct LayoutNode {
        QUuid id;
        QPointF position;
        QPointF velocity;  // For force-directed algorithms
        bool fixed;        // Pin node position
        
        LayoutNode() : fixed(false) {}
        LayoutNode(const QUuid& nodeId, const QPointF& pos) 
            : id(nodeId), position(pos), fixed(false) {}
    };
    
    struct LayoutEdge {
        QUuid fromNodeId;
        QUuid toNodeId;
        qreal weight;      // Edge weight for algorithms
        
        LayoutEdge() : weight(1.0) {}
        LayoutEdge(const QUuid& from, const QUuid& to, qreal w = 1.0)
            : fromNodeId(from), toNodeId(to), weight(w) {}
    };
    
    LayoutEngine();
    
    // Graph construction from Scene
    void buildGraphFromScene(Scene* scene);
    void addNode(const QUuid& nodeId, const QPointF& position);
    void addEdge(const QUuid& fromNodeId, const QUuid& toNodeId, qreal weight = 1.0);
    void clear();
    
    // Layout algorithms
    void applyGridLayout(qreal spacing = 100.0);
    void applyCircularLayout(qreal radius = 200.0);
    void applyForceDirectedLayout(int iterations = 100, qreal k = 50.0);
    void applyRandomLayout(qreal width = 800.0, qreal height = 600.0);
    
    // Results
    QHash<QUuid, QPointF> getNodePositions() const;
    void applyToScene(Scene* scene);
    
    // Configuration
    void setCanvasSize(qreal width, qreal height) { m_canvasWidth = width; m_canvasHeight = height; }
    void setNodeFixed(const QUuid& nodeId, bool fixed);
    
    // Debug
    void printGraphStats() const;
    
private:
    QHash<QUuid, LayoutNode> m_nodes;  // Simple node storage
    QVector<LayoutEdge> m_edges;       // Simple edge storage
    
    qreal m_canvasWidth;
    qreal m_canvasHeight;
    
    // Force-directed algorithm helpers
    QPointF calculateRepulsiveForce(const LayoutNode& node1, const LayoutNode& node2, qreal k) const;
    QPointF calculateAttractiveForce(const LayoutNode& node1, const LayoutNode& node2, qreal k) const;
    void updateNodePosition(const QUuid& nodeId, const QPointF& force, qreal timeStep);
    
    // Utility functions
    QPointF constrainToCanvas(const QPointF& position) const;
};

// ====================================
// FILE: node.h
// LAST MODIFIED: 2025-07-14 03:03:20
// ====================================

#pragma once

#include <QGraphicsItem>
#include <QGraphicsScene>
#include <QPainter>
#include <QStyleOptionGraphicsItem>
#include <QWidget>
#include <QUuid>
#include <QPointF>
#include <QString>
#include <QVector>
#include <QRectF>
#include <QSizeF>
#include <QColor>
#include <QSet>
#include <libxml/tree.h>

// Forward declarations to avoid circular includes
class Socket;
class Edge;

/**
 * Node - A self-serializing visual node
 * 
 * Core principles:
 * - Self-serialization via write()/read() methods
 * - Value semantics, no smart pointers
 * - No QObject inheritance or connect usage
 * - Sockets are children of nodes only
 * - Uses Qt containers instead of std library
 */
class Node : public QGraphicsItem
{
public:
    Node(const QUuid& id = QUuid::createUuid(), 
         const QPointF& position = QPointF(100, 100));
    ~Node(); // Destructor for safe edge invalidation
    
    // Core identity
    const QUuid& getId() const { return m_id; }
    
    // Self-serialization interface
    xmlNodePtr write(xmlDocPtr doc, xmlNodePtr repr = nullptr) const;
    virtual void read(xmlNodePtr node);
    
    // QGraphicsItem interface
    QRectF boundingRect() const override;
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) override;
    int type() const override { return UserType + 2; } // Node type identifier
    
    // Movement tracking for live XML updates
    QVariant itemChange(GraphicsItemChange change, const QVariant &value) override;
    
    // Node properties
    void setNodeSize(qreal width, qreal height);
    QSizeF getNodeSize() const { return QSizeF(m_width, m_height); }
    void calculateAndSetNodeSize(int inputCount, int outputCount);
    
    // Visual state - using Qt's selection system
    // Use QGraphicsItem::isSelected() and setSelected()
    
    // Socket management - O(1) performance
    Socket* getSocketByIndex(int index) const;
    int getSocketCount() const;
    void setNodeType(const QString& type);
    QString getNodeType() const { return m_nodeType; }
    
    // Built-in destruction safety
    bool isBeingDestroyed() const { return m_beingDestroyed; }
    
    // Socket registration for performance cache
    void registerSocket(Socket* socket, int index);
    
    // XML-driven socket creation
    void createSocketsFromXml(int inputCount, int outputCount);
    
    // Change notification - simple callback, no connect
    void setChangeCallback(void (*callback)(Node*));
    
    // Observer interface for GraphFactory - contract enforcement
    void setObserver(void* observer) { m_observer = observer; }
    bool hasObserver() const { return m_observer != nullptr; }
    void* getObserver() const { return m_observer; }
    
    // Edge connection management - O(degree) performance optimization
    void registerEdge(Edge* edge);
    void unregisterEdge(Edge* edge);
    void updateConnectedEdges();
    
    // Debug/testing helper
    int getIncidentEdgeCount() const { return m_incidentEdges.size(); }

private:
    QUuid m_id;
    QString m_nodeType;
    qreal m_width;
    qreal m_height;
    
    // Performance optimization: cache display string (created once, not every frame)
    mutable QString m_cachedDisplayId;
    
    // Socket cache for O(1) lookups - critical performance fix
    QVector<Socket*> m_sockets;  // Indexed by socket index for O(1) access
    
    // Edge adjacency set for O(degree) edge updates - performance optimization
    QSet<Edge*> m_incidentEdges;  // Edges touching this node (cleaned up by Edge destructor)
    
    // Built-in destruction safety flag
    bool m_beingDestroyed;        // Set to true during destruction
    
    // Simple callback - no QObject connect
    void (*m_changeCallback)(Node*);
    
    // Observer for contract enforcement
    void* m_observer;
    
    // Per-node position tracking (fixes global static bug)
    QPointF m_lastPos;
    
    // Socket creation
    void createStaticSockets();
    
    // Visual styling helpers
    void paintSockets(QPainter* painter) const;
};

// ====================================
// FILE: node_palette_bar.h
// LAST MODIFIED: 2025-07-14 09:09:44
// ====================================

#pragma once

#include <QWidget>
#include <QGridLayout>
#include <QVBoxLayout>
#include <QLabel>
#include <QScrollArea>
#include "node_tool_button.h"

/**
 * NodePaletteBar - Professional node palette for graph editing
 * 
 * Provides an organized collection of node types that users can add
 * to the scene. Supports categorization and clean visual layout.
 */
class NodePaletteBar : public QWidget
{
    Q_OBJECT

public:
    explicit NodePaletteBar(QWidget* parent = nullptr);
    
    // Add nodes dynamically
    void addNodeType(const QString& category, const QString& nodeType, const QIcon& icon);
    void addSeparator();

signals:
    void nodeSelected(const QString& nodeType);

private slots:
    void onNodeClicked(const QString& nodeType);

private:
    QVBoxLayout* m_mainLayout;
    QWidget* m_contentWidget;
    QScrollArea* m_scrollArea;
    
    void setupUI();
    void addBasicNodes();
    void addMathNodes();
    void addIONodes();
    
    QWidget* createCategorySection(const QString& title);
    void addToolToLayout(QGridLayout* layout, const QString& name, const QIcon& icon, int row, int col);
    
    // Create icons that show socket configuration
    QIcon createNodeIcon(const QString& nodeType);
    QIcon createTextIcon(const QString& text, const QColor& bgColor = QColor(200, 200, 255));
    QIcon createSocketIcon(int inputs, int outputs, const QColor& bgColor);
};

// ====================================
// FILE: node_palette_widget.h
// LAST MODIFIED: 2025-07-14 03:03:20
// ====================================

#pragma once

#include <QWidget>
#include <QScrollArea>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGridLayout>
#include <QLineEdit>
#include <QLabel>
#include <QPushButton>
#include <QToolButton>
#include <QFrame>

/**
 * PaletteButton - Consistent button for palette operations
 * 
 * Features:
 * - Uniform 24x24 icon size
 * - Consistent styling and hover states
 * - Tooltip support
 * - Icon resource alias support
 */
class PaletteButton : public QToolButton {
    Q_OBJECT
public:
    explicit PaletteButton(const QString& iconAlias, 
                          const QString& tooltip, 
                          QWidget* parent = nullptr);
    
    // Set checkable state for toggle tools
    void setCheckable(bool checkable);
    
    // Visual states
    void setHighlighted(bool highlighted);

private:
    void setupStyling();
};

/**
 * NodePaletteWidget - Icon-based node palette with grid layout
 * 
 * Features:
 * - Search filtering
 * - Double-click node creation
 * - Icon-based grid layout
 * - Professional visual node type recognition
 * - Integration with self-serializing nodes
 */
class NodePaletteWidget : public QWidget
{
    Q_OBJECT

public:
    explicit NodePaletteWidget(QWidget* parent = nullptr);
    
    // Node category enumeration
    enum class NodeCategory {
        Sources,    // Input nodes, data sources
        Processors, // Processing, transformation nodes  
        Outputs,    // Output nodes, sinks
        Math,       // Mathematical operations
        Logic,      // Logical operations
        Custom      // User-defined nodes
    };
    
    // Enhanced node template structure
    struct NodeTemplate {
        QString type;           // Node type (IN, OUT, PROCESSOR, etc.)
        QString name;           // Display name
        QString description;    // Tooltip description
        QString iconPath;       // Icon file path
        NodeCategory category;  // Node category for organization
        int inputSockets;       // Number of input sockets
        int outputSockets;      // Number of output sockets
        QStringList keywords;   // Keywords for search filtering
        
        // Default constructor for QVariant
        NodeTemplate() : category(NodeCategory::Custom), inputSockets(0), outputSockets(0) {}
        
        // Copy constructor
        NodeTemplate(const NodeTemplate& other) = default;
        NodeTemplate& operator=(const NodeTemplate& other) = default;
    };

signals:
    // Emitted when user wants to create a node
    void nodeCreationRequested(const NodeTemplate& nodeTemplate);

private slots:
    void filterChanged(const QString& text);
    void onNodeButtonClicked();

private:
    void setupUI();
    void populateNodeTemplates();
    void addNodeTemplate(const NodeTemplate& nodeTemplate);
    void updateVisibility();
    
    // Custom node button class
    class NodeButton : public QPushButton {
    public:
        NodeButton(const NodeTemplate& nodeTemplate, QWidget* parent = nullptr);
        NodeTemplate getNodeTemplate() const { return m_nodeTemplate; }
        bool matchesFilter(const QString& filter) const;
    private:
        NodeTemplate m_nodeTemplate;
        static QIcon createNodeIcon(const NodeTemplate& nodeTemplate);
    };
    
    // UI components
    QVBoxLayout* m_mainLayout;
    QLineEdit* m_searchEdit;
    QScrollArea* m_scrollArea;
    QWidget* m_scrollContent;
    QGridLayout* m_gridLayout;
    QLabel* m_titleLabel;
    
    // Node templates and buttons
    QList<NodeTemplate> m_nodeTemplates;
    QList<NodeButton*> m_nodeButtons;
    QString m_currentFilter;
};

// Declare NodeTemplate as a Qt metatype for QVariant storage
Q_DECLARE_METATYPE(NodePaletteWidget::NodeTemplate)

// ====================================
// FILE: node_registry.h
// LAST MODIFIED: 2025-07-07 12:06:19
// ====================================

#pragma once

#include <QString>
#include <QMap>
#include <functional>

class Node;

/**
 * NodeRegistry - Factory registry for node types
 * 
 * Allows registering node types by string name and creating instances
 * without the factory knowing about concrete types.
 * 
 * Usage:
 *   NodeRegistry::instance().registerNode("SOURCE", []() { return new SourceNode(); });
 *   Node* node = NodeRegistry::instance().createNode("SOURCE");
 */

using NodeFactoryFunction = std::function<Node*()>;

class NodeRegistry
{
public:
    // Singleton instance
    static NodeRegistry& instance();
    
    // Register a node type with its factory function
    void registerNode(const QString& typeName, NodeFactoryFunction factory);
    
    // Create a node instance by type name
    Node* createNode(const QString& typeName) const;
    
    // Check if a type is registered
    bool isRegistered(const QString& typeName) const;
    
    // Get all registered type names
    QStringList getRegisteredTypes() const;
    
    // Clear all registrations (for testing)
    void clear();

private:
    NodeRegistry() = default;
    NodeRegistry(const NodeRegistry&) = delete;
    NodeRegistry& operator=(const NodeRegistry&) = delete;
    
    QMap<QString, NodeFactoryFunction> m_factories;
};

/**
 * Convenience macro for registering node types
 * Use this in the .cpp file of each node type:
 * 
 * REGISTER_NODE_TYPE("SOURCE", SourceNode)
 */
#define REGISTER_NODE_TYPE(typeName, className) \
    namespace { \
        struct Register##className { \
            Register##className() { \
                NodeRegistry::instance().registerNode(typeName, []() { \
                    return new className(); \
                }); \
            } \
        }; \
        static Register##className register##className##Instance; \
    }


// ====================================
// FILE: node_tool_button.h
// LAST MODIFIED: 2025-07-14 09:07:54
// ====================================

#pragma once

#include <QToolButton>
#include <QMouseEvent>
#include <QString>
#include <QIcon>
#include <QSize>

/**
 * NodeToolButton - Custom tool button for node palette
 * 
 * Represents a specific node type that can be created in the scene.
 * Provides consistent styling and click handling for the node palette.
 */
class NodeToolButton : public QToolButton
{
    Q_OBJECT

public:
    explicit NodeToolButton(const QString& type, const QIcon& icon, QWidget* parent = nullptr);
    
    QString nodeType() const { return m_nodeType; }

signals:
    void nodeClicked(const QString& nodeType);

protected:
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void enterEvent(QEvent* event) override;
    void leaveEvent(QEvent* event) override;

private:
    QString m_nodeType;
    QPoint m_dragStartPosition;
    
    void updateButtonStyle();
    void setHoverStyle(bool hovered);
    void startDrag();
};

// ====================================
// FILE: scene.h
// LAST MODIFIED: 2025-07-14 03:03:20
// ====================================

#pragma once

#include <QGraphicsScene>
#include <QGraphicsSceneMouseEvent>
#include <QHash>
#include <QUuid>
#include "graph_observer.h"

class Node;
class Edge;
class Socket;
class QGraphicsPathItem;

/**
 * Scene - QElectroTech-style typed scene management
 * 
 * Uses QHash collections for O(1) UUID lookups
 * Never use generic items() - always use typed collections
 * Follows QElectroTech/Fritzing patterns for professional node editors
 */
class Scene : public QGraphicsScene, public GraphSubject
{
    Q_OBJECT

signals:
    void sceneChanged();

public:
    explicit Scene(QObject* parent = nullptr);
    
    // Typed item management - QElectroTech style
    void addNode(Node* node);
    void addEdge(Edge* edge);
    void addSocket(Socket* socket);  // Deprecated - sockets managed by nodes
    
    void removeNode(const QUuid& nodeId);
    void removeEdge(const QUuid& edgeId);
    
    // Fast UUID-based lookups O(1) - no searching, no casting
    Node* getNode(const QUuid& nodeId) const;
    Edge* getEdge(const QUuid& edgeId) const;
    
    // Type-safe iteration - never need qgraphicsitem_cast
    const QHash<QUuid, Node*>& getNodes() const { return m_nodes; }
    const QHash<QUuid, Edge*>& getEdges() const { return m_edges; }
    // Clean design: sockets accessed via nodes, not scene
    
    // Deletion methods - maintain integrity
    void deleteNode(const QUuid& nodeId);
    void deleteEdge(const QUuid& edgeId);
    void deleteSelected();  // Delete all selected items
    
    // Clear both graphics items AND registries - prevents dangling pointers
    void clearGraph();
    
    // PHASE 1.2: Safe shutdown preparation
    void prepareForShutdown();
    bool isShutdownInProgress() const { return m_shutdownInProgress; }
    
    // Public observer notifications (for Node movement)
    using GraphSubject::notifyNodeMoved;
    
    // Ghost edge for visual connection feedback (right-click and drag)
    void startGhostEdge(Socket* fromSocket, const QPointF& startPos);
    void updateGhostEdge(const QPointF& currentPos);
    void finishGhostEdge(Socket* toSocket = nullptr);
    void cancelGhostEdge();
    bool ghostEdgeActive() const { return m_ghostEdgeActive; }
    
    // Critical destruction safety flag
    static bool isClearing() { return s_clearingGraph; }

protected:
    // Mouse event handling for ghost edge interactions
    void mouseMoveEvent(QGraphicsSceneMouseEvent* event) override;
    void mouseReleaseEvent(QGraphicsSceneMouseEvent* event) override;

private:
    // QElectroTech-style typed collections with UUID keys
    QHash<QUuid, Node*> m_nodes;
    QHash<QUuid, Edge*> m_edges;
    QHash<QUuid, Socket*> m_sockets;  // Deprecated - kept for compatibility
    
    // Ghost edge for visual feedback during right-click connection creation
    QGraphicsPathItem* m_ghostEdge;
    Socket* m_ghostFromSocket;
    bool m_ghostEdgeActive;
    
    // Helper method for ghost edge styling
    QPen ghostPen() const;
    void resetAllSocketStates();
    
    // Static flag to prevent socket cleanup during clearGraph
    static bool s_clearingGraph;
    
    // Shutdown coordination flag
    bool m_shutdownInProgress;
};

// ====================================
// FILE: socket.h
// LAST MODIFIED: 2025-07-14 03:03:20
// ====================================

#pragma once

#include <QGraphicsItem>
#include <QPainter>
#include <QStyleOptionGraphicsItem>
#include <QWidget>
#include <QGraphicsSceneMouseEvent>
#include <QUuid>
#include <QPointF>
#include <QString>
#include <QColor>
#include <QRectF>
#include <QSet>
#include <libxml/tree.h>

class Node;
class Edge;

/**
 * Socket - QGraphicsItem connection point on a node
 * 
 * Core principles:
 * - QGraphicsItem child of Node QGraphicsItem
 * - Self-serializing like its parent node
 * - Handles mouse events for connection creation
 * - Position managed by Qt parent-child system
 * - Index-based identification within parent node
 */
class Socket : public QGraphicsItem
{
public:
    enum Role {
        Input,
        Output
    };
    
    enum VisualState {
        Normal,         // Default state
        Hovered,        // Mouse hovering over socket
        ValidTarget,    // Valid target for ghost edge connection
        InvalidTarget,  // Invalid target for ghost edge connection
        Connected       // Socket has active connections
    };
    
    // Helper for debugging
    static const char* roleToString(Role role) {
        switch (role) {
            case Input: return "INPUT";
            case Output: return "OUTPUT";
            default: return "UNKNOWN";
        }
    }
    
    Socket(Role role, Node* parentNode, int index);
    
    // Core identity - NO UUID, just index within parent node
    int getIndex() const { return m_index; }
    Role getRole() const { return m_role; }
    // Access parent node via Qt's system  
    Node* getParentNode() const;
    
    // Self-serialization interface
    xmlNodePtr write(xmlDocPtr doc, xmlNodePtr repr = nullptr) const;
    void read(xmlNodePtr node);
    
    // QGraphicsItem interface
    QRectF boundingRect() const override;
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) override;
    
    // Mouse events for connection creation
    void mousePressEvent(QGraphicsSceneMouseEvent *event) override;
    void mouseReleaseEvent(QGraphicsSceneMouseEvent *event) override;
    void hoverEnterEvent(QGraphicsSceneHoverEvent *event) override;
    void hoverLeaveEvent(QGraphicsSceneHoverEvent *event) override;
    
    // Connection state - supports multiple edges per socket
    bool isConnected() const { return !m_connectedEdges.isEmpty(); }
    void addConnectedEdge(Edge* edge);
    void removeConnectedEdge(Edge* edge);
    void clearAllConnections(); // Emergency clear for safe destruction
    const QSet<Edge*>& getConnectedEdges() const { return m_connectedEdges; }
    
    // Legacy single-edge interface for compatibility
    void setConnectedEdge(Edge* edge); // Deprecated - use addConnectedEdge
    Edge* getConnectedEdge() const;    // Returns first connected edge or nullptr
    
    // Visual feedback state for ghost edge interactions
    void setVisualState(VisualState state);
    VisualState getVisualState() const { return m_visualState; }
    
    // Socket positioning (automatic based on index and role)
    void updatePosition();

private:
    Role m_role;
    int m_index;                 // Socket index within parent node (0, 1, 2...)
    QSet<Edge*> m_connectedEdges; // All connected edges - supports multiple connections
    qreal m_radius;
    bool m_hovered;
    VisualState m_visualState;   // Current visual feedback state
    
    // Performance optimization: cache index string (created once, not every frame)
    mutable QString m_cachedIndexString;
    
    // Positioning helpers
    QPointF calculatePosition() const;
};

// ====================================
// FILE: tst_main.h
// LAST MODIFIED: 2025-07-14 08:28:45
// ====================================

#pragma once

#include <QObject>
#include <QtTest>
#include <QApplication>
#include <QElapsedTimer>
#include <libxml/tree.h>
#include "scene.h"
#include "graph_factory.h"
#include "node.h"
#include "edge.h"
#include "node_registry.h"
#include "xml_live_sync.h"

/**
 * tst_Main - Main Qt Test suite that grows with the application
 * 
 * Single comprehensive test suite for all application functionality.
 * Will expand as we add more features to the NodeGraph application.
 */
class tst_Main : public QObject
{
    Q_OBJECT

private slots:
    void initTestCase();
    void cleanupTestCase();
    void init();
    void cleanup();

    // Core functionality tests
    void testCreateNode();
    void testFactoryNodeCreation();
    void testXmlLoadSave();
    void testCompleteWorkflow();
    
    // XML Performance test - data-driven
    void testXmlPerformance();
    
    // XML Dynamic updates
    void testNodePositionToXml();
    void testEdgeModificationToXml();
    
    // Built-in destruction safety tests
    void test_nodeDestroyedBeforeEdge();
    void test_edgeDestroyedBeforeNode();
    void test_massDestructionStress();
    
    // Live XML synchronization tests
    void test_liveXmlNodePositionSync();
    void test_liveXmlEdgeCreationSync();
    void test_liveXmlEdgeDeletionSync();
    void test_liveXmlFastSave();
    void test_liveXmlRebuildFromScene();

private:
    // Helper methods
    Node* createNode(const QString& type = "OUT");
    bool setupEnvironment();
    void cleanupEnvironment();
    bool validateSceneSetup();
    
    // Performance test helpers
    void performXmlLoadTest(const QString& filename, const QString& testName);
    qint64 measureXmlLoadTime(const QString& filename);
    void validateLoadedGraph(int expectedNodes, int expectedEdges);
    
    // Test infrastructure
    QApplication* m_app;
    Scene* m_testScene;
    GraphFactory* m_factory;
    xmlDocPtr m_xmlDoc;
};

// ====================================
// FILE: tst_roundtrip.h
// LAST MODIFIED: 2025-07-08 08:18:01
// ====================================

#pragma once

#include <QObject>
#include <QtTest>
#include <QTemporaryDir>
#include <QFileInfo>
#include "scene.h"
#include "graph_factory.h"
#include "node_registry.h"

/**
 * tst_RoundTrip - Save → Load → Save comparison tests
 * 
 * Validates that save/load cycles preserve graph integrity.
 * Critical for verifying our Simple Fix ownership solution.
 */
class tst_RoundTrip : public QObject
{
    Q_OBJECT

private slots:
    void initTestCase();
    void cleanupTestCase();
    void init();
    void cleanup();

    // Core round-trip tests
    void saveLoadSave_identical();
    void saveLoadSave_emptyGraph();
    void saveLoadSave_singleNode();
    void saveLoadSave_simpleConnection();
    void saveLoadSave_complexGraph();
    
    // Edge case tests
    void saveLoadSave_disconnectedNodes();
    void saveLoadSave_multipleEdges();
    void saveLoadSave_variableSocketCounts();

private:
    // Helper methods
    void makeSampleGraph(Scene* scene, GraphFactory* factory);
    bool sameXml(const QString& file1, const QString& file2);
    bool saveGraph(Scene* scene, const QString& filename);
    bool loadGraph(Scene* scene, GraphFactory* factory, const QString& filename);
    
    // Test infrastructure
    QTemporaryDir* m_tempDir;
    xmlDocPtr m_xmlDoc;
};

// ====================================
// FILE: view.h
// LAST MODIFIED: 2025-07-14 09:11:28
// ====================================

#pragma once

#include <QGraphicsView>
#include <QMouseEvent>
#include <QWheelEvent>
#include <QScrollBar>
#include <QDragEnterEvent>
#include <QDropEvent>

class Scene;

/**
 * View - Enhanced graphics view for node editor
 * 
 * Features:
 * - Smooth zoom with limits
 * - Middle-click pan
 * - Keyboard navigation
 * - View reset and fit controls
 * - Grid background
 */
class View : public QGraphicsView
{
    Q_OBJECT

public:
    explicit View(Scene* scene, QWidget* parent = nullptr);
    
    // View control methods
    void zoomIn();
    void zoomOut();
    void zoomReset();
    void zoomToFit();
    void centerView();
    
    // Zoom level management
    qreal getZoomLevel() const { return m_zoomLevel; }
    void setZoomLevel(qreal zoom);

signals:
    void zoomChanged(qreal zoomLevel);
    void viewChanged(const QRectF& viewRect);
    void nodeDropped(const QString& nodeType, const QPointF& scenePos);

protected:
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void wheelEvent(QWheelEvent* event) override;
    void keyPressEvent(QKeyEvent* event) override;
    void drawBackground(QPainter* painter, const QRectF& rect) override;
    void scrollContentsBy(int dx, int dy) override;
    
    // Drag and drop support
    void dragEnterEvent(QDragEnterEvent* event) override;
    void dragMoveEvent(QDragMoveEvent* event) override;
    void dropEvent(QDropEvent* event) override;

private:
    Scene* m_scene;
    
    // Zoom management
    qreal m_zoomLevel;
    static constexpr qreal MIN_ZOOM = 0.1;
    static constexpr qreal MAX_ZOOM = 5.0;
    static constexpr qreal ZOOM_FACTOR = 1.2;
    
    // Pan management
    bool m_middleClickPanning;
    QPoint m_lastPanPoint;
    
    // Grid settings
    bool m_showGrid;
    qreal m_gridSize;
    
    void updateZoom(qreal factor, const QPointF& center = QPointF());
    void drawGrid(QPainter* painter, const QRectF& rect);
};

// ====================================
// FILE: window.h
// LAST MODIFIED: 2025-07-14 09:14:22
// ====================================

#pragma once

#include <QMainWindow>
#include <QString>
#include <QToolBar>
#include <QAction>
#include <QDockWidget>
#include <QLabel>
#include <QStatusBar>
#include <QMenuBar>
#include <QProgressBar>
#include <QSpinBox>
#include <QComboBox>
#include <libxml/tree.h>

class View;
class Scene;
class GraphFactory;
class XmlAutosaveObserver;
class NodePaletteBar;

/**
 * Window - Enhanced main window for self-serializing node editor
 * 
 * Features:
 * - Professional UI with dock widgets and status bar
 * - Node palette with drag-and-drop functionality
 * - Multi-section status bar with graph statistics
 * - Menu system with proper actions
 * - Integration with self-serializing architecture
 */
class Window : public QMainWindow
{
public:
    explicit Window(QWidget* parent = nullptr);
    ~Window();
    
    // Access to scene for testing
    Scene* getScene() const { return m_scene; }
    
    // Update status bar with current graph information
    void updateStatusBar();
    
    // Create node at specific position (for drag-and-drop)
    void createNodeAtPosition(const QString& nodeType, const QPointF& scenePos);

protected:
    // PHASE 3: Safe shutdown coordination
    void closeEvent(QCloseEvent* event) override;
    
public slots:
    // Scene event handlers
    void onSceneChanged();
    void onSelectionChanged();
    
    // Basic XML saving functionality
    bool saveGraph(const QString& filename);
    bool loadGraph(const QString& filename);
    
    // File management
    void setCurrentFile(const QString& filename);
    QString getCurrentFile() const { return m_currentFile; }
    
    // Interactive node creation
    void createInputNode();
    void createOutputNode();
    void createProcessorNode();
    
private slots:
    // Menu actions
    void newFile();
    void openFile();
    void saveFile();
    void saveAsFile();
    void exportGraph();
    void showAbout();
    
    // View actions
    void zoomIn();
    void zoomOut();
    void zoomFit();
    void zoomReset();
    
    // Selection info update
    void updateSelectionInfo();
    
protected:
    // Handle keyboard shortcuts
    void keyPressEvent(QKeyEvent* event) override;

private:
    Scene* m_scene;
    View* m_view;
    GraphFactory* m_factory;
    xmlDocPtr m_xmlDocument;
    XmlAutosaveObserver* m_autosaveObserver;
    
    // UI elements
    QAction* m_addInputAction;
    QAction* m_addOutputAction;
    QAction* m_addProcessorAction;
    
    // Professional node palette system
    QDockWidget* m_nodePaletteDock;
    NodePaletteBar* m_nodePalette;
    
    // Status bar components
    QLabel* m_fileInfoLabel;      // Current file info
    QLabel* m_graphStatsLabel;    // Node/edge count
    QLabel* m_selectionLabel;     // Selection information
    QLabel* m_positionLabel;      // Mouse position
    QLabel* m_zoomLabel;          // Current zoom level
    QProgressBar* m_operationProgress; // For long operations
    
    // Menu system
    QMenu* m_fileMenu;
    QMenu* m_editMenu;
    QMenu* m_viewMenu;
    QMenu* m_toolsMenu;
    QMenu* m_helpMenu;
    
    // File management
    QString m_currentFile;
    
    // Setup methods
    void setupUI();
    void setupMenus();
    void setupActions();
    void setupStatusBar();
    void setupDockWidgets();
    
    // Menu creation helpers
    void createFileMenu();
    void createEditMenu();
    void createViewMenu();
    void createToolsMenu();
    void createHelpMenu();
    
    // Status bar helpers
    void createStatusBarWidgets();
    void connectStatusBarSignals();
};

// ====================================
// FILE: xml_autosave_observer.h
// LAST MODIFIED: 2025-07-07 12:06:19
// ====================================

#pragma once

#include "graph_observer.h"
#include <QString>
#include <QTimer>

class Scene;

/**
 * XmlAutosaveObserver - Automatically saves graph changes to XML
 * 
 * Listens to all graph mutations and maintains an up-to-date XML file.
 * Uses delayed saving to avoid excessive I/O during rapid changes.
 */
class XmlAutosaveObserver : public GraphObserver
{
public:
    explicit XmlAutosaveObserver(Scene* scene, const QString& filename = "autosave.xml");
    ~XmlAutosaveObserver();
    
    // Configure autosave behavior
    void setFilename(const QString& filename);
    void setDelay(int milliseconds);  // Delay before saving after last change
    void setEnabled(bool enabled);
    
    // Force immediate save
    void saveNow();
    
    // GraphObserver interface
    void onNodeAdded(const Node& node) override;
    void onNodeRemoved(const QUuid& nodeId) override;
    void onNodeMoved(const QUuid& nodeId, QPointF oldPos, QPointF newPos) override;
    void onEdgeAdded(const Edge& edge) override;
    void onEdgeRemoved(const QUuid& edgeId) override;
    void onGraphCleared() override;
    
private:
    Scene* m_scene;
    QString m_filename;
    QTimer* m_saveTimer;
    bool m_enabled;
    bool m_pendingChanges;
    
    void scheduleAutosave();
    void performAutosave();
    QString generateFullXml() const;
};

// ====================================
// FILE: xml_live_sync.h
// LAST MODIFIED: 2025-07-14 08:28:45
// ====================================

#pragma once

#include "graph_observer.h"
#include <libxml/tree.h>
#include <QHash>
#include <QUuid>
#include <QString>
#include <QPointF>

class Scene;
class Node;
class Edge;

/**
 * XmlLiveSync - Real-time XML Document Synchronization
 * 
 * Maintains perfect synchronization between Scene state and XML document.
 * Unlike XmlAutosaveObserver (which saves to files), this keeps the 
 * in-memory XML document live and current for:
 * 
 * - Fast file saves (no need to rebuild XML)
 * - Undo/Redo system foundation  
 * - State consistency across sessions
 * - Real-time collaboration (future)
 * 
 * Inkscape-style architecture: XML is the source of truth.
 */
class XmlLiveSync : public GraphObserver
{
public:
    explicit XmlLiveSync(Scene* scene, xmlDocPtr xmlDocument);
    ~XmlLiveSync();
    
    // Enable/disable live sync
    void setEnabled(bool enabled);
    bool isEnabled() const { return m_enabled; }
    
    // Force full XML rebuild (for initialization or recovery)
    void rebuildXmlFromScene();
    
    // Get current XML document (always up-to-date)
    xmlDocPtr getXmlDocument() const { return m_xmlDocument; }
    
    // Fast save to file (XML already current)
    bool saveToFile(const QString& filename);
    
    // GraphObserver interface - real-time XML updates
    void onNodeAdded(const Node& node) override;
    void onNodeRemoved(const QUuid& nodeId) override;
    void onNodeMoved(const QUuid& nodeId, QPointF oldPos, QPointF newPos) override;
    void onEdgeAdded(const Edge& edge) override;
    void onEdgeRemoved(const QUuid& edgeId) override;
    void onGraphCleared() override;

private:
    Scene* m_scene;
    xmlDocPtr m_xmlDocument;
    bool m_enabled;
    
    // Cache XML nodes for fast updates
    QHash<QUuid, xmlNodePtr> m_nodeXmlCache;
    QHash<QUuid, xmlNodePtr> m_edgeXmlCache;
    
    // XML structure helpers
    xmlNodePtr getOrCreateNodesElement();
    xmlNodePtr getOrCreateEdgesElement();
    xmlNodePtr findNodeXml(const QUuid& nodeId);
    xmlNodePtr findEdgeXml(const QUuid& edgeId);
    
    // Incremental XML updates
    void updateNodePositionInXml(const QUuid& nodeId, const QPointF& newPos);
    void addNodeToXml(const Node& node);
    void removeNodeFromXml(const QUuid& nodeId);
    void addEdgeToXml(const Edge& edge);
    void removeEdgeFromXml(const QUuid& edgeId);
    
    // XML utilities
    void setXmlProperty(xmlNodePtr node, const QString& name, const QString& value);
    QString getXmlProperty(xmlNodePtr node, const QString& name);
};

// ====================================
// FILE: edge.cpp
// LAST MODIFIED: 2025-07-14 03:25:14
// ====================================

#include "edge.h"
#include "socket.h"
#include "node.h"
#include "scene.h"
#include <QPainter>
#include <QStyleOptionGraphicsItem>
#include <QWidget>
#include <QDebug>
#include <libxml/tree.h>
#include <cmath>

Edge::Edge(const QUuid& id, const QUuid& fromSocketId, const QUuid& toSocketId)
    : m_id(id)
    , m_fromNodeId()
    , m_toNodeId()
    , m_fromNodeUuid()
    , m_toNodeUuid()
    , m_fromSocketIndex(-1)
    , m_toSocketIndex(-1)
    , m_fromSocket(nullptr)
    , m_toSocket(nullptr)
    , m_fromNode(nullptr)
    , m_toNode(nullptr)
    , m_fromNodeValid(false)
    , m_toNodeValid(false)
    , m_hovered(false)
    #ifdef QT_DEBUG
    , m_shapeCallCount(0)
    #endif
{
    Q_UNUSED(fromSocketId)  // Legacy parameter, not used in clean design
    Q_UNUSED(toSocketId)    // Legacy parameter, not used in clean design
    setFlag(QGraphicsItem::ItemIsSelectable, true);
    setAcceptHoverEvents(true);  // Enable hover events for better interaction
    
    // Ensure edges are above nodes in z-order for easier selection
    setZValue(1);  // Nodes default to z=0, edges at z=1
    
    // Edge creation - minimal logging
}

Edge::~Edge()
{
    // PHASE 1.1: Remove socket cleanup entirely from destructor
    // Socket connections will be cleaned up by prepareForShutdown() before destruction
    
    // SAFETY: Use validity flags to prevent use-after-free
    if (m_fromNodeValid && m_fromNode) {
        m_fromNode->unregisterEdge(this);
    }
    if (m_toNodeValid && m_toNode) {
        m_toNode->unregisterEdge(this);
    }
    
    // PHASE 1: No socket cleanup in destructor - prevents use-after-free
}

void Edge::onNodeDestroying(const Node* node)
{
    // Built-in destruction safety - mark which node is being destroyed
    if (node == m_fromNode) {
        m_fromNodeValid = false;
        qDebug() << "SAFETY: Edge" << m_id.toString(QUuid::WithoutBraces).left(8) << "- fromNode destroying";
    }
    if (node == m_toNode) {
        m_toNodeValid = false;
        qDebug() << "SAFETY: Edge" << m_id.toString(QUuid::WithoutBraces).left(8) << "- toNode destroying";
    }
}

QRectF Edge::boundingRect() const
{
    return m_boundingRect;
}

void Edge::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
    Q_UNUSED(option)
    Q_UNUSED(widget)
    
    // Clean edge painting - strokes only, no fills
    painter->setRenderHint(QPainter::Antialiasing);
    painter->setBrush(Qt::NoBrush);  // Explicitly no fill
    
    // Simple edge styling
    QPen edgePen;
    if (isSelected()) {
        edgePen = QPen(QColor(255, 100, 0), 3);  // Orange selection
    } else if (m_hovered) {
        edgePen = QPen(QColor(100, 150, 255), 2);  // Blue hover
    } else {
        edgePen = QPen(QColor(80, 80, 80), 1);  // Gray normal
    }
    
    // Draw edge path - stroke only
    painter->setPen(edgePen);
    painter->drawPath(m_path);
}

QPainterPath Edge::shape() const
{
    // Create a much wider path for easier selection - very generous selection area
    QPainterPathStroker stroker;
    stroker.setWidth(20);  // Very wide selection area for easy clicking
    stroker.setCapStyle(Qt::RoundCap);
    stroker.setJoinStyle(Qt::RoundJoin);
    QPainterPath selectionPath = stroker.createStroke(m_path);
    
    #ifdef QT_DEBUG
    // Debug: Log when shape is queried (indicates potential interaction)
    // Per-edge counter avoids thread safety issues with global static
    ++m_shapeCallCount;
    if (m_shapeCallCount % 100 == 0) {  // Throttled logging to avoid spam
        qDebug() << "Edge" << m_id.toString(QUuid::WithoutBraces).left(8) 
                 << "shape() called" << m_shapeCallCount << "times";
    }
    #endif
    
    return selectionPath;
}

// Removed manual setSelected - using Qt's selection system

QVariant Edge::itemChange(GraphicsItemChange change, const QVariant &value)
{
    if (change == ItemSelectedHasChanged) {
        // Selection tracking logging - what has been selected
        bool isNowSelected = value.toBool();
        qDebug() << "Edge" << m_id.toString(QUuid::WithoutBraces).left(8) 
                 << (isNowSelected ? "SELECT" : "DESELECT");
        
        // Trigger visual update when selection changes
        update();
    }
    return QGraphicsItem::itemChange(change, value);
}

void Edge::mousePressEvent(QGraphicsSceneMouseEvent *event)
{
    QGraphicsItem::mousePressEvent(event);
}

void Edge::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)
{
    QGraphicsItem::mouseReleaseEvent(event);
}

void Edge::hoverEnterEvent(QGraphicsSceneHoverEvent *event)
{
    Q_UNUSED(event)
    m_hovered = true;
    update();  // Redraw to show hover effect
    QGraphicsItem::hoverEnterEvent(event);
}

void Edge::hoverLeaveEvent(QGraphicsSceneHoverEvent *event)
{
    Q_UNUSED(event)
    m_hovered = false;
    update();  // Redraw to remove hover effect
    QGraphicsItem::hoverLeaveEvent(event);
}

void Edge::updatePath()
{
    // Simple and clean: use direct socket pointers
    if (!m_fromSocket || !m_toSocket) {
        // Edge not resolved yet - notify BSP cache before clearing
        prepareGeometryChange();
        m_path = QPainterPath();
        m_boundingRect = QRectF();
        return;
    }
    
    QPointF start = m_fromSocket->scenePos();
    QPointF end = m_toSocket->scenePos();
    
    buildPath(start, end);
}



void Edge::buildPath(const QPointF& start, const QPointF& end)
{
    // Validate input points
    if (start.isNull() || end.isNull() || !qIsFinite(start.x()) || !qIsFinite(start.y()) || 
        !qIsFinite(end.x()) || !qIsFinite(end.y())) {
        // Notify BSP cache before clearing
        prepareGeometryChange();
        m_path = QPainterPath();
        m_boundingRect = QRectF();
        return;
    }
    
    // Clear and rebuild path safely
    m_path.clear();
    m_path.moveTo(start);
    
    // Create a curved connection with bounds checking
    qreal dx = end.x() - start.x();
    qreal controlOffset = qMin(qAbs(dx) * 0.5, 100.0); // Limit control point distance
    
    QPointF control1 = start + QPointF(controlOffset, 0);
    QPointF control2 = end - QPointF(controlOffset, 0);
    m_path.cubicTo(control1, control2, end);
    
    // Notify Qt's BSP cache before changing bounding rectangle
    prepareGeometryChange();
    
    // Update bounding rectangle with validation
    QRectF pathBounds = m_path.boundingRect();
    if (pathBounds.isValid()) {
        // Inflate by strokeWidth/2 = 10 to match stroker.setWidth(20)
        m_boundingRect = pathBounds.adjusted(-10, -10, 10, 10);
    } else {
        // Inflate by strokeWidth/2 = 10 to match stroker.setWidth(20)
        m_boundingRect = QRectF(start, end).normalized().adjusted(-10, -10, 10, 10);
    }
}

xmlNodePtr Edge::write(xmlDocPtr doc, xmlNodePtr repr) const
{
    xmlNodePtr node = xmlNewNode(nullptr, BAD_CAST "edge");
    
    // Core attributes - clean design uses node+index format
    xmlSetProp(node, BAD_CAST "id", BAD_CAST m_id.toString(QUuid::WithoutBraces).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "fromNode", BAD_CAST m_fromNodeId.toUtf8().constData());
    xmlSetProp(node, BAD_CAST "toNode", BAD_CAST m_toNodeId.toUtf8().constData());
    xmlSetProp(node, BAD_CAST "fromSocketIndex", BAD_CAST QString::number(m_fromSocketIndex).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "toSocketIndex", BAD_CAST QString::number(m_toSocketIndex).toUtf8().constData());
    
    if (repr) {
        xmlAddChild(repr, node);
    } else {
        xmlDocSetRootElement(doc, node);
    }
    
    return node;
}

void Edge::read(xmlNodePtr node)
{
    if (!node) return;
    
    // Read UUID
    xmlChar* idStr = xmlGetProp(node, BAD_CAST "id");
    if (idStr) {
        m_id = QUuid(QString::fromUtf8((char*)idStr));
        xmlFree(idStr);
    }
    
    // Read node+index references - store for later resolution
    // Support both formats: new (fromNode/toNode) and legacy (from/to)
    xmlChar* fromNodeStr = xmlGetProp(node, BAD_CAST "fromNode");
    if (!fromNodeStr) fromNodeStr = xmlGetProp(node, BAD_CAST "from");
    
    xmlChar* toNodeStr = xmlGetProp(node, BAD_CAST "toNode");
    if (!toNodeStr) toNodeStr = xmlGetProp(node, BAD_CAST "to");
    
    xmlChar* fromIndexStr = xmlGetProp(node, BAD_CAST "fromSocketIndex");
    if (!fromIndexStr) fromIndexStr = xmlGetProp(node, BAD_CAST "from-socket");
    
    xmlChar* toIndexStr = xmlGetProp(node, BAD_CAST "toSocketIndex");
    if (!toIndexStr) toIndexStr = xmlGetProp(node, BAD_CAST "to-socket");
    
    if (!fromNodeStr || !toNodeStr || !fromIndexStr || !toIndexStr) {
        qCritical() << "Edge::read() - Missing required node+index attributes";
        if (fromNodeStr) xmlFree(fromNodeStr);
        if (toNodeStr) xmlFree(toNodeStr);
        if (fromIndexStr) xmlFree(fromIndexStr);
        if (toIndexStr) xmlFree(toIndexStr);
        return;
    }
    
    // Store data for later resolution - don't try to resolve now
    m_fromNodeId = QString::fromUtf8((char*)fromNodeStr);
    m_toNodeId = QString::fromUtf8((char*)toNodeStr);
    m_fromSocketIndex = QString::fromUtf8((char*)fromIndexStr).toInt();
    m_toSocketIndex = QString::fromUtf8((char*)toIndexStr).toInt();
    
    // Performance optimization: cache UUIDs for fast comparison
    m_fromNodeUuid = QUuid(m_fromNodeId);
    m_toNodeUuid = QUuid(m_toNodeId);
    
    qDebug() << "Edge: Stored connection data fromNode" << m_fromNodeId.left(8) 
             << "socket" << m_fromSocketIndex << "-> toNode" << m_toNodeId.left(8) 
             << "socket" << m_toSocketIndex;
    
    xmlFree(fromNodeStr);
    xmlFree(toNodeStr);
    xmlFree(fromIndexStr);
    xmlFree(toIndexStr);
    
    // DON'T call updatePath() here - scene may not be ready
    // Socket resolution will happen later via resolveConnections()
}

bool Edge::isConnectedToNode(const QString& nodeId) const
{
    return (m_fromNodeId == nodeId || m_toNodeId == nodeId);
}

bool Edge::isConnectedToNode(const QUuid& nodeId) const
{
    // Optimized: Fast UUID comparison (no string conversion)
    return (m_fromNodeUuid == nodeId || m_toNodeUuid == nodeId);
}

bool Edge::resolveConnections(Scene* scene)
{
    if (!scene) {
        qCritical() << "Edge::resolveConnections - null scene";
        return false;
    }
    
    if (m_fromNodeId.isEmpty() || m_toNodeId.isEmpty()) {
        qCritical() << "Edge::resolveConnections - empty node IDs";
        return false;
    }
    
    // Find nodes by UUID
    Node* fromNode = scene->getNode(QUuid(m_fromNodeId));
    Node* toNode = scene->getNode(QUuid(m_toNodeId));
    
    if (!fromNode) {
        qCritical() << "Edge::resolveConnections - fromNode not found:" << m_fromNodeId.left(8);
        return false;
    }
    if (!toNode) {
        qCritical() << "Edge::resolveConnections - toNode not found:" << m_toNodeId.left(8);
        return false;
    }
    
    // Find sockets by index
    Socket* fromSocket = fromNode->getSocketByIndex(m_fromSocketIndex);
    Socket* toSocket = toNode->getSocketByIndex(m_toSocketIndex);
    
    qDebug() << "Edge resolve: fromNode" << m_fromNodeId.left(8) << "type:" << fromNode->getNodeType()
             << "socket" << m_fromSocketIndex << "role:" << (fromSocket ? Socket::roleToString(fromSocket->getRole()) : "NULL");
    qDebug() << "Edge resolve: toNode" << m_toNodeId.left(8) << "type:" << toNode->getNodeType()
             << "socket" << m_toSocketIndex << "role:" << (toSocket ? Socket::roleToString(toSocket->getRole()) : "NULL");
    
    if (!fromSocket) {
        qCritical() << "Edge::resolveConnections - fromSocket index" << m_fromSocketIndex 
                   << "not found in node" << m_fromNodeId.left(8) 
                   << "with" << fromNode->getSocketCount() << "sockets";
        return false;
    }
    if (!toSocket) {
        qCritical() << "Edge::resolveConnections - toSocket index" << m_toSocketIndex 
                   << "not found in node" << m_toNodeId.left(8) 
                   << "with" << toNode->getSocketCount() << "sockets";
        return false;
    }
    
    // Validate connection rules
    if (fromSocket->getRole() != Socket::Output) {
        qCritical() << "ERROR: Edge::resolveConnections - fromSocket must be Output role"
                   << "- fromNode:" << m_fromNodeId.left(8) << "socket" << m_fromSocketIndex 
                   << "has role:" << Socket::roleToString(fromSocket->getRole());
        return false;
    }
    if (toSocket->getRole() != Socket::Input) {
        qCritical() << "ERROR: Edge::resolveConnections - toSocket must be Input role"
                   << "- toNode:" << m_toNodeId.left(8) << "socket" << m_toSocketIndex 
                   << "has role:" << Socket::roleToString(toSocket->getRole());
        return false;
    }
    
    // Store socket references directly - NO UUIDs
    m_fromSocket = fromSocket;
    m_toSocket = toSocket;
    
    // Cache node pointers for safe destruction with validity flags
    Q_ASSERT(fromNode && toNode); // Future-risk check: ensure nodes are valid
    m_fromNode = fromNode;
    m_toNode = toNode;
    m_fromNodeValid = true;
    m_toNodeValid = true;
    
    // PATCH: Scene consistency check - prevent cross-scene connections
    if (fromNode->scene() != toNode->scene()) {
        qCritical() << "ERROR: Edge::resolveConnections - cross-scene edge detected"
                   << "fromNode scene:" << fromNode->scene() << "toNode scene:" << toNode->scene();
        return false;
    }
    
    // PERFORMANCE OPTIMIZATION: Register this edge with both connected nodes
    // This enables O(degree) edge updates instead of O(totalEdges)
    fromNode->registerEdge(this);
    toNode->registerEdge(this);
    
    // PATCH: Use new multi-edge socket system
    fromSocket->addConnectedEdge(this);
    toSocket->addConnectedEdge(this);
    
    qDebug() << "EDGE" << m_id.toString(QUuid::WithoutBraces).left(8) << ": Resolved" 
             << m_fromSocketIndex << "→" << m_toSocketIndex
             << "(from:" << fromSocket->getConnectedEdges().size() 
             << "to:" << toSocket->getConnectedEdges().size() << "connections)";
    
    updatePath();
    return true;
}

void Edge::setConnectionData(const QString& fromNodeId, const QString& toNodeId, 
                            int fromSocketIndex, int toSocketIndex)
{
    m_fromNodeId = fromNodeId;
    m_toNodeId = toNodeId;
    m_fromSocketIndex = fromSocketIndex;
    m_toSocketIndex = toSocketIndex;
    
    // Performance optimization: cache UUIDs for fast comparison
    m_fromNodeUuid = QUuid(fromNodeId);
    m_toNodeUuid = QUuid(toNodeId);
    
    qDebug() << "Edge: Set connection data" << fromNodeId.left(8) 
             << "socket" << fromSocketIndex << "-> " << toNodeId.left(8) 
             << "socket" << toSocketIndex;
}

void Edge::setResolvedSockets(Socket* fromSocket, Socket* toSocket)
{
    if (!fromSocket || !toSocket) {
        qCritical() << "Edge::setResolvedSockets - null socket(s) provided";
        return;
    }
    
    // Validate socket roles
    if (fromSocket->getRole() != Socket::Output) {
        qCritical() << "Edge::setResolvedSockets - fromSocket must be Output role";
        return;
    }
    if (toSocket->getRole() != Socket::Input) {
        qCritical() << "Edge::setResolvedSockets - toSocket must be Input role";
        return;
    }
    
    m_fromSocket = fromSocket;
    m_toSocket = toSocket;
    
    // Cache node pointers for safe destruction with validity flags
    Node* fromNode = fromSocket->getParentNode();
    Node* toNode = toSocket->getParentNode();
    Q_ASSERT(fromNode && toNode); // Future-risk check: ensure nodes are valid
    m_fromNode = fromNode;
    m_toNode = toNode;
    m_fromNodeValid = true;
    m_toNodeValid = true;
    
    // PERFORMANCE OPTIMIZATION: Register this edge with both connected nodes
    // This enables O(degree) edge updates instead of O(totalEdges)
    if (fromNode) fromNode->registerEdge(this);
    if (toNode) toNode->registerEdge(this);
    
    qDebug() << "✓ Edge: Set resolved sockets directly (optimization)";
    updatePath();
}

// ====================================
// FILE: graph_factory.cpp
// LAST MODIFIED: 2025-07-12 02:11:27
// ====================================

#include "graph_factory.h"
#include "node.h"
#include "socket.h"
#include "edge.h"
#include "scene.h"
#include "node_registry.h"
#include "graph_observer.h"
#include <QDateTime>
#include <QDebug>

GraphFactory::GraphFactory(QGraphicsScene* scene, xmlDocPtr xmlDoc)
    : m_scene(scene)
    , m_xmlDocument(xmlDoc)
{
    qDebug() << "GraphFactory initialized with scene and XML document";
}

Node* GraphFactory::createNodeFromXml(xmlNodePtr xmlNode)
{
    if (!xmlNode) {
        qWarning() << "GraphFactory::createNodeFromXml - null XML node";
        return nullptr;
    }
    
    // Get node type from XML
    QString nodeType = getXmlProperty(xmlNode, "type");
    if (nodeType.isEmpty()) {
        qWarning() << "GraphFactory::createNodeFromXml - missing type attribute";
        return nullptr;
    }
    
    // Create node using registry
    Node* node = NodeRegistry::instance().createNode(nodeType);
    if (!node) {
        qCritical() << "GraphFactory::createNodeFromXml - failed to create node of type:" << nodeType;
        return nullptr;
    }
    
    // Attach observer before reading XML - contract requirement
    node->setObserver(this);
    
    // Let the node read its XML and configure itself
    node->read(xmlNode);
    
    // Verify observer is still attached
    if (!node->hasObserver()) {
        qCritical() << "GraphFactory::createNodeFromXml - observer detached during read";
        delete node;
        return nullptr;
    }
    
    // Add to typed scene collection
    if (Scene* typedScene = static_cast<Scene*>(m_scene)) {
        typedScene->addNode(node);
    } else {
        m_scene->addItem(node);
    }
    
    qDebug() << "GraphFactory: Created node from XML, type:" << nodeType 
             << "id:" << node->getId().toString(QUuid::WithoutBraces).left(8);
    
    return node;
}

Edge* GraphFactory::createEdgeFromXml(xmlNodePtr xmlEdge)
{
    if (!xmlEdge) {
        qWarning() << "GraphFactory::createEdgeFromXml - null XML edge";
        return nullptr;
    }
    
    // Get edge properties from XML (new node+index format)
    QString edgeId = getXmlProperty(xmlEdge, "id");
    QString fromNode = getXmlProperty(xmlEdge, "fromNode");
    QString toNode = getXmlProperty(xmlEdge, "toNode");
    QString fromIndex = getXmlProperty(xmlEdge, "fromSocketIndex");
    QString toIndex = getXmlProperty(xmlEdge, "toSocketIndex");
    
    if (edgeId.isEmpty() || fromNode.isEmpty() || toNode.isEmpty() || 
        fromIndex.isEmpty() || toIndex.isEmpty()) {
        qWarning() << "GraphFactory::createEdgeFromXml - missing required node+index attributes";
        qWarning() << "Required: id, fromNode, toNode, fromSocketIndex, toSocketIndex";
        return nullptr;
    }
    
    // Create edge object with temporary UUIDs (will be resolved in read())
    Edge* edge = new Edge(QUuid::fromString(edgeId), QUuid(), QUuid());
    
    // Let the edge read its XML and configure itself
    edge->read(xmlEdge);
    
    // Add to typed scene collection
    if (Scene* typedScene = static_cast<Scene*>(m_scene)) {
        typedScene->addEdge(edge);
    } else {
        m_scene->addItem(edge);
    }
    
    qDebug() << "GraphFactory: Created edge from XML, id:" << edgeId.left(8)
             << "from node:" << fromNode.left(8) << "socket" << fromIndex
             << "to node:" << toNode.left(8) << "socket" << toIndex;
    
    return edge;
}

Node* GraphFactory::createNode(const QString& nodeType, const QPointF& position, int inputs, int outputs)
{
    if (!m_xmlDocument) {
        qCritical() << "GraphFactory::createNode - no XML document";
        return nullptr;
    }
    
    // Create XML node first with socket configuration
    xmlNodePtr xmlNode = createXmlNode(nodeType, position, inputs, outputs);
    if (!xmlNode) {
        qCritical() << "GraphFactory::createNode - failed to create XML node";
        return nullptr;
    }
    
    // Create object from XML
    return createNodeFromXml(xmlNode);
}

Edge* GraphFactory::createEdge(Node* fromNode, int fromSocketIndex, Node* toNode, int toSocketIndex)
{
    if (!m_xmlDocument) {
        qCritical() << "GraphFactory::createEdge - no XML document";
        return nullptr;
    }
    
    if (!fromNode || !toNode) {
        qCritical() << "GraphFactory::createEdge - null node(s)";
        return nullptr;
    }
    
    // Get actual socket UUIDs by finding sockets by index
    Socket* fromSocket = fromNode->getSocketByIndex(fromSocketIndex);
    Socket* toSocket = toNode->getSocketByIndex(toSocketIndex);
    
    if (!fromSocket || !toSocket) {
        qCritical() << "GraphFactory::createEdge - invalid socket index(es)";
        return nullptr;
    }
    
    // Create XML edge using clean node+index format
    xmlNodePtr xmlEdge = createXmlEdgeNodeIndex(fromNode->getId(), fromSocketIndex, toNode->getId(), toSocketIndex);
    if (!xmlEdge) {
        qCritical() << "GraphFactory::createEdge - failed to create XML edge";
        return nullptr;
    }
    
    qDebug() << "GraphFactory: Created XML edge from node" << fromNode->getId().toString(QUuid::WithoutBraces).left(8) 
             << "socket" << fromSocketIndex << "to node" << toNode->getId().toString(QUuid::WithoutBraces).left(8)
             << "socket" << toSocketIndex;
    
    // Create object from XML
    return createEdgeFromXml(xmlEdge);
}

Edge* GraphFactory::connectSockets(Socket* fromSocket, Socket* toSocket)
{
    if (!fromSocket || !toSocket) {
        qCritical() << "GraphFactory::connectSockets - null socket(s)";
        return nullptr;
    }
    
    if (!m_xmlDocument) {
        qCritical() << "GraphFactory::connectSockets - no XML document";
        return nullptr;
    }
    
    // Get parent nodes for clean node+index approach
    Node* fromNode = fromSocket->getParentNode();
    Node* toNode = toSocket->getParentNode();
    
    if (!fromNode || !toNode) {
        qCritical() << "GraphFactory::connectSockets - sockets have no parent nodes";
        return nullptr;
    }
    
    // Optimized: Create edge directly in memory, serialize later
    QUuid edgeId = QUuid::createUuid();
    Edge* edge = new Edge(edgeId, QUuid(), QUuid());
    
    // Set connection data directly without XML round-trip
    edge->setConnectionData(fromNode->getId().toString(QUuid::WithoutBraces), toNode->getId().toString(QUuid::WithoutBraces),
                           fromSocket->getIndex(), toSocket->getIndex());
    
    // Resolve connections immediately since we have the sockets
    edge->setResolvedSockets(fromSocket, toSocket);
    
    // Add to scene
    if (Scene* typedScene = static_cast<Scene*>(m_scene)) {
        typedScene->addEdge(edge);
    } else {
        m_scene->addItem(edge);
    }
    
    // Create XML for persistence (lazy serialization)
    xmlNodePtr xmlEdge = createXmlEdgeNodeIndex(fromNode->getId(), fromSocket->getIndex(), 
                                                toNode->getId(), toSocket->getIndex());
    if (!xmlEdge) {
        qWarning() << "GraphFactory::connectSockets - XML serialization failed (edge still created)";
    }
    
    // Connect sockets atomically
    fromSocket->setConnectedEdge(edge);
    toSocket->setConnectedEdge(edge);
    
    qDebug() << "GraphFactory: Atomically connected sockets" 
             << "index" << fromSocket->getIndex()
             << "to index" << toSocket->getIndex();
    
    return edge;
}

bool GraphFactory::loadFromXmlFile(const QString& filePath)
{
    qDebug() << "=== GraphFactory: Loading from XML File ===" << filePath;
    
    // OPTIMIZATION: Enable batch mode to prevent observer storm during bulk loading
    GraphSubject::beginBatch();
    
    // Parse XML file
    xmlDocPtr doc = xmlParseFile(filePath.toUtf8().constData());
    if (!doc) {
        qCritical() << "GraphFactory::loadFromXmlFile - failed to parse XML file:" << filePath;
        GraphSubject::endBatch();  // Clean up batch mode on error
        return false;
    }
    
    xmlNodePtr root = xmlDocGetRootElement(doc);
    if (!root) {
        qCritical() << "GraphFactory::loadFromXmlFile - no root element";
        xmlFreeDoc(doc);
        GraphSubject::endBatch();  // Clean up batch mode on error
        return false;
    }
    
    if (xmlStrcmp(root->name, (const xmlChar*)"graph") != 0) {
        qCritical() << "Invalid XML file: root element should be 'graph'";
        xmlFreeDoc(doc);
        GraphSubject::endBatch();  // Clean up batch mode on error
        return false;
    }
    
    qDebug() << "✓ XML file parsed successfully";
    
    // PHASE 1: Load ALL nodes first - handle both direct and nested formats
    QVector<Node*> allNodes;
    
    // Check if nodes are direct children or nested under <nodes>
    xmlNodePtr nodesContainer = nullptr;
    for (xmlNodePtr child = root->children; child; child = child->next) {
        if (child->type == XML_ELEMENT_NODE && xmlStrcmp(child->name, (const xmlChar*)"nodes") == 0) {
            nodesContainer = child;
            break;
        }
    }
    
    // Load nodes from appropriate location
    xmlNodePtr nodeParent = nodesContainer ? nodesContainer : root;
    qDebug() << "=== Loading Nodes" << (nodesContainer ? "from <nodes> wrapper" : "directly from root") << "===";
    
    for (xmlNodePtr xmlNode = nodeParent->children; xmlNode; xmlNode = xmlNode->next) {
        if (xmlNode->type == XML_ELEMENT_NODE && xmlStrcmp(xmlNode->name, (const xmlChar*)"node") == 0) {
            
            // Check if this node has the format we support (inputs/outputs attributes)
            xmlChar* inputsAttr = xmlGetProp(xmlNode, BAD_CAST "inputs");
            xmlChar* outputsAttr = xmlGetProp(xmlNode, BAD_CAST "outputs");
            
            if (inputsAttr && outputsAttr) {
                // Our format: <node inputs="1" outputs="1" />
                Node* node = createNodeFromXml(xmlNode);
                if (node) {
                    allNodes.append(node);
                    qDebug() << "✓ Loaded node:" << node->getNodeType() 
                             << "ID:" << node->getId().toString(QUuid::WithoutBraces).left(8);
                }
                xmlFree(inputsAttr);
                xmlFree(outputsAttr);
            } else {
                // Nested socket format: <node><socket /></node> - skip
                qDebug() << "Skipping node with nested socket format (not supported)";
                if (inputsAttr) xmlFree(inputsAttr);
                if (outputsAttr) xmlFree(outputsAttr);
            }
        }
    }
    
    // PHASE 2: Load edges (but don't resolve connections yet)
    QVector<Edge*> allEdges;
    qDebug() << "=== Loading Edges directly from root ===";
    for (xmlNodePtr xmlNode = root->children; xmlNode; xmlNode = xmlNode->next) {
        if (xmlNode->type == XML_ELEMENT_NODE && xmlStrcmp(xmlNode->name, (const xmlChar*)"edge") == 0) {
            Edge* edge = createEdgeFromXml(xmlNode);
            if (edge) {
                allEdges.append(edge);
                qDebug() << "✓ Loaded edge:" << edge->getId().toString(QUuid::WithoutBraces).left(8);
            }
        }
    }
    
    qDebug() << "=== XML Loading Complete ===";
    qDebug() << "✓ Loaded" << allNodes.size() << "nodes and" << allEdges.size() << "edges";
    
    xmlFreeDoc(doc);
    
    // PHASE 3: Resolve all edge connections now that all nodes exist
    qDebug() << "=== Resolving Edge Connections ===";
    int successfulConnections = 0;
    if (Scene* typedScene = static_cast<Scene*>(m_scene)) {
        for (Edge* edge : allEdges) {
            qDebug() << "Resolving edge:" << edge->getId().toString(QUuid::WithoutBraces).left(8);
            if (edge->resolveConnections(typedScene)) {
                successfulConnections++;
            } else {
                qWarning() << "FAILED to resolve edge connections:" << edge->getId().toString(QUuid::WithoutBraces).left(8);
            }
        }
    }
    
    qDebug() << "✓ Graph loaded:" << allNodes.size() << "nodes," << successfulConnections << "/" << allEdges.size() << "edges connected";
    
    // OPTIMIZATION: End batch mode to resume normal observer notifications
    GraphSubject::endBatch();
    
    // Validate graph integrity in debug builds
    #ifdef QT_DEBUG
    if (!validateGraphIntegrity()) {
        qWarning() << "Graph integrity validation failed after loading";
    }
    #endif
    
    return true;
}

QString GraphFactory::getXmlProperty(xmlNodePtr node, const QString& name)
{
    if (!node) return QString();
    
    xmlChar* prop = xmlGetProp(node, BAD_CAST name.toUtf8().constData());
    if (!prop) return QString();
    
    QString result = QString::fromUtf8((char*)prop);
    xmlFree(prop);
    return result;
}

xmlNodePtr GraphFactory::createXmlNode(const QString& nodeType, const QPointF& position, int inputs, int outputs)
{
    xmlNodePtr nodesElement = getNodesElement();
    if (!nodesElement) {
        qCritical() << "GraphFactory::createXmlNode - no nodes element in XML";
        return nullptr;
    }
    
    // Create new node element
    xmlNodePtr nodeElement = xmlNewChild(nodesElement, nullptr, BAD_CAST "node", nullptr);
    
    // Set attributes including socket configuration
    QUuid nodeId = QUuid::createUuid();
    xmlSetProp(nodeElement, BAD_CAST "id", BAD_CAST nodeId.toString(QUuid::WithoutBraces).toUtf8().constData());
    xmlSetProp(nodeElement, BAD_CAST "type", BAD_CAST nodeType.toUtf8().constData());
    xmlSetProp(nodeElement, BAD_CAST "x", BAD_CAST QString::number(position.x()).toUtf8().constData());
    xmlSetProp(nodeElement, BAD_CAST "y", BAD_CAST QString::number(position.y()).toUtf8().constData());
    xmlSetProp(nodeElement, BAD_CAST "inputs", BAD_CAST QString::number(inputs).toUtf8().constData());
    xmlSetProp(nodeElement, BAD_CAST "outputs", BAD_CAST QString::number(outputs).toUtf8().constData());
    
    qDebug() << "GraphFactory: Created XML node, type:" << nodeType << "id:" << nodeId.toString(QUuid::WithoutBraces).left(8)
             << "inputs:" << inputs << "outputs:" << outputs;
    
    return nodeElement;
}

xmlNodePtr GraphFactory::createXmlEdgeNodeIndex(const QUuid& fromNodeId, int fromSocketIndex, const QUuid& toNodeId, int toSocketIndex)
{
    xmlNodePtr edgesElement = getEdgesElement();
    if (!edgesElement) {
        qCritical() << "GraphFactory::createXmlEdgeNodeIndex - no edges element in XML";
        return nullptr;
    }
    
    // Create new edge element
    xmlNodePtr edgeElement = xmlNewChild(edgesElement, nullptr, BAD_CAST "edge", nullptr);
    
    // Set attributes using clean node+index format
    QUuid edgeId = QUuid::createUuid();
    xmlSetProp(edgeElement, BAD_CAST "id", BAD_CAST edgeId.toString(QUuid::WithoutBraces).toUtf8().constData());
    xmlSetProp(edgeElement, BAD_CAST "fromNode", BAD_CAST fromNodeId.toString(QUuid::WithoutBraces).toUtf8().constData());
    xmlSetProp(edgeElement, BAD_CAST "toNode", BAD_CAST toNodeId.toString(QUuid::WithoutBraces).toUtf8().constData());
    xmlSetProp(edgeElement, BAD_CAST "fromSocketIndex", BAD_CAST QString::number(fromSocketIndex).toUtf8().constData());
    xmlSetProp(edgeElement, BAD_CAST "toSocketIndex", BAD_CAST QString::number(toSocketIndex).toUtf8().constData());
    
    qDebug() << "GraphFactory: Created XML edge, id:" << edgeId.toString(QUuid::WithoutBraces).left(8)
             << "from node:" << fromNodeId.toString(QUuid::WithoutBraces).left(8) << "socket" << fromSocketIndex
             << "to node:" << toNodeId.toString(QUuid::WithoutBraces).left(8) << "socket" << toSocketIndex;
    
    return edgeElement;
}

xmlNodePtr GraphFactory::getNodesElement()
{
    if (!m_xmlDocument) return nullptr;
    
    xmlNodePtr root = xmlDocGetRootElement(m_xmlDocument);
    if (!root) return nullptr;
    
    // Find or create <nodes> element
    for (xmlNodePtr child = root->children; child; child = child->next) {
        if (xmlStrcmp(child->name, BAD_CAST "nodes") == 0) {
            return child;
        }
    }
    
    // Create nodes element if it doesn't exist
    xmlNodePtr nodesElement = xmlNewChild(root, nullptr, BAD_CAST "nodes", nullptr);
    return nodesElement;
}

xmlNodePtr GraphFactory::getEdgesElement()
{
    if (!m_xmlDocument) return nullptr;
    
    xmlNodePtr root = xmlDocGetRootElement(m_xmlDocument);
    if (!root) return nullptr;
    
    // Find or create <edges> or <connections> element
    for (xmlNodePtr child = root->children; child; child = child->next) {
        if (xmlStrcmp(child->name, BAD_CAST "edges") == 0 ||
            xmlStrcmp(child->name, BAD_CAST "connections") == 0) {
            return child;
        }
    }
    
    // Create connections element if it doesn't exist
    xmlNodePtr connectionsElement = xmlNewChild(root, nullptr, BAD_CAST "connections", nullptr);
    return connectionsElement;
}

// Clean design: socket resolution handled by edges internally - method removed

// No socket resolver needed in clean design - edges use direct socket pointers

bool GraphFactory::validateGraphIntegrity() const
{
    if (!m_scene) {
        qCritical() << "GraphFactory::validateGraphIntegrity - no scene";
        return false;
    }
    
    Scene* typedScene = static_cast<Scene*>(m_scene);
    if (!typedScene) {
        qCritical() << "GraphFactory::validateGraphIntegrity - scene not typed";
        return false;
    }
    
    bool valid = true;
    
    // Validate all nodes have UUIDs and observers
    for (Node* node : typedScene->getNodes().values()) {
        if (!node) {
            qCritical() << "Validation: null node in scene";
            valid = false;
            continue;
        }
        
        if (node->getId().isNull()) {
            qCritical() << "Validation: node without UUID";
            valid = false;
        }
        
        // Check sockets belong to parent node
        for (QGraphicsItem* child : node->childItems()) {
            if (Socket* socket = qgraphicsitem_cast<Socket*>(child)) {
                if (socket->getParentNode() != node) {
                    qCritical() << "Validation: socket parent mismatch";
                    valid = false;
                }
            }
        }
    }
    
    // Validate all edges have valid socket connections
    for (Edge* edge : typedScene->getEdges().values()) {
        if (!edge) {
            qCritical() << "Validation: null edge in scene";
            valid = false;
            continue;
        }
        
        if (edge->getId().isNull()) {
            qCritical() << "Validation: edge without UUID";
            valid = false;
        }
        
        // Clean design: edges should have been resolved during loading
        // Skip validation - edges were validated during resolveConnections() call
    }
    
    // Validate scene count matches typed collections
    int sceneItems = m_scene->items().size();
    int typedItems = typedScene->getNodes().size() + typedScene->getEdges().size();
    
    // Account for sockets as children
    int socketCount = 0;
    for (Node* node : typedScene->getNodes().values()) {
        socketCount += node->getSocketCount();
    }
    typedItems += socketCount;
    
    if (sceneItems != typedItems) {
        qWarning() << "Validation: scene item count mismatch - scene:" << sceneItems 
                   << "typed:" << typedItems;
        // This is a warning, not an error - some items might be temporary
    }
    
    if (valid) {
        qDebug() << "✓ Graph integrity validation passed";
    }
    
    return valid;
}

Socket* GraphFactory::createSocket(Socket::Role role, Node* parentNode, int index)
{
    if (!parentNode) {
        qCritical() << "GraphFactory::createSocket - null parent node";
        return nullptr;
    }
    
    // Create socket with factory access
    Socket* socket = new Socket(role, parentNode, index);
    if (!socket) {
        qCritical() << "GraphFactory::createSocket - failed to create socket";
        return nullptr;
    }
    
    // Add to typed scene collection if available
    if (Scene* typedScene = static_cast<Scene*>(m_scene)) {
        typedScene->addSocket(socket);
    }
    
    qDebug() << "GraphFactory: Created socket" << (role == Socket::Input ? "Input" : "Output") 
             << "index" << index << "for node" << parentNode->getId().toString(QUuid::WithoutBraces).left(8);
    
    return socket;
}

// ====================================
// FILE: graph_observer.cpp
// LAST MODIFIED: 2025-07-12 02:11:27
// ====================================

#include "graph_observer.h"
#include "node.h"
#include "edge.h"
#include <QDebug>

// ============================================================================
// GraphSubject Implementation
// ============================================================================

// Initialize static batch depth
int GraphSubject::s_batchDepth = 0;

GraphSubject::~GraphSubject()
{
    // CRITICAL FIX: Clear observer container properly to prevent dangling pointers
    // The old code was setting local pointer to nullptr, not the container elements!
    qDebug() << "GraphSubject: Destroying subject with" << m_observers.size() << "observers";
    
    // Simply clear the container - observers manage their own lifecycle
    m_observers.clear();
    
    qDebug() << "GraphSubject: ✓ Observer container cleared safely";
}

void GraphSubject::attach(GraphObserver* observer)
{
    if (observer) {
        m_observers.insert(observer);
        qDebug() << "GraphSubject: Observer attached, total observers:" << m_observers.size();
    }
}

void GraphSubject::detach(GraphObserver* observer)
{
    if (observer && m_observers.remove(observer)) {
        qDebug() << "GraphSubject: Observer detached, remaining observers:" << m_observers.size();
    }
}

void GraphSubject::notifyNodeAdded(const Node& node)
{
    // OPTIMIZATION: Skip notifications during batch operations
    if (isInBatch()) return;
    
    qDebug() << "GraphSubject: Notifying" << m_observers.size() << "observers of node added:" 
             << node.getId().toString(QUuid::WithoutBraces).left(8);
    
    for (GraphObserver* observer : m_observers) {
        if (observer) {
            observer->onNodeAdded(node);
        }
    }
}

void GraphSubject::notifyNodeRemoved(const QUuid& nodeId)
{
    // OPTIMIZATION: Skip notifications during batch operations
    if (isInBatch()) return;
    
    qDebug() << "GraphSubject: Notifying" << m_observers.size() << "observers of node removed:" 
             << nodeId.toString(QUuid::WithoutBraces).left(8);
    
    for (GraphObserver* observer : m_observers) {
        if (observer) {
            observer->onNodeRemoved(nodeId);
        }
    }
}

void GraphSubject::notifyNodeMoved(const QUuid& nodeId, QPointF oldPos, QPointF newPos)
{
    // OPTIMIZATION: Skip notifications during batch operations
    if (isInBatch()) return;
    
    qDebug() << "GraphSubject: Notifying" << m_observers.size() << "observers of node moved:" 
             << nodeId.toString(QUuid::WithoutBraces).left(8) << "from" << oldPos << "to" << newPos;
    
    for (GraphObserver* observer : m_observers) {
        if (observer) {
            observer->onNodeMoved(nodeId, oldPos, newPos);
        }
    }
}

void GraphSubject::notifyEdgeAdded(const Edge& edge)
{
    // OPTIMIZATION: Skip notifications during batch operations
    if (isInBatch()) return;
    
    qDebug() << "GraphSubject: Notifying" << m_observers.size() << "observers of edge added:" 
             << edge.getId().toString(QUuid::WithoutBraces).left(8);
    
    for (GraphObserver* observer : m_observers) {
        if (observer) {
            observer->onEdgeAdded(edge);
        }
    }
}

void GraphSubject::notifyEdgeRemoved(const QUuid& edgeId)
{
    // OPTIMIZATION: Skip notifications during batch operations
    if (isInBatch()) return;
    
    qDebug() << "GraphSubject: Notifying" << m_observers.size() << "observers of edge removed:" 
             << edgeId.toString(QUuid::WithoutBraces).left(8);
    
    for (GraphObserver* observer : m_observers) {
        if (observer) {
            observer->onEdgeRemoved(edgeId);
        }
    }
}

void GraphSubject::notifyGraphCleared()
{
    qDebug() << "GraphSubject: Notifying" << m_observers.size() << "observers of graph cleared";
    
    for (GraphObserver* observer : m_observers) {
        if (observer) {
            observer->onGraphCleared();
        }
    }
}

void GraphSubject::notifyGraphLoaded(const QString& filename)
{
    qDebug() << "GraphSubject: Notifying" << m_observers.size() << "observers of graph loaded:" << filename;
    
    for (GraphObserver* observer : m_observers) {
        if (observer) {
            observer->onGraphLoaded(filename);
        }
    }
}

void GraphSubject::notifyGraphSaved(const QString& filename)
{
    qDebug() << "GraphSubject: Notifying" << m_observers.size() << "observers of graph saved:" << filename;
    
    for (GraphObserver* observer : m_observers) {
        if (observer) {
            observer->onGraphSaved(filename);
        }
    }
}

// ============================================================================
// Batch Mode Implementation
// ============================================================================

void GraphSubject::beginBatch()
{
    ++s_batchDepth;
    qDebug() << "GraphSubject: Begin batch mode (depth:" << s_batchDepth << ")";
}

void GraphSubject::endBatch()
{
    if (s_batchDepth > 0) {
        --s_batchDepth;
        qDebug() << "GraphSubject: End batch mode (depth:" << s_batchDepth << ")";
        
        if (s_batchDepth == 0) {
            qDebug() << "GraphSubject: Batch complete - observers can resume";
        }
    }
}

// ====================================
// FILE: layout_engine.cpp
// LAST MODIFIED: 2025-07-11 16:51:59
// ====================================

#include "layout_engine.h"
#include "scene.h"
#include "node.h"
#include "edge.h"
#include <QRandomGenerator>
#include <QtMath>
#include <algorithm>

LayoutEngine::LayoutEngine()
    : m_canvasWidth(800.0)
    , m_canvasHeight(600.0)
{
    qDebug() << "LayoutEngine: Initialized with lightweight backend";
}

void LayoutEngine::buildGraphFromScene(Scene* scene)
{
    if (!scene) {
        qCritical() << "LayoutEngine::buildGraphFromScene - null scene";
        return;
    }
    
    clear();
    
    // Add all nodes
    auto nodes = scene->getNodes();
    for (Node* node : nodes) {
        QUuid nodeId = node->getId();
        QPointF position = node->pos();
        addNode(nodeId, position);
    }
    
    // Add all edges  
    auto edges = scene->getEdges();
    for (Edge* edge : edges) {
        Node* fromNode = edge->getFromNode();
        Node* toNode = edge->getToNode();
        
        if (!fromNode || !toNode) {
            continue; // Skip unresolved edges
        }
        
        QUuid fromId = fromNode->getId();
        QUuid toId = toNode->getId();
        addEdge(fromId, toId, 1.0);
    }
    
    qDebug() << "LayoutEngine: Built graph from scene with" 
             << m_nodes.size() << "nodes and" 
             << m_edges.size() << "edges";
}

void LayoutEngine::addNode(const QUuid& nodeId, const QPointF& position)
{
    LayoutNode layoutNode(nodeId, position);
    m_nodes[nodeId] = layoutNode;
    
    qDebug() << "LayoutEngine: Added node" << nodeId.toString(QUuid::WithoutBraces).left(8)
             << "at position" << position;
}

void LayoutEngine::addEdge(const QUuid& fromNodeId, const QUuid& toNodeId, qreal weight)
{
    if (!m_nodes.contains(fromNodeId) || !m_nodes.contains(toNodeId)) {
        qCritical() << "LayoutEngine::addEdge - one or both nodes not found";
        return;
    }
    
    LayoutEdge layoutEdge(fromNodeId, toNodeId, weight);
    m_edges.append(layoutEdge);
    
    qDebug() << "LayoutEngine: Added edge" 
             << fromNodeId.toString(QUuid::WithoutBraces).left(8) << "->"
             << toNodeId.toString(QUuid::WithoutBraces).left(8);
}

void LayoutEngine::clear()
{
    m_nodes.clear();
    m_edges.clear();
    qDebug() << "LayoutEngine: Cleared graph data";
}

void LayoutEngine::applyGridLayout(qreal spacing)
{
    if (m_nodes.isEmpty()) {
        qWarning() << "LayoutEngine::applyGridLayout - no nodes to layout";
        return;
    }
    
    int gridSize = qCeil(qSqrt(m_nodes.size()));
    int currentIndex = 0;
    
    for (auto it = m_nodes.begin(); it != m_nodes.end(); ++it) {
        LayoutNode& layoutNode = it.value();
        
        if (!layoutNode.fixed) {
            int row = currentIndex / gridSize;
            int col = currentIndex % gridSize;
            
            QPointF newPosition(col * spacing, row * spacing);
            layoutNode.position = newPosition;
        }
        
        currentIndex++;
    }
    
    qDebug() << "LayoutEngine: Applied grid layout with spacing" << spacing;
}

void LayoutEngine::applyCircularLayout(qreal radius)
{
    if (m_nodes.isEmpty()) {
        qWarning() << "LayoutEngine::applyCircularLayout - no nodes to layout";
        return;
    }
    
    QPointF center(m_canvasWidth / 2.0, m_canvasHeight / 2.0);
    auto nodeIds = m_nodes.keys();
    int nodeCount = nodeIds.size();
    
    for (int i = 0; i < nodeCount; ++i) {
        QUuid nodeId = nodeIds[i];
        LayoutNode& layoutNode = m_nodes[nodeId];
        
        if (!layoutNode.fixed) {
            qreal angle = (2.0 * M_PI * i) / nodeCount;
            QPointF newPosition(
                center.x() + radius * qCos(angle),
                center.y() + radius * qSin(angle)
            );
            layoutNode.position = constrainToCanvas(newPosition);
        }
    }
    
    qDebug() << "LayoutEngine: Applied circular layout with radius" << radius;
}

void LayoutEngine::applyForceDirectedLayout(int iterations, qreal k)
{
    if (m_nodes.isEmpty()) {
        qWarning() << "LayoutEngine::applyForceDirectedLayout - no nodes to layout";
        return;
    }
    
    qreal timeStep = 0.1;
    qreal damping = 0.9;
    
    for (int iter = 0; iter < iterations; ++iter) {
        // Calculate forces for each node
        for (auto nodeIt = m_nodes.begin(); nodeIt != m_nodes.end(); ++nodeIt) {
            QUuid nodeId = nodeIt.key();
            LayoutNode& currentNode = nodeIt.value();
            
            if (currentNode.fixed) continue;
            
            QPointF totalForce(0, 0);
            
            // Repulsive forces from all other nodes
            for (auto otherIt = m_nodes.begin(); otherIt != m_nodes.end(); ++otherIt) {
                if (nodeIt.key() == otherIt.key()) continue;
                
                const LayoutNode& otherNode = otherIt.value();
                QPointF repulsiveForce = calculateRepulsiveForce(currentNode, otherNode, k);
                totalForce += repulsiveForce;
            }
            
            // Attractive forces from connected nodes
            for (const LayoutEdge& edge : m_edges) {
                QUuid connectedNodeId;
                
                if (edge.fromNodeId == nodeId) {
                    connectedNodeId = edge.toNodeId;
                } else if (edge.toNodeId == nodeId) {
                    connectedNodeId = edge.fromNodeId;
                } else {
                    continue; // Edge doesn't involve current node
                }
                
                if (m_nodes.contains(connectedNodeId)) {
                    const LayoutNode& connectedNode = m_nodes[connectedNodeId];
                    QPointF attractiveForce = calculateAttractiveForce(currentNode, connectedNode, k);
                    totalForce += attractiveForce;
                }
            }
            
            // Update velocity and position with damping
            currentNode.velocity = (currentNode.velocity + totalForce * timeStep) * damping;
            updateNodePosition(nodeId, currentNode.velocity, timeStep);
        }
        
        // Cool down the system
        timeStep *= 0.99;
    }
    
    qDebug() << "LayoutEngine: Applied force-directed layout with" << iterations << "iterations";
}

void LayoutEngine::applyRandomLayout(qreal width, qreal height)
{
    if (m_nodes.isEmpty()) {
        qWarning() << "LayoutEngine::applyRandomLayout - no nodes to layout";
        return;
    }
    
    auto* generator = QRandomGenerator::global();
    
    for (auto it = m_nodes.begin(); it != m_nodes.end(); ++it) {
        LayoutNode& layoutNode = it.value();
        
        if (!layoutNode.fixed) {
            QPointF newPosition(
                generator->bounded(width),
                generator->bounded(height)
            );
            layoutNode.position = newPosition;
        }
    }
    
    qDebug() << "LayoutEngine: Applied random layout in" << width << "x" << height << "area";
}

QHash<QUuid, QPointF> LayoutEngine::getNodePositions() const
{
    QHash<QUuid, QPointF> positions;
    
    for (auto it = m_nodes.begin(); it != m_nodes.end(); ++it) {
        QUuid nodeId = it.key();
        const LayoutNode& layoutNode = it.value();
        positions[nodeId] = layoutNode.position;
    }
    
    return positions;
}

void LayoutEngine::applyToScene(Scene* scene)
{
    if (!scene) {
        qCritical() << "LayoutEngine::applyToScene - null scene";
        return;
    }
    
    auto positions = getNodePositions();
    int appliedCount = 0;
    
    for (auto it = positions.begin(); it != positions.end(); ++it) {
        QUuid nodeId = it.key();
        QPointF position = it.value();
        
        Node* node = scene->getNode(nodeId);
        if (node) {
            node->setPos(position);
            appliedCount++;
        }
    }
    
    qDebug() << "LayoutEngine: Applied positions to" << appliedCount << "nodes in scene";
}

void LayoutEngine::setNodeFixed(const QUuid& nodeId, bool fixed)
{
    if (m_nodes.contains(nodeId)) {
        m_nodes[nodeId].fixed = fixed;
        
        qDebug() << "LayoutEngine: Set node" << nodeId.toString(QUuid::WithoutBraces).left(8)
                 << "fixed =" << fixed;
    }
}

void LayoutEngine::printGraphStats() const
{
    qDebug() << "=== LayoutEngine Graph Statistics ===";
    qDebug() << "Nodes:" << m_nodes.size();
    qDebug() << "Edges:" << m_edges.size();
    qDebug() << "Canvas size:" << m_canvasWidth << "x" << m_canvasHeight;
    
    // Print node details
    for (auto it = m_nodes.begin(); it != m_nodes.end(); ++it) {
        const LayoutNode& layoutNode = it.value();
        qDebug() << "  Node" << layoutNode.id.toString(QUuid::WithoutBraces).left(8)
                 << "at" << layoutNode.position
                 << (layoutNode.fixed ? "(fixed)" : "(free)");
    }
}

// Private helper functions

QPointF LayoutEngine::calculateRepulsiveForce(const LayoutNode& node1, const LayoutNode& node2, qreal k) const
{
    QPointF delta = node1.position - node2.position;
    qreal distance = qSqrt(delta.x() * delta.x() + delta.y() * delta.y());
    
    if (distance < 1.0) distance = 1.0; // Avoid division by zero
    
    qreal force = (k * k) / distance;
    QPointF direction = delta / distance;
    
    return direction * force;
}

QPointF LayoutEngine::calculateAttractiveForce(const LayoutNode& node1, const LayoutNode& node2, qreal k) const
{
    QPointF delta = node2.position - node1.position;
    qreal distance = qSqrt(delta.x() * delta.x() + delta.y() * delta.y());
    
    if (distance < 1.0) distance = 1.0; // Avoid division by zero
    
    qreal force = (distance * distance) / k;
    QPointF direction = delta / distance;
    
    return direction * force;
}

void LayoutEngine::updateNodePosition(const QUuid& nodeId, const QPointF& force, qreal timeStep)
{
    if (m_nodes.contains(nodeId)) {
        LayoutNode& layoutNode = m_nodes[nodeId];
        
        if (!layoutNode.fixed) {
            QPointF newPosition = layoutNode.position + force * timeStep;
            layoutNode.position = constrainToCanvas(newPosition);
        }
    }
}

QPointF LayoutEngine::constrainToCanvas(const QPointF& position) const
{
    qreal margin = 50.0;
    return QPointF(
        qBound(margin, position.x(), m_canvasWidth - margin),
        qBound(margin, position.y(), m_canvasHeight - margin)
    );
}

// ====================================
// FILE: main.cpp
// LAST MODIFIED: 2025-07-14 03:03:20
// ====================================

#include <QApplication>
#include <QCommandLineParser>
#include <QCommandLineOption>
#include <QFileInfo>
#include <QDebug>
#include <QLoggingCategory>
#include <QStandardPaths>
#include <QDir>
#include <QTextStream>
#include <QDateTime>
#include <QMutex>
#include <QTimer>
#include <QMessageBox>
#include <iostream>
#include "window.h"
#include "scene.h"
#include "node.h"
#include "edge.h"
#include "graph_factory.h"
#include "node_registry.h"

void setupLogging()
{
    // Create logs directory if it doesn't exist
    QDir logsDir("logs");
    if (!logsDir.exists()) {
        logsDir.mkpath(".");
    }
    
    // Create timestamped log file
    QString timestamp = QDateTime::currentDateTime().toString("yyyy-MM-dd_hh-mm-ss");
    QString logFileName = QString("logs/NodeGraph_%1.log").arg(timestamp);
    
    // Redirect Qt debug output to file
    static QFile debugFile(logFileName);
    debugFile.open(QIODevice::WriteOnly | QIODevice::Append);
    static QTextStream stream(&debugFile);
    
    qInstallMessageHandler([](QtMsgType type, const QMessageLogContext &context, const QString &msg) {
        QString timestamp = QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss.zzz");
        QString typeStr;
        
        switch (type) {
        case QtDebugMsg:    typeStr = "DEBUG"; break;
        case QtInfoMsg:     typeStr = "INFO "; break;
        case QtWarningMsg:  typeStr = "WARN "; break;
        case QtCriticalMsg: typeStr = "ERROR"; break;
        case QtFatalMsg:    typeStr = "FATAL"; break;
        }
        
        stream << QString("[%1] %2: %3").arg(timestamp, typeStr, msg) << Qt::endl;
        stream.flush();
    });
    
    qDebug() << "=== NodeGraph Application Started ===";
    qDebug() << "Log file:" << logFileName;
    qDebug() << "Timestamp:" << QDateTime::currentDateTime().toString();
}

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    
    // Setup file logging
    setupLogging();
    
    
    // Set application metadata for Qt command line tools
    QCoreApplication::setApplicationName("NodeGraph");
    QCoreApplication::setApplicationVersion("1.0.0");
    QCoreApplication::setOrganizationName("NodeGraph Project");
    // setApplicationDisplayName not available in Qt 5.x on all platforms
    
    // Setup Qt5 command line parser
    QCommandLineParser parser;
    parser.setApplicationDescription("A self-serializing node graph editor with libxml2 backend");
    parser.addHelpOption();
    parser.addVersionOption();
    
    // Add file loading option
    QCommandLineOption loadFileOption(QStringList() << "l" << "load",
                                      "Load graph from XML file",
                                      "file");
    parser.addOption(loadFileOption);
    
    // Clean startup - no test options needed
    
    // Add positional argument for file
    parser.addPositionalArgument("file", "XML file to load (optional)");
    
    // Process command line arguments
    parser.process(app);
    
    // Command line parsing complete
    
    // Create main window
    Window window;
    
    // Handle file loading
    QString filename;
    if (parser.isSet(loadFileOption)) {
        filename = parser.value(loadFileOption);
    } else {
        const QStringList positionalArgs = parser.positionalArguments();
        if (!positionalArgs.isEmpty()) {
            filename = positionalArgs.first();
        }
    }
    
    // Store information about file loading status for user notification
    bool fileLoadAttempted = !filename.isEmpty();
    QString originalFilename = filename; // Store original filename for user message
    
    xmlDocPtr xmlDoc = nullptr;
    if (!filename.isEmpty()) {
        QFileInfo fileInfo(filename);
        if (fileInfo.exists() && fileInfo.isReadable()) {
            // Load XML file using libxml2
            xmlDoc = xmlParseFile(fileInfo.absoluteFilePath().toUtf8().constData());
            if (!xmlDoc) {
                qCritical() << "Failed to parse XML file:" << filename;
                filename.clear(); // Clear filename so we create a default document
            }
        } else {
            qDebug() << "File not found:" << filename;
            filename.clear(); // Clear filename so we create a default document
        }
    }
    
    // Create default XML document if no file was loaded or file was missing/invalid
    if (!xmlDoc) {
        // Create default XML document structure for XML-first architecture
        qDebug() << "=== Creating XML Document Structure ===";
        xmlDoc = xmlNewDoc(BAD_CAST "1.0");
        xmlNodePtr root = xmlNewNode(nullptr, BAD_CAST "graph");
        xmlDocSetRootElement(xmlDoc, root);
        
        xmlSetProp(root, BAD_CAST "version", BAD_CAST "1.0");
        xmlSetProp(root, BAD_CAST "xmlns", BAD_CAST "http://nodegraph.org/schema");
        
        qDebug() << "✓ XML document created with root element";
    }
    
    // Register clean design node types
    qDebug() << "=== Registering Node Types ===";
    NodeRegistry::instance().registerNode("IN", []() { 
        Node* node = new Node(); 
        node->setNodeType("IN"); 
        return node; 
    });
    NodeRegistry::instance().registerNode("OUT", []() { 
        Node* node = new Node(); 
        node->setNodeType("OUT"); 
        return node; 
    });
    
    // Legacy compatibility for tests (maps to clean types)
    NodeRegistry::instance().registerNode("PROCESSOR", []() { 
        Node* node = new Node(); 
        node->setNodeType("OUT");  // Map legacy PROCESSOR to OUT
        return node; 
    });
    NodeRegistry::instance().registerNode("SOURCE", []() { 
        Node* node = new Node(); 
        node->setNodeType("OUT");  // Map legacy SOURCE to OUT
        return node; 
    });
    NodeRegistry::instance().registerNode("SINK", []() { 
        Node* node = new Node(); 
        node->setNodeType("IN");   // Map legacy SINK to IN
        return node; 
    });
    
    // Test the NodeRegistry to verify nodes are registered
    qDebug() << "=== NodeGraph Application Starting ===";
    qDebug() << "Registered node types:" << NodeRegistry::instance().getRegisteredTypes();
    
    // Initialize GraphFactory with scene and XML document
    Scene* scene = window.getScene();
    if (!scene) {
        qCritical() << "✗ Failed to get scene from window";
        return -1;
    }
    
    GraphFactory factory(scene, xmlDoc);
    qDebug() << "✓ GraphFactory initialized with scene and XML document";
    
    if (!filename.isEmpty()) {
        // Use GraphFactory's XML loading - single source of truth
        if (!factory.loadFromXmlFile(filename)) {
            qCritical() << "Failed to load XML file:" << filename;
            return -1;
        }
        
        qDebug() << "✓ Graph loaded successfully from file:" << filename;
        
    } else {
        qDebug() << "Starting with empty graph - use node palette to create nodes";
    }
    
    qDebug() << "=== XML-First Architecture Test Complete ===";
    
    // Set current file if we loaded from command line
    if (!filename.isEmpty()) {
        window.setCurrentFile(filename);
        qDebug() << "📁 Command line file loaded - Ctrl+S will save to:" << filename;
    }
    
    // Cleanup XML document when done
    // Note: GraphFactory holds reference, so clean up after window closes
    
    window.show();
    
    // Show user-friendly message about file loading status
    if (fileLoadAttempted && originalFilename != filename) {
        // File was attempted but failed to load (filename was cleared)
        QTimer::singleShot(500, [&window, originalFilename]() {
            QMessageBox::information(&window, "File Not Found", 
                QString("The specified file could not be found or loaded:\n\n%1\n\nStarting with an empty graph instead.\n\nYou can create a new graph or open an existing file using File → Open.")
                .arg(originalFilename));
        });
    }
    
    int result = app.exec();
    
    // Final status before exit
    qDebug() << "=== NodeGraph Application Ending ===";
    
    // Cleanup XML document
    if (xmlDoc) {
        xmlFreeDoc(xmlDoc);
        qDebug() << "✓ XML document cleaned up";
    }
    
    return result;
}

// ====================================
// FILE: node.cpp
// LAST MODIFIED: 2025-07-14 03:03:20
// ====================================

#include "node.h"
#include "socket.h"
#include "edge.h"
#include "scene.h"
#include <QPainter>
#include <QStyleOptionGraphicsItem>
#include <QWidget>
#include <QDebug>
#include <QTimer>
#include <libxml/tree.h>

Node::Node(const QUuid& id, const QPointF& position)
    : m_id(id)
    , m_nodeType("DEFAULT")
    , m_width(80.0)
    , m_height(50.0)
    , m_changeCallback(nullptr)
    , m_observer(nullptr)
    , m_lastPos(position)
    , m_beingDestroyed(false)
{
    setPos(position);
    setFlag(QGraphicsItem::ItemIsMovable, true);
    setFlag(QGraphicsItem::ItemIsSelectable, true);
    setFlag(QGraphicsItem::ItemSendsGeometryChanges, true);
    
    // Node creation logging removed - working correctly
}

Node::~Node()
{
    // Built-in destruction safety - notify edges before they can access us
    m_beingDestroyed = true;
    
    qDebug() << "SAFETY: Node" << m_id.toString(QUuid::WithoutBraces).left(8) << "notifying" << m_incidentEdges.size() << "edges";
    
    // Copy the set to avoid modification during iteration
    QSet<Edge*> edgesCopy = m_incidentEdges;
    for (Edge* edge : edgesCopy) {
        edge->onNodeDestroying(this);
    }
    
    // Node destruction logging removed - working correctly
}

QRectF Node::boundingRect() const
{
    return QRectF(0, 0, m_width, m_height);
}

void Node::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
    Q_UNUSED(option)
    Q_UNUSED(widget)
    
    QRectF rect = boundingRect();
    
    // Draw node body with rounded corners and gradient
    painter->setRenderHint(QPainter::Antialiasing);
    
    // Enhanced selection highlight using Qt's selection system
    if (isSelected()) {
        // Draw selection glow effect
        painter->setPen(QPen(QColor(255, 69, 0), 6)); // Thick orange border
        painter->setBrush(QColor(255, 245, 205)); // Light orange background
        
        // Add outer glow
        QRectF glowRect = rect.adjusted(-3, -3, 3, 3);
        painter->setPen(QPen(QColor(255, 69, 0, 100), 8));
        painter->drawRoundedRect(glowRect, 10.0, 10.0);
        
        // Restore main border
        painter->setPen(QPen(QColor(255, 69, 0), 4));
    } else {
        painter->setPen(QPen(Qt::darkGray, 2));
        painter->setBrush(QColor(240, 240, 240)); // Light gray background
    }
    
    painter->drawRoundedRect(rect, 8.0, 8.0);
    
    // Draw node type with improved typography
    painter->setPen(Qt::black);
    
    // Performance optimization: static font (created once, not every frame)
    static const QFont nodeFont("Arial", 8, QFont::Bold);
    painter->setFont(nodeFont);
    
    // Draw node type instead of UUID
    QString displayText = m_nodeType;
    painter->drawText(rect, Qt::AlignCenter, displayText);
    
    // Draw subtle node ID below type (smaller)
    if (rect.height() > 35) {
        // Performance optimization: cache display string (created once, not every frame)
        if (m_cachedDisplayId.isEmpty()) {
            m_cachedDisplayId = m_id.toString(QUuid::WithoutBraces).left(6);
        }
        
        static const QFont idFont("Arial", 6);
        painter->setFont(idFont);
        painter->setPen(QColor(120, 120, 120));
        
        QRectF idRect = rect.adjusted(0, rect.height() * 0.6, 0, 0);
        painter->drawText(idRect, Qt::AlignCenter, m_cachedDisplayId);
    }
}

QVariant Node::itemChange(GraphicsItemChange change, const QVariant &value)
{
    if (change == ItemSelectedHasChanged) {
        // Selection tracking logging - what has been selected
        bool isNowSelected = value.toBool();
        qDebug() << "Node" << m_id.toString(QUuid::WithoutBraces).left(8) 
                 << (isNowSelected ? "SELECT" : "DESELECT") << m_nodeType;
        
        // Trigger visual update when selection changes
        update();
    } else if (change == ItemPositionHasChanged) {
        // Only update edges when position actually changes significantly
        QPointF currentPos = value.toPointF();
        if ((currentPos - m_lastPos).manhattanLength() > 5.0) {
            QPointF oldPos = m_lastPos;
            m_lastPos = currentPos;
            
            // Re-enabled with safer edge updates
            updateConnectedEdges();
            
            // Notify observers of node movement via scene
            if (Scene* typedScene = static_cast<Scene*>(scene())) {
                typedScene->notifyNodeMoved(m_id, oldPos, currentPos);
            }
        }
        
        if (m_changeCallback) {
            m_changeCallback(this);
        }
    }
    return QGraphicsItem::itemChange(change, value);
}

void Node::setNodeSize(qreal width, qreal height)
{
    prepareGeometryChange();
    m_width = width;
    m_height = height;
    update();
}

void Node::calculateAndSetNodeSize(int inputCount, int outputCount)
{
    // Calculate required node dimensions based on socket count and spacing
    const qreal socketSpacing = 30.0;  // Match socket spacing from Socket::updatePosition()
    const qreal socketSize = 20.0;     // Match socket bounding rect size
    const qreal minNodeWidth = 120.0;  // Minimum width for node text
    const qreal minNodeHeight = 60.0;  // Minimum height for node content
    const qreal socketPadding = 10.0;  // Extra padding around sockets
    
    // Calculate maximum sockets on each side
    int maxSockets = qMax(inputCount, outputCount);
    
    // Calculate minimum height needed for sockets with proper spacing
    qreal requiredHeight = minNodeHeight;
    if (maxSockets > 0) {
        // Height = padding + (socket_count * socket_size) + ((socket_count - 1) * spacing) + padding
        qreal socketAreaHeight = maxSockets * socketSize + (maxSockets - 1) * (socketSpacing - socketSize) + 2 * socketPadding;
        requiredHeight = qMax(minNodeHeight, socketAreaHeight);
    }
    
    // Set calculated size
    setNodeSize(minNodeWidth, requiredHeight);
    
    qDebug() << "Node" << m_id.toString(QUuid::WithoutBraces).left(8) 
             << "resized to" << minNodeWidth << "x" << requiredHeight 
             << "for" << maxSockets << "max sockets";
}

// Removed manual setSelected - using Qt's selection system

void Node::setNodeType(const QString& type)
{
    m_nodeType = type;
    createStaticSockets();
    update();
    
    qDebug() << "Node" << m_id.toString(QUuid::WithoutBraces).left(8) << "type:" << type;
}

void Node::createStaticSockets()
{
    // CRITICAL: Delete edges connected to this node BEFORE deleting sockets
    Scene* typedScene = static_cast<Scene*>(scene());
    if (typedScene) {
        QList<QUuid> edgesToDelete;
        for (auto it = typedScene->getEdges().begin(); it != typedScene->getEdges().end(); ++it) {
            Edge* edge = it.value();
            if (edge->isConnectedToNode(m_id)) {
                edgesToDelete.append(it.key());
            }
        }
        // Delete edges that reference old sockets
        for (const QUuid& edgeId : edgesToDelete) {
            typedScene->deleteEdge(edgeId);
        }
        qDebug() << "Node::createStaticSockets - removed" << edgesToDelete.size() 
                 << "edges before socket recreation for node" << m_id.toString(QUuid::WithoutBraces).left(8);
    }
    
    // Remove existing sockets (Qt will auto-delete child items)
    for (QGraphicsItem* child : childItems()) {
        if (qgraphicsitem_cast<Socket*>(child)) {
            delete child;  // Qt removes from parent automatically
        }
    }
    m_sockets.clear();  // Clear cache to prevent dangling pointers
    
    // This method now does nothing - sockets are created during XML read()
    // based on XML attributes like inputs="2" outputs="3"
}

void Node::createSocketsFromXml(int inputCount, int outputCount)
{
    // CRITICAL: Delete edges connected to this node BEFORE deleting sockets
    // Otherwise edges keep stale Socket* pointers and crash on updatePath()
    Scene* typedScene = static_cast<Scene*>(scene());
    if (typedScene) {
        QList<QUuid> edgesToDelete;
        for (auto it = typedScene->getEdges().begin(); it != typedScene->getEdges().end(); ++it) {
            Edge* edge = it.value();
            if (edge->isConnectedToNode(m_id)) {
                edgesToDelete.append(it.key());
            }
        }
        // Delete edges that reference old sockets
        for (const QUuid& edgeId : edgesToDelete) {
            typedScene->deleteEdge(edgeId);
        }
        qDebug() << "Node::createSocketsFromXml - removed" << edgesToDelete.size() 
                 << "edges before socket recreation for node" << m_id.toString(QUuid::WithoutBraces).left(8);
    }
    
    // Clear existing sockets - both graphics items AND cache
    for (QGraphicsItem* child : childItems()) {
        if (qgraphicsitem_cast<Socket*>(child)) {
            delete child;  // Qt removes from parent automatically
        }
    }
    m_sockets.clear();  // Clear cache to prevent dangling pointers
    
    int socketIndex = 0;
    
    // Create input sockets (indexes 0, 1, 2, ...)
    for (int i = 0; i < inputCount; ++i) {
        Socket* inputSocket = new Socket(Socket::Input, this, socketIndex++);
        // Register socket with scene if node has observer (GraphFactory)
        if (hasObserver()) {
            Scene* scene = static_cast<Scene*>(this->scene());
            if (scene) {
                scene->addSocket(inputSocket);
            }
        }
    }
    
    // Create output sockets (continuing index sequence)
    for (int i = 0; i < outputCount; ++i) {
        Socket* outputSocket = new Socket(Socket::Output, this, socketIndex++);
        // Register socket with scene if node has observer (GraphFactory)
        if (hasObserver()) {
            Scene* scene = static_cast<Scene*>(this->scene());
            if (scene) {
                scene->addSocket(outputSocket);
            }
        }
    }
    
    // Calculate and set node size based on socket count
    calculateAndSetNodeSize(inputCount, outputCount);
    
    // Update socket positions after node resize
    for (QGraphicsItem* child : childItems()) {
        if (Socket* socket = qgraphicsitem_cast<Socket*>(child)) {
            socket->updatePosition();
        }
    }
    
    qDebug() << "Node" << m_id.toString(QUuid::WithoutBraces).left(8) << inputCount << "IN" << outputCount << "OUT";
}

Socket* Node::getSocketByIndex(int index) const
{
    // O(1) socket lookup using cache - with safety validation
    if (index >= 0 && index < m_sockets.size()) {
        Socket* socket = m_sockets[index];
        if (!socket) {
            qCritical() << "Node::getSocketByIndex() - null socket at index" << index 
                       << "in node" << m_id.toString(QUuid::WithoutBraces).left(8);
            return nullptr;
        }
        // Belt-and-suspenders: check if socket has been deleted
        if (socket->scene() == nullptr) {
            qWarning() << "Node::getSocketByIndex() - socket at index" << index 
                      << "has been deleted (not in scene) in node" << m_id.toString(QUuid::WithoutBraces).left(8);
            return nullptr;
        }
        return socket;
    }
    qWarning() << "Node::getSocketByIndex() - index" << index << "out of bounds [0," 
               << m_sockets.size() << ") in node" << m_id.toString(QUuid::WithoutBraces).left(8);
    return nullptr;
}

int Node::getSocketCount() const
{
    // O(1) socket count using cache
    return m_sockets.size();
}

void Node::registerSocket(Socket* socket, int index)
{
    if (!socket) {
        qCritical() << "Node::registerSocket() - null socket passed for index" << index;
        return;
    }
    
    // Enforce contiguous indices - prevent sparse arrays with nullptr gaps
    if (index != m_sockets.size()) {
        qCritical() << "Node::registerSocket() - index" << index 
                   << "is not contiguous. Expected index" << m_sockets.size() 
                   << "for node" << m_id.toString(QUuid::WithoutBraces).left(8);
        Q_ASSERT(index == m_sockets.size());
        return;
    }
    
    // Append socket to maintain contiguous array
    m_sockets.append(socket);
    
    qDebug() << "Node" << m_id.toString(QUuid::WithoutBraces).left(8) << "socket" << index 
             << (socket->getRole() == Socket::Input ? "IN" : "OUT");
}

void Node::setChangeCallback(void (*callback)(Node*))
{
    m_changeCallback = callback;
}

// ============================================================================
// Edge Management - O(degree) Performance Optimization
// ============================================================================

void Node::registerEdge(Edge* edge)
{
    if (!edge) {
        qWarning() << "Node::registerEdge() - null edge pointer for node" << m_id.toString(QUuid::WithoutBraces).left(8);
        return;
    }
    
    // Debug assertion in development builds
    #ifdef QT_DEBUG
    if (m_incidentEdges.contains(edge)) {
        qWarning() << "Node::registerEdge() - edge already registered with node" << m_id.toString(QUuid::WithoutBraces).left(8);
        return;
    }
    #endif
    
    m_incidentEdges.insert(edge);
    // Edge registration logging removed - working correctly
}

void Node::unregisterEdge(Edge* edge)
{
    if (!edge) {
        qWarning() << "Node::unregisterEdge() - null edge pointer for node" << m_id.toString(QUuid::WithoutBraces).left(8);
        return;
    }
    
    // Debug assertion in development builds
    #ifdef QT_DEBUG
    if (!m_incidentEdges.contains(edge)) {
        qWarning() << "Node::unregisterEdge() - edge not found in node" << m_id.toString(QUuid::WithoutBraces).left(8);
        return;
    }
    #endif
    
    m_incidentEdges.remove(edge);
    // Edge unregistration logging removed - working correctly
}

void Node::updateConnectedEdges()
{
    // NEW: O(degree) performance - only update edges actually connected to this node
    for (Edge* edge : m_incidentEdges) {
        edge->updatePath();
    }
    
    // Edge update logging removed - working correctly
}


// Sockets now paint themselves as QGraphicsItems - no need for this method

xmlNodePtr Node::write(xmlDocPtr doc, xmlNodePtr repr) const
{
    xmlNodePtr node = xmlNewNode(nullptr, BAD_CAST "node");
    
    // Core attributes
    xmlSetProp(node, BAD_CAST "id", BAD_CAST m_id.toString(QUuid::WithoutBraces).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "x", BAD_CAST QString::number(pos().x()).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "y", BAD_CAST QString::number(pos().y()).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "type", BAD_CAST m_nodeType.toUtf8().constData());
    
    // Count sockets by role
    int inputCount = 0, outputCount = 0;
    for (QGraphicsItem* child : childItems()) {
        if (Socket* socket = qgraphicsitem_cast<Socket*>(child)) {
            if (socket->getRole() == Socket::Input) inputCount++;
            else if (socket->getRole() == Socket::Output) outputCount++;
        }
    }
    
    // Save socket configuration as XML attributes
    xmlSetProp(node, BAD_CAST "inputs", BAD_CAST QString::number(inputCount).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "outputs", BAD_CAST QString::number(outputCount).toUtf8().constData());
    
    if (repr) {
        xmlAddChild(repr, node);
    } else {
        xmlDocSetRootElement(doc, node);
    }
    
    return node;
}

void Node::read(xmlNodePtr node)
{
    if (!node) return;
    
    // Read UUID
    xmlChar* idStr = xmlGetProp(node, BAD_CAST "id");
    if (idStr) {
        m_id = QUuid(QString::fromUtf8((char*)idStr));
        xmlFree(idStr);
    }
    
    // Read node type 
    xmlChar* typeStr = xmlGetProp(node, BAD_CAST "type");
    if (typeStr) {
        m_nodeType = QString::fromUtf8((char*)typeStr);
        xmlFree(typeStr);
    }
    
    // Read socket configuration from XML attributes
    int inputCount = 1;  // Default
    int outputCount = 1; // Default
    
    xmlChar* inputsStr = xmlGetProp(node, BAD_CAST "inputs");
    if (inputsStr) {
        inputCount = QString::fromUtf8((char*)inputsStr).toInt();
        xmlFree(inputsStr);
    }
    
    xmlChar* outputsStr = xmlGetProp(node, BAD_CAST "outputs");
    if (outputsStr) {
        outputCount = QString::fromUtf8((char*)outputsStr).toInt();
        xmlFree(outputsStr);
    }
    
    // Create sockets based on XML configuration
    createSocketsFromXml(inputCount, outputCount);
    
    // Read position
    xmlChar* xStr = xmlGetProp(node, BAD_CAST "x");
    xmlChar* yStr = xmlGetProp(node, BAD_CAST "y");
    if (xStr && yStr) {
        qreal x = QString::fromUtf8((char*)xStr).toDouble();
        qreal y = QString::fromUtf8((char*)yStr).toDouble();
        setPos(x, y);
        xmlFree(xStr);
        xmlFree(yStr);
    }
    
    update();
}

// ====================================
// FILE: node_palette_bar.cpp
// LAST MODIFIED: 2025-07-14 09:10:06
// ====================================

#include "node_palette_bar.h"
#include <QLabel>
#include <QFrame>
#include <QScrollArea>
#include <QVBoxLayout>
#include <QGridLayout>
#include <QPixmap>
#include <QPainter>
#include <QFont>
#include <QDebug>

NodePaletteBar::NodePaletteBar(QWidget* parent)
    : QWidget(parent)
    , m_mainLayout(nullptr)
    , m_contentWidget(nullptr)
    , m_scrollArea(nullptr)
{
    setupUI();
    addBasicNodes();
    addMathNodes();
    addIONodes();
    
    qDebug() << "✓ NodePaletteBar initialized";
}

void NodePaletteBar::setupUI()
{
    setFixedWidth(120);  // Wider to accommodate category labels
    setMinimumHeight(300);
    
    // Create scroll area for node palette
    m_scrollArea = new QScrollArea(this);
    m_scrollArea->setWidgetResizable(true);
    m_scrollArea->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_scrollArea->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
    
    m_contentWidget = new QWidget();
    m_mainLayout = new QVBoxLayout(m_contentWidget);
    m_mainLayout->setSpacing(8);
    m_mainLayout->setContentsMargins(4, 4, 4, 4);
    
    m_scrollArea->setWidget(m_contentWidget);
    
    // Main layout for the entire widget
    QVBoxLayout* outerLayout = new QVBoxLayout(this);
    outerLayout->setContentsMargins(0, 0, 0, 0);
    outerLayout->addWidget(m_scrollArea);
    
    setLayout(outerLayout);
}

void NodePaletteBar::addBasicNodes()
{
    // Not used - we only have the 4 specific node types
}

void NodePaletteBar::addMathNodes()
{
    // Not used - we only have the 4 specific node types  
}

void NodePaletteBar::addIONodes()
{
    QWidget* nodeSection = createCategorySection("Node Types");
    QGridLayout* nodeLayout = new QGridLayout(nodeSection);
    nodeLayout->setSpacing(2);
    nodeLayout->setContentsMargins(4, 4, 4, 4);
    
    // The 4 required node types
    addToolToLayout(nodeLayout, "Source", createSocketIcon(0, 1, QColor(100, 255, 100)), 0, 0);
    addToolToLayout(nodeLayout, "Sink", createSocketIcon(1, 0, QColor(255, 100, 100)), 0, 1);
    addToolToLayout(nodeLayout, "1-to-2", createSocketIcon(1, 2, QColor(100, 100, 255)), 1, 0);
    addToolToLayout(nodeLayout, "2-to-1", createSocketIcon(2, 1, QColor(255, 255, 100)), 1, 1);
    
    m_mainLayout->addWidget(nodeSection);
}

QWidget* NodePaletteBar::createCategorySection(const QString& title)
{
    QWidget* section = new QWidget();
    
    // Create title label
    QLabel* titleLabel = new QLabel(title);
    titleLabel->setStyleSheet(
        "QLabel {"
        "  font-weight: bold;"
        "  color: #333333;"
        "  background-color: #e8e8e8;"
        "  padding: 2px 4px;"
        "  border: 1px solid #cccccc;"
        "  border-radius: 2px;"
        "}"
    );
    titleLabel->setAlignment(Qt::AlignCenter);
    
    // Create container for the section content
    QVBoxLayout* sectionLayout = new QVBoxLayout(section);
    sectionLayout->setSpacing(2);
    sectionLayout->setContentsMargins(0, 0, 0, 0);
    sectionLayout->addWidget(titleLabel);
    
    return section;
}

void NodePaletteBar::addToolToLayout(QGridLayout* layout, const QString& name, const QIcon& icon, int row, int col)
{
    NodeToolButton* btn = new NodeToolButton(name, icon, this);
    connect(btn, &NodeToolButton::nodeClicked, this, &NodePaletteBar::onNodeClicked);
    layout->addWidget(btn, row, col);
}

void NodePaletteBar::onNodeClicked(const QString& nodeType)
{
    qDebug() << "NodePaletteBar: Node selected:" << nodeType;
    emit nodeSelected(nodeType);
}

void NodePaletteBar::addNodeType(const QString& category, const QString& nodeType, const QIcon& icon)
{
    // For now, add to the main layout - could be enhanced to find category section
    QWidget* customSection = createCategorySection(category);
    QGridLayout* customLayout = new QGridLayout(customSection);
    customLayout->setSpacing(2);
    
    addToolToLayout(customLayout, nodeType, icon, 0, 0);
    m_mainLayout->addWidget(customSection);
    
    qDebug() << "Added custom node type:" << nodeType << "to category:" << category;
}

void NodePaletteBar::addSeparator()
{
    QFrame* separator = new QFrame();
    separator->setFrameShape(QFrame::HLine);
    separator->setFrameShadow(QFrame::Sunken);
    separator->setStyleSheet("QFrame { color: #cccccc; }");
    m_mainLayout->addWidget(separator);
}

QIcon NodePaletteBar::createNodeIcon(const QString& nodeType)
{
    // Create a simple node-like icon
    QPixmap pixmap(24, 24);
    pixmap.fill(Qt::transparent);
    
    QPainter painter(&pixmap);
    painter.setRenderHint(QPainter::Antialiasing);
    
    // Draw a rounded rectangle representing a node
    painter.setBrush(QColor(220, 220, 240));
    painter.setPen(QPen(QColor(100, 100, 120), 1));
    painter.drawRoundedRect(2, 2, 20, 20, 3, 3);
    
    // Draw connection points (sockets)
    painter.setBrush(QColor(100, 100, 120));
    painter.setPen(Qt::NoPen);
    painter.drawEllipse(0, 10, 4, 4);  // Left socket
    painter.drawEllipse(20, 10, 4, 4); // Right socket
    
    return QIcon(pixmap);
}

QIcon NodePaletteBar::createTextIcon(const QString& text, const QColor& bgColor)
{
    QPixmap pixmap(24, 24);
    pixmap.fill(Qt::transparent);
    
    QPainter painter(&pixmap);
    painter.setRenderHint(QPainter::Antialiasing);
    painter.setRenderHint(QPainter::TextAntialiasing);
    
    // Draw background
    painter.setBrush(bgColor);
    painter.setPen(QPen(QColor(80, 80, 80), 1));
    painter.drawRoundedRect(1, 1, 22, 22, 3, 3);
    
    // Draw text
    painter.setPen(QColor(40, 40, 40));
    QFont font = painter.font();
    font.setPointSize(8);
    font.setBold(true);
    painter.setFont(font);
    
    painter.drawText(pixmap.rect(), Qt::AlignCenter, text);
    
    return QIcon(pixmap);
}

QIcon NodePaletteBar::createSocketIcon(int inputs, int outputs, const QColor& bgColor)
{
    QPixmap pixmap(32, 24);
    pixmap.fill(Qt::transparent);
    
    QPainter painter(&pixmap);
    painter.setRenderHint(QPainter::Antialiasing);
    
    // Draw main node body
    painter.setBrush(bgColor);
    painter.setPen(QPen(QColor(80, 80, 80), 1));
    painter.drawRoundedRect(6, 4, 20, 16, 2, 2);
    
    // Draw input sockets on the left
    painter.setBrush(QColor(60, 60, 60));
    painter.setPen(Qt::NoPen);
    for (int i = 0; i < inputs; ++i) {
        int y = 8 + (i * 8) - (inputs - 1) * 4;  // Center vertically
        painter.drawEllipse(2, y, 4, 4);
    }
    
    // Draw output sockets on the right
    for (int i = 0; i < outputs; ++i) {
        int y = 8 + (i * 8) - (outputs - 1) * 4;  // Center vertically
        painter.drawEllipse(26, y, 4, 4);
    }
    
    return QIcon(pixmap);
}

// ====================================
// FILE: node_palette_widget.cpp
// LAST MODIFIED: 2025-07-14 03:03:20
// ====================================

#include "node_palette_widget.h"
#include <QFont>
#include <QIcon>
#include <QDebug>
#include <QScrollArea>
#include <QGridLayout>
#include <QPainter>
#include <QMouseEvent>
#include <QToolButton>
#include <QSize>

// ============================================================================
// PaletteButton Implementation
// ============================================================================

PaletteButton::PaletteButton(const QString& iconAlias, 
                            const QString& tooltip, 
                            QWidget* parent)
    : QToolButton(parent)
{
    // Load icon from resource using alias
    QIcon icon(QStringLiteral(":/icons/%1").arg(iconAlias));
    setIcon(icon);
    setIconSize(QSize(24, 24));
    setToolTip(tooltip);
    
    // Apply consistent styling
    setupStyling();
}

void PaletteButton::setCheckable(bool checkable)
{
    QToolButton::setCheckable(checkable);
    if (checkable) {
        // Add checked state styling
        setStyleSheet(styleSheet() + 
                     "QToolButton:checked { "
                     "  background: #007acc; "
                     "  color: white; "
                     "}");
    }
}

void PaletteButton::setupStyling()
{
    setAutoRaise(true);
    setCursor(Qt::PointingHandCursor);
    setFixedSize(32, 32);
    
    // Apply CSS styling for hover states
    setStyleSheet(
        "QToolButton {"
        "  border: none;"
        "  border-radius: 4px;"
        "  padding: 4px;"
        "  background: transparent;"
        "}"
        "QToolButton:hover {"
        "  background: rgba(0, 0, 0, 0.08);"
        "}"
        "QToolButton:pressed {"
        "  background: rgba(0, 0, 0, 0.16);"
        "}"
    );
}

// ============================================================================
// NodePaletteWidget Implementation
// ============================================================================

NodePaletteWidget::NodePaletteWidget(QWidget* parent)
    : QWidget(parent)
    , m_mainLayout(nullptr)
    , m_searchEdit(nullptr)
    , m_scrollArea(nullptr)
    , m_scrollContent(nullptr)
    , m_gridLayout(nullptr)
    , m_titleLabel(nullptr)
{
    setupUI();
    populateNodeTemplates();
}

void NodePaletteWidget::setupUI()
{
    m_mainLayout = new QVBoxLayout(this);
    m_mainLayout->setContentsMargins(8, 8, 8, 8);
    m_mainLayout->setSpacing(6);
    
    // Title
    m_titleLabel = new QLabel("Node Palette", this);
    QFont titleFont = m_titleLabel->font();
    titleFont.setBold(true);
    titleFont.setPointSize(titleFont.pointSize() + 1);
    m_titleLabel->setFont(titleFont);
    m_titleLabel->setStyleSheet("QLabel { color: #2c3e50; margin-bottom: 4px; }");
    
    // Search box
    m_searchEdit = new QLineEdit(this);
    m_searchEdit->setPlaceholderText("Search nodes...");
    m_searchEdit->setStyleSheet(
        "QLineEdit {"
        "  border: 1px solid #bdc3c7;"
        "  border-radius: 4px;"
        "  padding: 6px 10px;"
        "  background: white;"
        "  font-size: 12px;"
        "}"
        "QLineEdit:focus {"
        "  border-color: #3498db;"
        "  outline: none;"
        "}"
    );
    
    // Scroll area for node grid
    m_scrollArea = new QScrollArea(this);
    m_scrollArea->setWidgetResizable(true);
    m_scrollArea->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_scrollArea->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
    m_scrollArea->setFrameShape(QFrame::NoFrame);
    
    // Content widget for the grid
    m_scrollContent = new QWidget();
    m_gridLayout = new QGridLayout(m_scrollContent);
    m_gridLayout->setContentsMargins(4, 4, 4, 4);
    m_gridLayout->setSpacing(6);
    
    m_scrollArea->setWidget(m_scrollContent);
    
    // Layout
    m_mainLayout->addWidget(m_titleLabel);
    m_mainLayout->addWidget(m_searchEdit);
    m_mainLayout->addWidget(m_scrollArea, 1);
    
    // Connections
    connect(m_searchEdit, &QLineEdit::textChanged, this, &NodePaletteWidget::filterChanged);
}

void NodePaletteWidget::populateNodeTemplates()
{
    // Add our self-serializing node types with visual icons
    
    NodeTemplate inputNode;
    inputNode.type = "IN";
    inputNode.name = "Input";
    inputNode.description = "Input node with configurable outputs";
    inputNode.iconPath = ""; // We'll create custom icons
    inputNode.inputSockets = 0;
    inputNode.outputSockets = 2;
    addNodeTemplate(inputNode);
    
    NodeTemplate outputNode;
    outputNode.type = "OUT";
    outputNode.name = "Output";
    outputNode.description = "Output node with configurable inputs";
    outputNode.iconPath = "";
    outputNode.inputSockets = 2;
    outputNode.outputSockets = 0;
    addNodeTemplate(outputNode);
    
    NodeTemplate processorNode;
    processorNode.type = "PROCESSOR";
    processorNode.name = "Processor";
    processorNode.description = "Processing node with inputs and outputs";
    processorNode.iconPath = "";
    processorNode.inputSockets = 2;
    processorNode.outputSockets = 2;
    addNodeTemplate(processorNode);
    
    qDebug() << "✓ Node palette populated with" << m_nodeTemplates.size() << "icon-based templates";
}

void NodePaletteWidget::addNodeTemplate(const NodeTemplate& nodeTemplate)
{
    m_nodeTemplates.append(nodeTemplate);
    
    // Create icon button for this node type
    NodeButton* button = new NodeButton(nodeTemplate, m_scrollContent);
    m_nodeButtons.append(button);
    
    // Connect button to our slot
    connect(button, &QPushButton::clicked, this, &NodePaletteWidget::onNodeButtonClicked);
    
    // Add to grid layout (2 columns)
    int row = m_nodeButtons.size() / 2;
    int col = (m_nodeButtons.size() - 1) % 2;
    m_gridLayout->addWidget(button, row, col);
}

void NodePaletteWidget::filterChanged(const QString& text)
{
    m_currentFilter = text;
    updateVisibility();
}

void NodePaletteWidget::onNodeButtonClicked()
{
    NodeButton* button = static_cast<NodeButton*>(sender());
    if (!button) return;
    
    NodeTemplate nodeTemplate = button->getNodeTemplate();
    qDebug() << "Node palette: Creating node" << nodeTemplate.name << "via button click";
    emit nodeCreationRequested(nodeTemplate);
}

void NodePaletteWidget::updateVisibility()
{
    for (NodeButton* button : m_nodeButtons) {
        bool visible = m_currentFilter.isEmpty() || button->matchesFilter(m_currentFilter);
        button->setVisible(visible);
    }
}

// ============================================================================
// NodeButton Implementation
// ============================================================================

NodePaletteWidget::NodeButton::NodeButton(const NodeTemplate& nodeTemplate, QWidget* parent)
    : QPushButton(parent)
    , m_nodeTemplate(nodeTemplate)
{
    setFixedSize(80, 80);
    setToolTip(QString("%1\n%2\nInputs: %3, Outputs: %4")
               .arg(nodeTemplate.name)
               .arg(nodeTemplate.description)
               .arg(nodeTemplate.inputSockets)
               .arg(nodeTemplate.outputSockets));
    
    // Create custom icon based on node type
    QIcon icon = NodeButton::createNodeIcon(nodeTemplate);
    setIcon(icon);
    setIconSize(QSize(48, 48));
    
    // Set text below icon
    setText(nodeTemplate.name);
    
    // Apply object name for external styling
    setObjectName("nodeButton");
}

bool NodePaletteWidget::NodeButton::matchesFilter(const QString& filter) const
{
    return m_nodeTemplate.name.contains(filter, Qt::CaseInsensitive) ||
           m_nodeTemplate.description.contains(filter, Qt::CaseInsensitive) ||
           m_nodeTemplate.type.contains(filter, Qt::CaseInsensitive);
}

QIcon NodePaletteWidget::NodeButton::createNodeIcon(const NodeTemplate& nodeTemplate)
{
    // Create a custom icon for each node type
    QPixmap pixmap(48, 48);
    pixmap.fill(Qt::transparent);
    
    QPainter painter(&pixmap);
    painter.setRenderHint(QPainter::Antialiasing);
    
    // Define colors for different node types
    QColor nodeColor;
    QString symbol;
    
    if (nodeTemplate.type == "IN") {
        nodeColor = QColor(46, 204, 113); // Green for input
        symbol = "IN";
    } else if (nodeTemplate.type == "OUT") {
        nodeColor = QColor(231, 76, 60); // Red for output
        symbol = "OUT";
    } else if (nodeTemplate.type == "PROCESSOR") {
        nodeColor = QColor(52, 152, 219); // Blue for processor
        symbol = "PROC";
    } else {
        nodeColor = QColor(149, 165, 166); // Gray for unknown
        symbol = "?";
    }
    
    // Draw node shape
    painter.setBrush(QBrush(nodeColor));
    painter.setPen(QPen(nodeColor.darker(120), 2));
    painter.drawRoundedRect(4, 4, 40, 40, 6, 6);
    
    // Draw text
    painter.setPen(Qt::white);
    painter.setFont(QFont("Arial", 8, QFont::Bold));
    painter.drawText(QRect(4, 4, 40, 40), Qt::AlignCenter, symbol);
    
    // Draw socket indicators
    painter.setBrush(QBrush(Qt::white));
    painter.setPen(QPen(Qt::darkGray, 1));
    
    // Input sockets (left side)
    int inputSpacing = nodeTemplate.inputSockets > 0 ? 32 / (nodeTemplate.inputSockets + 1) : 0;
    for (int i = 0; i < nodeTemplate.inputSockets; ++i) {
        int y = 8 + inputSpacing * (i + 1);
        painter.drawEllipse(0, y, 6, 6);
    }
    
    // Output sockets (right side)
    int outputSpacing = nodeTemplate.outputSockets > 0 ? 32 / (nodeTemplate.outputSockets + 1) : 0;
    for (int i = 0; i < nodeTemplate.outputSockets; ++i) {
        int y = 8 + outputSpacing * (i + 1);
        painter.drawEllipse(42, y, 6, 6);
    }
    
    return QIcon(pixmap);
}



// ====================================
// FILE: node_registry.cpp
// LAST MODIFIED: 2025-07-07 12:06:19
// ====================================

#include "node_registry.h"
#include "node.h"
#include <QDebug>

NodeRegistry& NodeRegistry::instance()
{
    static NodeRegistry registry;
    return registry;
}

void NodeRegistry::registerNode(const QString& typeName, NodeFactoryFunction factory)
{
    if (m_factories.contains(typeName)) {
        qWarning() << "NodeRegistry: Overwriting existing registration for type:" << typeName;
    }
    
    m_factories[typeName] = factory;
    qDebug() << "NodeRegistry: Registered node type:" << typeName;
}

Node* NodeRegistry::createNode(const QString& typeName) const
{
    auto it = m_factories.find(typeName);
    if (it != m_factories.end()) {
        Node* node = it.value()();
        if (node) {
            qDebug() << "NodeRegistry: Created node of type:" << typeName;
            return node;
        } else {
            qCritical() << "NodeRegistry: Factory function returned null for type:" << typeName;
        }
    } else {
        qWarning() << "NodeRegistry: Unknown node type requested:" << typeName;
        qDebug() << "Available types:" << getRegisteredTypes();
    }
    return nullptr;
}

bool NodeRegistry::isRegistered(const QString& typeName) const
{
    return m_factories.contains(typeName);
}

QStringList NodeRegistry::getRegisteredTypes() const
{
    return m_factories.keys();
}

void NodeRegistry::clear()
{
    qDebug() << "NodeRegistry: Clearing all registrations";
    m_factories.clear();
}

// ====================================
// FILE: node_tool_button.cpp
// LAST MODIFIED: 2025-07-14 09:08:51
// ====================================

#include "node_tool_button.h"
#include <QDebug>
#include <QDrag>
#include <QMimeData>
#include <QApplication>

NodeToolButton::NodeToolButton(const QString& type, const QIcon& icon, QWidget* parent)
    : QToolButton(parent)
    , m_nodeType(type)
{
    setIcon(icon);
    setIconSize(QSize(24, 24));         // Classic size for clear visibility
    setFixedSize(QSize(32, 32));        // Border padding around icon
    setToolTip(QString("Create %1 node").arg(type));
    setCheckable(false);
    
    updateButtonStyle();
    
    qDebug() << "✓ NodeToolButton created for type:" << type;
}

void NodeToolButton::mousePressEvent(QMouseEvent* event)
{
    if (event->button() == Qt::LeftButton) {
        m_dragStartPosition = event->pos();
    }
    QToolButton::mousePressEvent(event);
}

void NodeToolButton::mouseMoveEvent(QMouseEvent* event)
{
    if (!(event->buttons() & Qt::LeftButton))
        return;

    if ((event->pos() - m_dragStartPosition).manhattanLength()
         < QApplication::startDragDistance())
        return;

    startDrag();
}

void NodeToolButton::enterEvent(QEvent* event)
{
    QToolButton::enterEvent(event);
    setHoverStyle(true);
}

void NodeToolButton::leaveEvent(QEvent* event)
{
    QToolButton::leaveEvent(event);
    setHoverStyle(false);
}

void NodeToolButton::updateButtonStyle()
{
    setStyleSheet(
        "QToolButton {"
        "  background-color: #f5f5f5;"
        "  border: 1px solid #cccccc;"
        "  border-radius: 3px;"
        "  padding: 2px;"
        "}"
        "QToolButton:hover {"
        "  background-color: #e0e0e0;"
        "  border: 1px solid #999999;"
        "}"
        "QToolButton:pressed {"
        "  background-color: #d0d0d0;"
        "  border: 1px solid #666666;"
        "}"
    );
}

void NodeToolButton::setHoverStyle(bool hovered)
{
    // Additional hover feedback could be added here
    // For now, CSS handles the visual feedback
    Q_UNUSED(hovered);
}

void NodeToolButton::startDrag()
{
    qDebug() << "Starting drag for node type:" << m_nodeType;
    
    QDrag* drag = new QDrag(this);
    QMimeData* mimeData = new QMimeData;
    
    // Set the node type as mime data
    mimeData->setText(m_nodeType);
    mimeData->setData("application/x-nodetype", m_nodeType.toUtf8());
    drag->setMimeData(mimeData);
    
    // Use the button's icon as drag pixmap
    QPixmap dragPixmap = icon().pixmap(32, 32);
    if (dragPixmap.isNull()) {
        // Create a simple drag pixmap if no icon
        dragPixmap = QPixmap(32, 32);
        dragPixmap.fill(Qt::lightGray);
    }
    
    drag->setPixmap(dragPixmap);
    drag->setHotSpot(QPoint(16, 16));  // Center of the pixmap
    
    // Execute the drag operation
    Qt::DropAction dropAction = drag->exec(Qt::CopyAction);
    
    if (dropAction == Qt::CopyAction) {
        qDebug() << "✓ Node drag completed successfully";
    } else {
        qDebug() << "✗ Node drag cancelled or failed";
    }
}

// ====================================
// FILE: scene.cpp
// LAST MODIFIED: 2025-07-14 03:03:20
// ====================================

#include "scene.h"
#include "node.h"
#include "edge.h"
#include "socket.h"
#include <QDebug>
#include <QGraphicsPathItem>
#include <QTimer>

// Static flag definition for safe destruction
bool Scene::s_clearingGraph = false;

Scene::Scene(QObject* parent)
    : QGraphicsScene(parent)
    , m_ghostEdge(nullptr)
    , m_ghostFromSocket(nullptr)
    , m_ghostEdgeActive(false)
    , m_shutdownInProgress(false)
{
    setSceneRect(-1000, -1000, 2000, 2000);
}

// QElectroTech-style QHash implementation with SIMPLE_FIX logging
void Scene::addNode(Node* node)
{
    if (!node) return;
    
    QUuid nodeId = node->getId();
    m_nodes.insert(nodeId, node);
    addItem(node);
    
    // Node added to scene
    
    // Notify observers of node addition
    notifyNodeAdded(*node);
    
    // Emit signal for UI updates
    emit sceneChanged();
}

void Scene::addEdge(Edge* edge)
{
    if (!edge) return;
    
    QUuid edgeId = edge->getId();
    m_edges.insert(edgeId, edge);
    addItem(edge);
    
    // Edge added to scene
    
    // Notify observers of edge addition
    notifyEdgeAdded(*edge);
    
    // Emit signal for UI updates
    emit sceneChanged();
    
    // Clean design: edges manage their own socket connections via resolveConnections()
}

void Scene::addSocket(Socket* socket)
{
    if (!socket) return;
    
    // Clean design: sockets are managed by their parent nodes, not scene
    // Socket is automatically added to scene as child of parent node
}

void Scene::removeNode(const QUuid& nodeId)
{
    Node* node = m_nodes.value(nodeId, nullptr);
    if (!node) return;
    
    // Clean design: sockets are children of nodes - no separate tracking needed
    
    // Remove connected edges that reference this node
    QList<QUuid> edgesToRemove;
    QString nodeIdStr = nodeId.toString();
    for (Edge* edge : m_edges.values()) {
        if (edge->isConnectedToNode(nodeIdStr)) {
            edgesToRemove.append(edge->getId());
        }
    }
    
    // Clean up edges first (they may reference sockets)
    for (const QUuid& edgeId : edgesToRemove) {
        removeEdge(edgeId);
    }
    
    // Clean design: sockets cleaned up automatically as node children
    
    // Finally remove the node
    removeItem(node);
    m_nodes.remove(nodeId);
    delete node;
}

void Scene::removeEdge(const QUuid& edgeId)
{
    Edge* edge = m_edges.value(edgeId, nullptr);
    if (!edge) return;
    
    // Clean design: edges manage their own socket disconnection via direct pointers
    // Socket cleanup handled automatically when edge is destroyed
    
    // Remove from scene and registry
    removeItem(edge);
    m_edges.remove(edgeId);
    delete edge;
}

// Clean design: socket management methods removed - sockets handled by parent nodes

// O(1) UUID lookups
Node* Scene::getNode(const QUuid& nodeId) const
{
    return m_nodes.value(nodeId, nullptr);
}

Edge* Scene::getEdge(const QUuid& edgeId) const
{
    return m_edges.value(edgeId, nullptr);
}

void Scene::deleteNode(const QUuid& nodeId)
{
    Node* node = getNode(nodeId);
    if (!node) {
        qWarning() << "Scene::deleteNode - node not found:" << nodeId.toString(QUuid::WithoutBraces).left(8);
        return;
    }
    
    qDebug() << "Deleting node:" << nodeId.toString(QUuid::WithoutBraces).left(8);
    
    // First, find and delete all edges connected to this node
    QList<QUuid> edgesToDelete;
    for (auto it = m_edges.begin(); it != m_edges.end(); ++it) {
        Edge* edge = it.value();
        if (edge->isConnectedToNode(nodeId)) {
            edgesToDelete.append(it.key());
        }
    }
    
    // Delete connected edges
    for (const QUuid& edgeId : edgesToDelete) {
        deleteEdge(edgeId);
    }
    
    // Remove node from collections and scene
    m_nodes.remove(nodeId);
    removeItem(node);
    
    // Notify observers BEFORE deleting the node
    notifyNodeRemoved(nodeId);
    
    delete node;
    
    // Emit signal for UI updates
    emit sceneChanged();
    
    qDebug() << "Node deleted with" << edgesToDelete.size() << "connected edges - Observer notified";
}

void Scene::deleteEdge(const QUuid& edgeId)
{
    Edge* edge = getEdge(edgeId);
    if (!edge) {
        qWarning() << "Scene::deleteEdge - edge not found:" << edgeId.toString(QUuid::WithoutBraces).left(8);
        return;
    }
    
    // PHASE 1: Clean up socket connections before deletion (Edge destructor no longer does this)
    if (edge->getFromSocket()) {
        qDebug() << "DELETE_EDGE: Cleaning from-socket connections";
        edge->getFromSocket()->removeConnectedEdge(edge);
    }
    if (edge->getToSocket()) {
        qDebug() << "DELETE_EDGE: Cleaning to-socket connections";
        edge->getToSocket()->removeConnectedEdge(edge);
    }
    qDebug() << "DELETE_EDGE: Socket cleanup complete for edge" << edgeId.toString().left(8);
    
    // Remove from collection and scene
    m_edges.remove(edgeId);
    removeItem(edge);
    
    // Notify observers BEFORE deleting the edge
    notifyEdgeRemoved(edgeId);
    
    delete edge;
    
    // Emit signal for UI updates
    emit sceneChanged();
    
    qDebug() << "Edge deleted - Observer notified";
}

void Scene::deleteSelected()
{
    QList<QGraphicsItem*> selectedItems = this->selectedItems();
    if (selectedItems.isEmpty()) {
        qDebug() << "DELETE: No items selected";
        return;
    }
    
    qDebug() << "DELETE: Processing" << selectedItems.size() << "selected items";
    
    // PHASE 1: Safe deletion using typed registries (no casting)
    QSet<QUuid> selectedNodeIds;
    QSet<QUuid> selectedEdgeIds;

    for (QGraphicsItem* item : selectedItems) {
        if (item->type() == QGraphicsItem::UserType + 1) { // Edge
            for (auto it = m_edges.begin(); it != m_edges.end(); ++it) {
                if (it.value() == item) {
                    selectedEdgeIds.insert(it.key());
                    qDebug() << "DELETE: Found selected edge" << it.key().toString().left(8);
                    break;
                }
            }
        } else if (item->type() == QGraphicsItem::UserType + 2) { // Node
            for (auto it = m_nodes.begin(); it != m_nodes.end(); ++it) {
                if (it.value() == item) {
                    selectedNodeIds.insert(it.key());
                    qDebug() << "DELETE: Found selected node" << it.key().toString().left(8);
                    break;
                }
            }
        } else {
            qDebug() << "DELETE: Unknown item type" << item->type();
        }
    }

    // Delete edges first to prevent dangling socket references
    qDebug() << "DELETE: Removing" << selectedEdgeIds.size() << "edges first";
    for (const QUuid& edgeId : selectedEdgeIds) {
        deleteEdge(edgeId);
    }

    qDebug() << "DELETE: Removing" << selectedNodeIds.size() << "nodes second";
    for (const QUuid& nodeId : selectedNodeIds) {
        deleteNode(nodeId);
    }
    
    qDebug() << "DELETE: ✓ Completed - removed" << selectedEdgeIds.size() << "edges," << selectedNodeIds.size() << "nodes";
}

void Scene::clearGraph()
{
    qDebug() << "SIMPLE_FIX: Clearing graph - removing" << m_nodes.size() << "nodes and" << m_edges.size() << "edges";
    
    // PHASE 1.2: Use safe shutdown preparation
    prepareForShutdown();
    
    // CRITICAL FIX: Set global flag to prevent socket cleanup during destruction
    s_clearingGraph = true;
    
    // SIMPLE FIX: Clear registries SECOND to prevent dangling pointers
    // This prevents hash lookups during Qt's destruction sequence
    qDebug() << "SIMPLE_FIX: Clearing hash registries";
    m_nodes.clear();
    m_edges.clear();
    m_sockets.clear();  // Clear deprecated socket registry too
    
    // Then clear Qt graphics scene (safe now - no socket or hash references)
    qDebug() << "SIMPLE_FIX: Clearing Qt scene items";
    QGraphicsScene::clear();
    
    // Reset the clearing flag
    s_clearingGraph = false;
    
    // Notify observers of graph clearing
    notifyGraphCleared();
    
    // Emit signal for UI updates
    emit sceneChanged();
    
    qDebug() << "SIMPLE_FIX: ✓ Graph cleared safely - hash cleared before Qt cleanup";
}

// ============================================================================
// PHASE 1.2: Safe Shutdown Preparation
// ============================================================================

void Scene::prepareForShutdown()
{
    if (m_shutdownInProgress) {
        qDebug() << "SHUTDOWN: Already in progress, skipping";
        return;
    }
    
    qDebug() << "PHASE1: Shutdown preparation -" << m_edges.size() << "edges," << m_nodes.size() << "nodes";
    m_shutdownInProgress = true;
    
    // Step 1: Clean edge-socket connections BEFORE any destruction
    for (Edge* edge : m_edges.values()) {
        if (edge->getFromSocket()) {
            edge->getFromSocket()->removeConnectedEdge(edge);
        }
        if (edge->getToSocket()) {
            edge->getToSocket()->removeConnectedEdge(edge);
        }
    }
    
    // Step 2: Clear all socket connection sets
    for (Node* node : m_nodes.values()) {
        for (QGraphicsItem* child : node->childItems()) {
            if (Socket* socket = qgraphicsitem_cast<Socket*>(child)) {
                socket->clearAllConnections();
            }
        }
    }
    
    qDebug() << "PHASE1: ✓ Socket connections cleared safely";
}

// ============================================================================
// Ghost Edge Implementation for Right-Click Socket Connections
// ============================================================================

// IUnknown UUID for ghost edge identification
static const QUuid GHOST_EDGE_UUID = QUuid("{00000000-0000-0000-C000-000000000046}");

void Scene::startGhostEdge(Socket* fromSocket, const QPointF& startPos)
{
    if (m_ghostEdge) {
        removeItem(m_ghostEdge);
        delete m_ghostEdge;
    }
    
    m_ghostFromSocket = fromSocket;
    m_ghostEdge = new QGraphicsPathItem();
    m_ghostEdge->setZValue(-10); // Below all interactive items
    m_ghostEdge->setFlag(QGraphicsItem::ItemIsSelectable, false);
    m_ghostEdge->setAcceptedMouseButtons(Qt::NoButton);
    m_ghostEdge->setData(0, GHOST_EDGE_UUID); // IUnknown UUID marker
    m_ghostEdge->setPen(ghostPen());
    addItem(m_ghostEdge);
    m_ghostEdgeActive = true;
    
    updateGhostEdge(startPos);
    
    qDebug() << "GHOST: Started from socket" << fromSocket->getIndex() 
             << "(" << (fromSocket->getRole() == Socket::Input ? "Input" : "Output") << ")";
}

void Scene::updateGhostEdge(const QPointF& currentPos)
{
    if (!m_ghostEdge || !m_ghostFromSocket) return;
    
    QPointF start = m_ghostFromSocket->scenePos();
    QPainterPath path;
    path.moveTo(start);
    
    // Create curved ghost edge similar to real edges
    qreal dx = currentPos.x() - start.x();
    qreal controlOffset = qMin(qAbs(dx) * 0.5, 100.0);
    
    QPointF control1 = start + QPointF(controlOffset, 0);
    QPointF control2 = currentPos - QPointF(controlOffset, 0);
    path.cubicTo(control1, control2, currentPos);
    
    // Update ghost edge visual based on target validity
    QPen ghostPenCurrent = ghostPen();
    QGraphicsItem* itemUnderCursor = itemAt(currentPos, QTransform());
    Socket* targetSocket = qgraphicsitem_cast<Socket*>(itemUnderCursor);
    
    // Reset all socket visual states to normal first
    resetAllSocketStates();
    
    if (targetSocket) {
        // Check if this is a valid connection target
        bool isValidTarget = (targetSocket->getRole() == Socket::Input && 
                            targetSocket != m_ghostFromSocket &&
                            targetSocket->getParentNode() != m_ghostFromSocket->getParentNode());
        
        if (isValidTarget) {
            targetSocket->setVisualState(Socket::ValidTarget);
            ghostPenCurrent.setColor(QColor(0, 255, 0, 180)); // Green ghost edge
        } else {
            targetSocket->setVisualState(Socket::InvalidTarget);
            ghostPenCurrent.setColor(QColor(255, 0, 0, 180)); // Red ghost edge
        }
    } else {
        // No socket under cursor - default ghost edge color
        ghostPenCurrent.setColor(QColor(0, 255, 0, 150)); // Default green
    }
    
    m_ghostEdge->setPen(ghostPenCurrent);
    m_ghostEdge->setPath(path);
}

void Scene::resetAllSocketStates()
{
    // Reset all sockets to normal state when not being targeted
    for (Node* node : m_nodes.values()) {
        for (QGraphicsItem* child : node->childItems()) {
            if (Socket* socket = qgraphicsitem_cast<Socket*>(child)) {
                if (socket->getVisualState() == Socket::ValidTarget || 
                    socket->getVisualState() == Socket::InvalidTarget) {
                    socket->setVisualState(Socket::Normal);
                }
            }
        }
    }
}

void Scene::finishGhostEdge(Socket* toSocket)
{
    if (m_ghostFromSocket && toSocket) {
        // Validate connection roles
        if (m_ghostFromSocket->getRole() == Socket::Output && 
            toSocket->getRole() == Socket::Input) {
            
            // Create real edge using existing system
            Edge* newEdge = new Edge(QUuid::createUuid(), QUuid(), QUuid());
            
            Node* fromNode = m_ghostFromSocket->getParentNode();
            Node* toNode = toSocket->getParentNode();
            
            if (fromNode && toNode) {
                newEdge->setConnectionData(
                    fromNode->getId().toString(QUuid::WithoutBraces),
                    toNode->getId().toString(QUuid::WithoutBraces),
                    m_ghostFromSocket->getIndex(),
                    toSocket->getIndex()
                );
                
                addEdge(newEdge);
                newEdge->resolveConnections(this);
                
                // Brief success feedback - flash the connected sockets green
                m_ghostFromSocket->setVisualState(Socket::ValidTarget);
                toSocket->setVisualState(Socket::ValidTarget);
                QTimer::singleShot(300, [this, toSocket]() {
                    // Reset to normal appearance after brief success flash
                    if (m_ghostFromSocket) m_ghostFromSocket->setVisualState(Socket::Normal);
                    toSocket->setVisualState(Socket::Normal);
                });
                
                qDebug() << "GHOST: ✓ Created edge" << m_ghostFromSocket->getIndex() << "→" << toSocket->getIndex();
            }
        } else {
            qDebug() << "GHOST: ✗ Invalid connection - wrong socket roles";
        }
    }
    
    cancelGhostEdge();
}

void Scene::cancelGhostEdge()
{
    // Reset all socket visual states
    resetAllSocketStates();
    
    if (m_ghostEdge) {
        removeItem(m_ghostEdge);
        delete m_ghostEdge;
        m_ghostEdge = nullptr;
    }
    m_ghostFromSocket = nullptr;
    m_ghostEdgeActive = false;
    
    qDebug() << "GHOST: Cancelled";
}

QPen Scene::ghostPen() const
{
    QPen pen(QColor(0, 255, 0, 150)); // Semi-transparent green
    pen.setWidth(3);
    pen.setStyle(Qt::DashLine);
    pen.setDashPattern({8, 4});
    return pen;
}

void Scene::mouseMoveEvent(QGraphicsSceneMouseEvent* event)
{
    if (m_ghostEdgeActive) {
        updateGhostEdge(event->scenePos());
        event->accept();
        return;
    }
    QGraphicsScene::mouseMoveEvent(event);
}

void Scene::mouseReleaseEvent(QGraphicsSceneMouseEvent* event)
{
    if (m_ghostEdgeActive && event->button() == Qt::RightButton) {
        // Find socket under mouse
        QGraphicsItem* item = itemAt(event->scenePos(), QTransform());
        Socket* targetSocket = qgraphicsitem_cast<Socket*>(item);
        finishGhostEdge(targetSocket);
        event->accept();
        return;
    }
    QGraphicsScene::mouseReleaseEvent(event);
}

// ====================================
// FILE: socket.cpp
// LAST MODIFIED: 2025-07-14 03:03:20
// ====================================

#include "socket.h"
#include "node.h"
#include "edge.h"
#include "scene.h"
#include <QPainter>
#include <QGraphicsSceneMouseEvent>
#include <QDebug>

Socket::Socket(Role role, Node* parentNode, int index)
    : QGraphicsItem(parentNode)
    , m_role(role)
    , m_index(index)
    , m_connectedEdges()  // Initialize empty QSet
    , m_radius(12.0)
    , m_hovered(false)
    , m_visualState(Normal)
{
    setAcceptHoverEvents(true);
    setFlag(QGraphicsItem::ItemIsSelectable, true);
    updatePosition();
    
    // Register with parent node for O(1) lookups
    if (parentNode) {
        parentNode->registerSocket(this, m_index);
    }
    
    // Socket creation - keep minimal logging
}

Node* Socket::getParentNode() const
{
    return qgraphicsitem_cast<Node*>(parentItem());
}

QRectF Socket::boundingRect() const
{
    // Larger sockets for better usability and ghost edge interaction
    return QRectF(-10, -10, 20, 20);
}

void Socket::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
    Q_UNUSED(option)
    Q_UNUSED(widget)
    
    painter->setRenderHint(QPainter::Antialiasing);
    
    // Color-coded sockets like upper level system
    QColor socketColor;
    QColor borderColor;
    
    if (m_role == Input) {
        socketColor = QColor(100, 149, 237); // Cornflower blue
        borderColor = QColor(70, 130, 180);  // Steel blue
    } else {
        socketColor = QColor(220, 20, 60);    // Crimson red
        borderColor = QColor(178, 34, 34);    // Fire brick
    }
    
    // Apply visual state effects
    switch (m_visualState) {
        case Hovered:
            socketColor = socketColor.lighter(150);
            borderColor = borderColor.lighter(130);
            break;
        case ValidTarget:
            // Green glow effect for valid ghost edge target
            socketColor = QColor(100, 255, 100);  // Bright green
            borderColor = QColor(0, 200, 0);      // Green border
            break;
        case InvalidTarget:
            // Red glow effect for invalid ghost edge target
            socketColor = QColor(255, 100, 100);  // Bright red
            borderColor = QColor(200, 0, 0);      // Red border
            break;
        case Connected:
            // Subtle highlight for connected sockets
            borderColor = borderColor.lighter(120);
            break;
        case Normal:
        default:
            // Keep original colors
            break;
    }
    
    // Draw socket as rounded rectangle with better styling
    QRectF rect = boundingRect();
    
    // Add glow effect for target states
    if (m_visualState == ValidTarget || m_visualState == InvalidTarget) {
        QColor glowColor = (m_visualState == ValidTarget) ? QColor(0, 255, 0, 100) : QColor(255, 0, 0, 100);
        
        // Draw outer glow
        for (int i = 1; i <= 3; ++i) {
            QColor fadeColor = glowColor;
            fadeColor.setAlpha(glowColor.alpha() / (i * 2));
            painter->setPen(QPen(fadeColor, 2 + i));
            painter->setBrush(Qt::NoBrush);
            painter->drawRoundedRect(rect.adjusted(-i, -i, i, i), 3.0 + i, 3.0 + i);
        }
    }
    
    painter->setBrush(socketColor);
    painter->setPen(QPen(borderColor, 2));
    painter->drawRoundedRect(rect, 3.0, 3.0);
    
    // Draw socket index number with better contrast
    if (rect.width() > 8) { // Only draw index if socket is large enough
        painter->setPen(Qt::white);
        
        // Performance optimization: static font (created once, not every frame)
        static const QFont socketFont("Arial", 6, QFont::Bold);
        painter->setFont(socketFont);
        
        // Performance optimization: cache index string (created once, not every frame)
        if (m_cachedIndexString.isEmpty()) {
            m_cachedIndexString = QString::number(m_index);
        }
        painter->drawText(rect, Qt::AlignCenter, m_cachedIndexString);
    }
}

void Socket::mousePressEvent(QGraphicsSceneMouseEvent *event)
{
    if (event->button() == Qt::RightButton && m_role == Output) {
        // Start ghost edge from Output socket only
        Scene* scenePtr = qobject_cast<Scene*>(scene());
        if (scenePtr) {
            scenePtr->startGhostEdge(this, event->scenePos());
        }
        event->accept();
        return;
    }
    
    if (event->button() == Qt::LeftButton) {
        // TODO: Start edge creation drag
        event->accept();
    }
    QGraphicsItem::mousePressEvent(event);
}

void Socket::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)
{
    if (event->button() == Qt::LeftButton) {
        // TODO: Complete edge connection
        event->accept();
    }
    QGraphicsItem::mouseReleaseEvent(event);
}

void Socket::hoverEnterEvent(QGraphicsSceneHoverEvent *event)
{
    Q_UNUSED(event)
    m_hovered = true;
    if (m_visualState == Normal) {
        m_visualState = Hovered;
    }
    update();
}

void Socket::hoverLeaveEvent(QGraphicsSceneHoverEvent *event)
{
    Q_UNUSED(event)
    m_hovered = false;
    if (m_visualState == Hovered) {
        m_visualState = Normal;
    }
    update();
}

void Socket::setVisualState(VisualState state)
{
    if (m_visualState != state) {
        m_visualState = state;
        update();  // Trigger repaint with new visual state
    }
}

void Socket::updatePosition()
{
    Node* parent = getParentNode();
    if (!parent) return;
    
    QRectF nodeRect = parent->boundingRect();
    const qreal socketSpacing = 30.0;  // Increased spacing for better usability
    const qreal socketOffset = 3.0;    // Even closer to node edge
    
    // Count input and output sockets to calculate proper vertical positioning
    int inputCount = 0;
    int outputCount = 0;
    int myInputIndex = -1;
    int myOutputIndex = -1;
    
    // Find socket counts and my position within role
    for (QGraphicsItem* child : parent->childItems()) {
        if (Socket* socket = qgraphicsitem_cast<Socket*>(child)) {
            if (socket->getRole() == Socket::Input) {
                if (socket == this) myInputIndex = inputCount;
                inputCount++;
            } else {
                if (socket == this) myOutputIndex = outputCount;
                outputCount++;
            }
        }
    }
    
    if (m_role == Input) {
        // Input sockets on left side, centered vertically
        qreal totalInputHeight = (inputCount - 1) * socketSpacing;
        qreal startY = nodeRect.center().y() - totalInputHeight / 2.0;
        setPos(-socketOffset, startY + (myInputIndex * socketSpacing));
    } else {
        // Output sockets on right side, centered vertically  
        qreal totalOutputHeight = (outputCount - 1) * socketSpacing;
        qreal startY = nodeRect.center().y() - totalOutputHeight / 2.0;
        setPos(nodeRect.width() + socketOffset, startY + (myOutputIndex * socketSpacing));
    }
}

xmlNodePtr Socket::write(xmlDocPtr doc, xmlNodePtr repr) const
{
    Q_UNUSED(doc)
    Q_UNUSED(repr)
    // Sockets are written as part of their parent node
    return nullptr;
}

void Socket::read(xmlNodePtr node)
{
    Q_UNUSED(node)
    // Socket properties read from parent node's socket definitions
    updatePosition();
}


QPointF Socket::calculatePosition() const
{
    Node* parent = getParentNode();
    if (!parent) return QPointF(0, 0);
    
    QRectF nodeRect = parent->boundingRect();
    const qreal socketSpacing = 30.0;  // Increased spacing for better usability
    const qreal socketOffset = 3.0;    // Even closer to node edge
    
    // Count input and output sockets for proper centering
    int inputCount = 0;
    int outputCount = 0;
    int myInputIndex = -1;
    int myOutputIndex = -1;
    
    for (QGraphicsItem* child : parent->childItems()) {
        if (Socket* socket = qgraphicsitem_cast<Socket*>(child)) {
            if (socket->getRole() == Socket::Input) {
                if (socket == this) myInputIndex = inputCount;
                inputCount++;
            } else {
                if (socket == this) myOutputIndex = outputCount;
                outputCount++;
            }
        }
    }
    
    if (m_role == Input) {
        qreal totalInputHeight = (inputCount - 1) * socketSpacing;
        qreal startY = nodeRect.center().y() - totalInputHeight / 2.0;
        return QPointF(-socketOffset, startY + (myInputIndex * socketSpacing));
    } else {
        qreal totalOutputHeight = (outputCount - 1) * socketSpacing;
        qreal startY = nodeRect.center().y() - totalOutputHeight / 2.0;
        return QPointF(nodeRect.width() + socketOffset, startY + (myOutputIndex * socketSpacing));
    }
}

// ============================================================================
// Multi-Edge Connection Support (Patch Implementation)
// ============================================================================

void Socket::addConnectedEdge(Edge* edge)
{
    if (edge && !m_connectedEdges.contains(edge)) {
        m_connectedEdges.insert(edge);
        qDebug() << "SOCKET" << m_index << ": +Edge (" << m_connectedEdges.size() << "total)";
    }
}

void Socket::removeConnectedEdge(Edge* edge)
{
    if (!edge) return;
    
    if (m_connectedEdges.contains(edge)) {
        m_connectedEdges.remove(edge);
        qDebug() << "SOCKET" << m_index << ": -Edge (" << m_connectedEdges.size() << "remaining)";
    }
}

void Socket::clearAllConnections()
{
    if (!m_connectedEdges.isEmpty()) {
        qDebug() << "PHASE1: Socket emergency clear (" << m_connectedEdges.size() << "connections)";
        m_connectedEdges.clear();
    }
}

// Legacy compatibility methods - support existing code
void Socket::setConnectedEdge(Edge* edge)
{
    qWarning() << "setConnectedEdge() is deprecated - use addConnectedEdge()";
    if (edge) {
        addConnectedEdge(edge);
    }
}

Edge* Socket::getConnectedEdge() const
{
    if (m_connectedEdges.isEmpty()) {
        return nullptr;
    }
    // Return first edge for legacy compatibility
    return *m_connectedEdges.begin();
}

// ====================================
// FILE: test_destruction_safety.cpp
// LAST MODIFIED: 2025-07-13 09:25:30
// ====================================

#include <QtTest>
#include <QGraphicsScene>
#include <QDebug>
#include "node.h"
#include "edge.h"
#include "socket.h"
#include "scene.h"

/**
 * Test cases for built-in destruction safety
 * 
 * This tests the critical use-after-free vulnerability fix where
 * Edge destruction could access dangling Node pointers.
 */
class TestDestructionSafety : public QObject
{
    Q_OBJECT

private slots:
    void test_nodeDestroyedBeforeEdge();
    void test_edgeDestroyedBeforeNode();
    void test_massiveNodeEdgeDestruction();
    void test_crossConnectedNodeDestruction();

private:
    Scene* createTestScene();
    void verifyNoMemoryLeaks();
};

void TestDestructionSafety::test_nodeDestroyedBeforeEdge()
{
    qDebug() << "\n=== TEST: Node destroyed before Edge ===";
    
    Scene* scene = createTestScene();
    
    // Create two nodes and connect them
    Node* node1 = new Node(QUuid::createUuid(), QPointF(0, 0));
    Node* node2 = new Node(QUuid::createUuid(), QPointF(100, 0));
    
    node1->setNodeType("OUT");
    node1->setSocketCount(0, 1);  // 1 output
    node2->setNodeType("IN"); 
    node2->setSocketCount(1, 0);  // 1 input
    
    scene->addItem(node1);
    scene->addItem(node2);
    
    // Create edge
    Edge* edge = new Edge();
    edge->setResolvedSockets(node1->getSocketByIndex(0), node2->getSocketByIndex(0));
    scene->addItem(edge);
    
    qDebug() << "Created edge connecting two nodes";
    
    // Get the edge's view of the nodes BEFORE destruction
    Node* edgeFromNode = edge->getFromNode();
    Node* edgeToNode = edge->getToNode();
    
    QVERIFY(edgeFromNode == node1);
    QVERIFY(edgeToNode == node2);
    
    // CRITICAL TEST: Destroy node1 first, then check edge safety
    qDebug() << "Destroying node1 while edge still exists...";
    delete node1;  // This should call edge->onNodeDestroying(node1)
    
    // Edge should now return nullptr for the destroyed node
    QVERIFY(edge->getFromNode() == nullptr);  // Should be safe null
    QVERIFY(edge->getToNode() == node2);      // Should still be valid
    
    qDebug() << "Edge safely handled node1 destruction";
    
    // Clean up remaining objects
    delete edge;  // This should NOT crash when accessing destroyed node1
    delete node2;
    delete scene;
    
    qDebug() << "✓ Test passed - no use-after-free crash";
}

void TestDestructionSafety::test_edgeDestroyedBeforeNode()
{
    qDebug() << "\n=== TEST: Edge destroyed before Node ===";
    
    Scene* scene = createTestScene();
    
    // Create two nodes and connect them
    Node* node1 = new Node(QUuid::createUuid(), QPointF(0, 0));
    Node* node2 = new Node(QUuid::createUuid(), QPointF(100, 0));
    
    node1->setNodeType("OUT");
    node1->setSocketCount(0, 1);
    node2->setNodeType("IN");
    node2->setSocketCount(1, 0);
    
    scene->addItem(node1);
    scene->addItem(node2);
    
    Edge* edge = new Edge();
    edge->setResolvedSockets(node1->getSocketByIndex(0), node2->getSocketByIndex(0));
    scene->addItem(edge);
    
    qDebug() << "Created edge connecting two nodes";
    
    // CRITICAL TEST: Destroy edge first, then nodes
    qDebug() << "Destroying edge while nodes still exist...";
    delete edge;  // This should safely unregister from both nodes
    
    // Nodes should still be valid and not crash
    QVERIFY(!node1->isBeingDestroyed());
    QVERIFY(!node2->isBeingDestroyed());
    
    qDebug() << "Edge safely destroyed without affecting nodes";
    
    // Clean up nodes
    delete node1;  // Should not crash trying to notify destroyed edge
    delete node2;
    delete scene;
    
    qDebug() << "✓ Test passed - normal destruction order works";
}

void TestDestructionSafety::test_massiveNodeEdgeDestruction()
{
    qDebug() << "\n=== TEST: Massive node-edge destruction stress test ===";
    
    Scene* scene = createTestScene();
    QVector<Node*> nodes;
    QVector<Edge*> edges;
    
    // Create a grid of interconnected nodes
    const int gridSize = 10;
    qDebug() << "Creating" << gridSize << "x" << gridSize << "grid of nodes...";
    
    // Create nodes
    for (int i = 0; i < gridSize * gridSize; ++i) {
        Node* node = new Node(QUuid::createUuid(), QPointF(i % gridSize * 50, i / gridSize * 50));
        node->setNodeType("OUT");
        node->setSocketCount(2, 2);  // 2 inputs, 2 outputs each
        scene->addItem(node);
        nodes.append(node);
    }
    
    // Create edges connecting adjacent nodes
    for (int i = 0; i < gridSize; ++i) {
        for (int j = 0; j < gridSize; ++j) {
            int nodeIndex = i * gridSize + j;
            Node* currentNode = nodes[nodeIndex];
            
            // Connect to right neighbor
            if (j < gridSize - 1) {
                Node* rightNode = nodes[nodeIndex + 1];
                Edge* edge = new Edge();
                edge->setResolvedSockets(currentNode->getSocketByIndex(1), rightNode->getSocketByIndex(0));
                scene->addItem(edge);
                edges.append(edge);
            }
            
            // Connect to bottom neighbor
            if (i < gridSize - 1) {
                Node* bottomNode = nodes[nodeIndex + gridSize];
                Edge* edge = new Edge();
                edge->setResolvedSockets(currentNode->getSocketByIndex(3), bottomNode->getSocketByIndex(2));
                scene->addItem(edge);
                edges.append(edge);
            }
        }
    }
    
    qDebug() << "Created" << nodes.size() << "nodes and" << edges.size() << "edges";
    
    // STRESS TEST: Delete nodes in random order while edges exist
    qDebug() << "Randomly destroying nodes while edges exist...";
    QVector<int> nodeIndices;
    for (int i = 0; i < nodes.size(); ++i) {
        nodeIndices.append(i);
    }
    
    // Shuffle destruction order
    for (int i = 0; i < nodeIndices.size(); ++i) {
        int j = QRandomGenerator::global()->bounded(nodeIndices.size());
        nodeIndices.swapItemsAt(i, j);
    }
    
    // Delete first half of nodes randomly
    for (int i = 0; i < nodes.size() / 2; ++i) {
        int index = nodeIndices[i];
        if (nodes[index]) {
            delete nodes[index];
            nodes[index] = nullptr;
        }
    }
    
    qDebug() << "Destroyed half the nodes, checking edge safety...";
    
    // Verify edges handle the destroyed nodes safely
    int nullFromNodes = 0, nullToNodes = 0;
    for (Edge* edge : edges) {
        if (edge->getFromNode() == nullptr) nullFromNodes++;
        if (edge->getToNode() == nullptr) nullToNodes++;
    }
    
    qDebug() << "Edges with null fromNode:" << nullFromNodes;
    qDebug() << "Edges with null toNode:" << nullToNodes;
    
    QVERIFY(nullFromNodes > 0 || nullToNodes > 0);  // Should have some nulled nodes
    
    // Clean up remaining objects
    for (Edge* edge : edges) {
        delete edge;
    }
    for (Node* node : nodes) {
        if (node) delete node;
    }
    delete scene;
    
    qDebug() << "✓ Stress test passed - handled massive destruction safely";
}

void TestDestructionSafety::test_crossConnectedNodeDestruction()
{
    qDebug() << "\n=== TEST: Cross-connected node destruction ===";
    
    Scene* scene = createTestScene();
    
    // Create 4 nodes in a cross pattern: A connects to B and C, B connects to D
    Node* nodeA = new Node(QUuid::createUuid(), QPointF(0, 0));
    Node* nodeB = new Node(QUuid::createUuid(), QPointF(100, 0));
    Node* nodeC = new Node(QUuid::createUuid(), QPointF(0, 100));
    Node* nodeD = new Node(QUuid::createUuid(), QPointF(100, 100));
    
    nodeA->setNodeType("OUT");
    nodeA->setSocketCount(0, 2);  // 2 outputs
    nodeB->setNodeType("OUT");
    nodeB->setSocketCount(1, 1);  // 1 input, 1 output
    nodeC->setNodeType("IN");
    nodeC->setSocketCount(1, 0);  // 1 input
    nodeD->setNodeType("IN");
    nodeD->setSocketCount(1, 0);  // 1 input
    
    scene->addItem(nodeA);
    scene->addItem(nodeB);
    scene->addItem(nodeC);
    scene->addItem(nodeD);
    
    // Create cross connections
    Edge* edgeAB = new Edge();
    edgeAB->setResolvedSockets(nodeA->getSocketByIndex(0), nodeB->getSocketByIndex(0));
    scene->addItem(edgeAB);
    
    Edge* edgeAC = new Edge();
    edgeAC->setResolvedSockets(nodeA->getSocketByIndex(1), nodeC->getSocketByIndex(0));
    scene->addItem(edgeAC);
    
    Edge* edgeBD = new Edge();
    edgeBD->setResolvedSockets(nodeB->getSocketByIndex(1), nodeD->getSocketByIndex(0));
    scene->addItem(edgeBD);
    
    qDebug() << "Created cross-connected graph: A->B->D, A->C";
    
    // CRITICAL TEST: Delete the central node A first
    qDebug() << "Destroying central node A...";
    delete nodeA;  // Should notify edgeAB and edgeAC
    
    // Verify edges handle the destruction
    QVERIFY(edgeAB->getFromNode() == nullptr);  // A is gone
    QVERIFY(edgeAB->getToNode() == nodeB);      // B still valid
    QVERIFY(edgeAC->getFromNode() == nullptr);  // A is gone  
    QVERIFY(edgeAC->getToNode() == nodeC);      // C still valid
    QVERIFY(edgeBD->getFromNode() == nodeB);    // Unaffected
    QVERIFY(edgeBD->getToNode() == nodeD);      // Unaffected
    
    qDebug() << "All edges handled node A destruction safely";
    
    // Clean up
    delete edgeAB;
    delete edgeAC;
    delete edgeBD;
    delete nodeB;
    delete nodeC;
    delete nodeD;
    delete scene;
    
    qDebug() << "✓ Cross-connection test passed";
}

Scene* TestDestructionSafety::createTestScene()
{
    Scene* scene = new Scene();
    scene->setSceneRect(-500, -500, 1000, 1000);
    return scene;
}

void TestDestructionSafety::verifyNoMemoryLeaks()
{
    // In a real implementation, this would use valgrind or similar
    // For now, just verify we can create and destroy without crashes
    QVERIFY(true);
}

// Include the MOC generated file
#include "test_destruction_safety.moc"

QTEST_MAIN(TestDestructionSafety)

// ====================================
// FILE: tst_main.cpp
// LAST MODIFIED: 2025-07-14 08:28:45
// ====================================

#include "tst_main.h"
#include "node_registry.h"
#include <QtTest>
#include <QApplication>
#include <QDateTime>
#include <QDir>
#include <QFile>
#include <QTextStream>
#include <QDebug>
#include <QSysInfo>
#include <QTime>
#include <QFileInfo>

// ─── Test Summary Logging (concise, structured) ───────────────────────────
static QTextStream* testSummaryStream = nullptr;

static void setupLogging()
{
    QDir{"logs"}.mkpath(".");
    const QString logFileName =
        QStringLiteral("logs/TestSummary_%1.log")
        .arg(QDateTime::currentDateTime().toString("yyyy-MM-dd_hh-mm-ss"));

    static QFile summaryFile(logFileName);
    summaryFile.open(QIODevice::WriteOnly | QIODevice::Append);
    testSummaryStream = new QTextStream(&summaryFile);
    
    // Write test session header
    *testSummaryStream << "=== NodeGraph Test Summary ===" << Qt::endl;
    *testSummaryStream << "Date: " << QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss") << Qt::endl;
    *testSummaryStream << "Platform: " << QSysInfo::productType() << " " << QSysInfo::productVersion() << Qt::endl;
    *testSummaryStream << Qt::endl;
    testSummaryStream->flush();
    
    // Disable verbose Qt logging during tests
    qInstallMessageHandler([](QtMsgType type, const QMessageLogContext &, const QString &msg) {
        // Only log critical errors to avoid noise
        if (type == QtCriticalMsg || type == QtFatalMsg) {
            if (testSummaryStream) {
                *testSummaryStream << "ERROR: " << msg << Qt::endl;
                testSummaryStream->flush();
            }
        }
    });
    
    qInfo().noquote() << "Test summary logging to:" << logFileName;
}

// Test summary helper
static void logTestSummary(const QString& message)
{
    if (testSummaryStream) {
        *testSummaryStream << QTime::currentTime().toString("hh:mm:ss") << " | " << message << Qt::endl;
        testSummaryStream->flush();
    }
}
// ───────────────────────────────────────────────────────

void tst_Main::initTestCase()
{
    setupLogging();  // Enable file logging early
    qDebug() << "=== NodeGraph Main Test Suite ===";
    qDebug() << "Initializing test case...";
    
    m_app = nullptr;
    m_testScene = nullptr;
    m_factory = nullptr;
    m_xmlDoc = nullptr;
    
    qDebug() << "✓ Test case initialized";
}

void tst_Main::cleanupTestCase()
{
    qDebug() << "Cleaning up test case...";
    cleanupEnvironment();
    qInfo().noquote() << "=== TEST RUN FINISHED ===";
    qDebug() << "✓ Test case cleaned up";
}

void tst_Main::init()
{
    qDebug() << "\n--- Setting up test environment ---";
    QVERIFY(setupEnvironment());
    qDebug() << "✓ Test environment ready";
}

void tst_Main::cleanup()
{
    qDebug() << "--- Cleaning up test environment ---";
    cleanupEnvironment();
    qDebug() << "✓ Test environment cleaned up";
}

bool tst_Main::setupEnvironment()
{
    qDebug() << "Setting up test environment...";
    
    // Step 1: Create XML document for factory
    qDebug() << "  Creating XML document...";
    m_xmlDoc = xmlNewDoc(BAD_CAST "1.0");
    if (!m_xmlDoc) {
        qCritical() << "  FAILED: Could not create XML document";
        return false;
    }
    qDebug() << "  ✓ XML document created";
    
    // Step 2: Create root graph element
    qDebug() << "  Creating root graph element...";
    xmlNodePtr root = xmlNewNode(nullptr, BAD_CAST "graph");
    if (!root) {
        qCritical() << "  FAILED: Could not create root graph element";
        xmlFreeDoc(m_xmlDoc);
        m_xmlDoc = nullptr;
        return false;
    }
    xmlDocSetRootElement(m_xmlDoc, root);
    qDebug() << "  ✓ Root graph element created";
    
    // Step 3: Create test scene
    qDebug() << "  Creating test scene...";
    m_testScene = new Scene();
    if (!m_testScene) {
        qCritical() << "  FAILED: Could not create Scene";
        xmlFreeDoc(m_xmlDoc);
        m_xmlDoc = nullptr;
        return false;
    }
    qDebug() << "  ✓ Scene created - initial nodes:" << m_testScene->getNodes().size() 
             << "edges:" << m_testScene->getEdges().size();
    
    // Step 4: Create GraphFactory
    qDebug() << "  Creating GraphFactory...";
    m_factory = new GraphFactory(m_testScene, m_xmlDoc);
    if (!m_factory) {
        qCritical() << "  FAILED: Could not create GraphFactory";
        delete m_testScene;
        m_testScene = nullptr;
        xmlFreeDoc(m_xmlDoc);
        m_xmlDoc = nullptr;
        return false;
    }
    qDebug() << "  ✓ GraphFactory created";
    
    // Step 5: Validate setup
    qDebug() << "  Validating setup...";
    if (!validateSceneSetup()) {
        qCritical() << "  FAILED: Scene setup validation failed";
        return false;
    }
    
    qDebug() << "✓ Test environment setup complete";
    return true;
}

void tst_Main::cleanupEnvironment()
{
    if (m_factory) {
        delete m_factory;
        m_factory = nullptr;
    }
    
    if (m_testScene) {
        delete m_testScene;
        m_testScene = nullptr;
    }
    
    if (m_xmlDoc) {
        xmlFreeDoc(m_xmlDoc);
        m_xmlDoc = nullptr;
    }
}

bool tst_Main::validateSceneSetup()
{
    if (!m_testScene) {
        qCritical() << "    Scene is null";
        return false;
    }
    
    if (!m_factory) {
        qCritical() << "    Factory is null";
        return false;
    }
    
    if (!m_xmlDoc) {
        qCritical() << "    XML document is null";
        return false;
    }
    
    // Check that scene is properly initialized
    const auto& nodes = m_testScene->getNodes();
    const auto& edges = m_testScene->getEdges();
    
    qDebug() << "    Scene validation: nodes=" << nodes.size() << "edges=" << edges.size();
    
    return true;
}

Node* tst_Main::createNode(const QString& type)
{
    qDebug() << "Creating node of type:" << type;
    
    Node* node = m_factory->createNode("node", QPointF(100, 100));
    if (!node) {
        qDebug() << "Factory failed to create node";
        return nullptr;
    }
    
    qDebug() << "Node created with ID:" << node->getId().toString(QUuid::WithoutBraces).left(8);
    
    // Ensure proper socket initialization based on type
    if (type == "OUT") {
        qDebug() << "Creating OUT node with 0 inputs, 1 output";
        node->createSocketsFromXml(0, 1);  // 0 inputs, 1 output
    } else if (type == "IN") {
        qDebug() << "Creating IN node with 1 input, 0 outputs";
        node->createSocketsFromXml(1, 0);  // 1 input, 0 outputs
    } else {
        qDebug() << "Creating default node with 1 input, 1 output";
        node->createSocketsFromXml(1, 1);  // Default: 1 input, 1 output
    }
    
    node->setNodeType(type);
    
    qDebug() << "Node has" << node->getSocketCount() << "sockets";
    
    return node;
}

void tst_Main::testCreateNode()
{
    qDebug() << "\n=== Testing Basic Node Creation ===";
    
    // Test creating nodes directly (bypass factory/registry for now)
    Node* outNode = new Node();
    outNode->setNodeType("OUT");
    outNode->createSocketsFromXml(0, 1);  // 0 inputs, 1 output
    m_testScene->addNode(outNode);
    
    QVERIFY(outNode != nullptr);
    QCOMPARE(outNode->getNodeType(), QString("OUT"));
    QVERIFY(!outNode->getId().isNull());
    QCOMPARE(outNode->getSocketCount(), 1);
    
    Node* inNode = new Node();
    inNode->setNodeType("IN");
    inNode->createSocketsFromXml(1, 0);  // 1 input, 0 outputs
    m_testScene->addNode(inNode);
    
    QVERIFY(inNode != nullptr);
    QCOMPARE(inNode->getNodeType(), QString("IN"));
    QVERIFY(!inNode->getId().isNull());
    QCOMPARE(inNode->getSocketCount(), 1);
    
    // Verify scene has correct node count
    QCOMPARE(m_testScene->getNodes().size(), 2);
    
    qDebug() << "✓ Basic node creation works";
    
    // Test edge creation and connection
    qDebug() << "\n=== Testing Edge System ===";
    
    // Create edge using factory method
    Edge* edge = m_factory->createEdge(outNode, 0, inNode, 0);
    QVERIFY(edge != nullptr);
    
    qDebug() << "Edge created with ID:" << edge->getId().toString(QUuid::WithoutBraces).left(8);
    
    // Test edge resolution
    bool resolved = edge->resolveConnections(m_testScene);
    if (resolved) {
        qDebug() << "✓ Edge resolution successful";
        QVERIFY(resolved);
    } else {
        qDebug() << "✗ Edge resolution failed";
        QVERIFY(resolved);  // This will fail and show the issue
    }
    
    // Verify scene has the edge
    QCOMPARE(m_testScene->getEdges().size(), 1);
    
    qDebug() << "✓ Edge system test passed";
}

void tst_Main::testFactoryNodeCreation()
{
    qDebug() << "\n=== Testing Factory/Registry Node Creation ===";
    
    // First register node types (this should be moved to a shared function)
    NodeRegistry::instance().registerNode("IN", []() { 
        Node* node = new Node(); 
        node->setNodeType("IN"); 
        return node; 
    });
    NodeRegistry::instance().registerNode("OUT", []() { 
        Node* node = new Node(); 
        node->setNodeType("OUT"); 
        return node; 
    });
    
    qDebug() << "Registered node types:" << NodeRegistry::instance().getRegisteredTypes();
    
    // Test factory node creation with proper XML structure  
    Node* outNode = m_factory->createNode("OUT", QPointF(100, 100), 0, 1);
    QVERIFY(outNode != nullptr);
    QCOMPARE(outNode->getNodeType(), QString("OUT"));
    QCOMPARE(outNode->getSocketCount(), 1);
    
    Node* inNode = m_factory->createNode("IN", QPointF(200, 100), 1, 0);
    QVERIFY(inNode != nullptr);
    QCOMPARE(inNode->getNodeType(), QString("IN"));
    QCOMPARE(inNode->getSocketCount(), 1);
    
    // Test edge creation through factory
    Edge* edge = m_factory->createEdge(outNode, 0, inNode, 0);
    QVERIFY(edge != nullptr);
    
    // Test edge resolution
    QVERIFY(edge->resolveConnections(m_testScene));
    
    qDebug() << "✓ Factory/Registry system working";
}

void tst_Main::testXmlLoadSave()
{
    qDebug() << "\n=== Testing XML Load/Save Round-Trip ===";
    
    // Register node types
    NodeRegistry::instance().registerNode("IN", []() { 
        Node* node = new Node(); 
        node->setNodeType("IN"); 
        return node; 
    });
    NodeRegistry::instance().registerNode("OUT", []() { 
        Node* node = new Node(); 
        node->setNodeType("OUT"); 
        return node; 
    });
    
    // Get test data directory from environment variable
    QString testDataPath = qgetenv("NODEGRAPH_TEST_DATA");
    if (testDataPath.isEmpty()) {
        testDataPath = "..";  // fallback to parent directory
        qDebug() << "NODEGRAPH_TEST_DATA not set, using fallback:" << testDataPath;
    } else {
        qDebug() << "Using test data path from environment:" << testDataPath;
    }
    
    // Test loading available XML files
    QStringList testFiles = {"tests_tiny.xml", "tests_small.xml", "tests_medium.xml"};
    QString testFile;
    
    // Find first available test file in the specified directory
    for (const QString& candidate : testFiles) {
        QString fullPath = QDir(testDataPath).absoluteFilePath(candidate);
        if (QFile::exists(fullPath)) {
            testFile = fullPath;
            break;
        }
    }
    
    qDebug() << "Loading test file:" << (testFile.isEmpty() ? "none found" : testFile);
    
    bool loaded = false;
    if (!testFile.isEmpty()) {
        loaded = m_factory->loadFromXmlFile(testFile);
    }
    
    if (!loaded) {
        qDebug() << "No test file available, creating minimal test instead";
        // Create a minimal graph for testing
        Node* node1 = m_factory->createNode("OUT", QPointF(100, 100), 0, 1);
        Node* node2 = m_factory->createNode("IN", QPointF(200, 100), 1, 0);
        Edge* edge = m_factory->createEdge(node1, 0, node2, 0);
        QVERIFY(node1 && node2 && edge);
    } else {
        qDebug() << "✓ Successfully loaded test file";
    }
    
    // Check scene has content
    int nodeCount = m_testScene->getNodes().size();
    int edgeCount = m_testScene->getEdges().size();
    qDebug() << "Loaded graph: " << nodeCount << "nodes," << edgeCount << "edges";
    
    QVERIFY(nodeCount > 0);
    
    qDebug() << "✓ XML loading test passed";
}

void tst_Main::testCompleteWorkflow()
{
    qDebug() << "\n=== Testing Complete Workflow ===";
    
    // Register node types
    NodeRegistry::instance().registerNode("IN", []() { 
        Node* node = new Node(); 
        node->setNodeType("IN"); 
        return node; 
    });
    NodeRegistry::instance().registerNode("OUT", []() { 
        Node* node = new Node(); 
        node->setNodeType("OUT"); 
        return node; 
    });
    
    // Step 1: Create a test graph
    qDebug() << "Step 1: Creating test graph...";
    Node* sourceNode = m_factory->createNode("OUT", QPointF(50, 50), 0, 1);
    Node* middleNode = m_factory->createNode("OUT", QPointF(150, 50), 1, 1);  
    Node* sinkNode = m_factory->createNode("IN", QPointF(250, 50), 1, 0);
    
    QVERIFY(sourceNode && middleNode && sinkNode);
    
    Edge* edge1 = m_factory->createEdge(sourceNode, 0, middleNode, 0);
    Edge* edge2 = m_factory->createEdge(middleNode, 1, sinkNode, 0);
    
    QVERIFY(edge1 && edge2);
    
    // Resolve all connections
    QVERIFY(edge1->resolveConnections(m_testScene));
    QVERIFY(edge2->resolveConnections(m_testScene));
    
    // Step 2: Verify initial state
    QCOMPARE(m_testScene->getNodes().size(), 3);
    QCOMPARE(m_testScene->getEdges().size(), 2);
    
    qDebug() << "✓ Test graph created successfully";
    qDebug() << "✓ Complete workflow test passed";
}

// XML Performance Tests - data-driven
void tst_Main::testXmlPerformance()
{
    logTestSummary("=== XML PERFORMANCE TESTS START ===");
    
    // Get test data directory from environment variable
    QString testDataPath = qgetenv("NODEGRAPH_TEST_DATA");
    if (testDataPath.isEmpty()) {
        testDataPath = "..";  // fallback to parent directory
    }
    logTestSummary(QString("Test data path: %1").arg(testDataPath));
    
    // Test files with expected approximate node counts (exclude large files for regular testing)
    QList<QPair<QString, QString>> testCases = {
        {"tests_tiny.xml", "Tiny (10 nodes)"},
        {"tests_small.xml", "Small (100 nodes)"},
        {"tests_medium.xml", "Medium (500 nodes)"}
        // Skip large files: they're too slow for regular testing
        // {"tests_large.xml", "Large (1000 nodes)"},
        // {"tests_stress.xml", "Stress (5000 nodes)"}
    };
    
    int testsRun = 0;
    for (const auto& testCase : testCases) {
        QString fullPath = QDir(testDataPath).absoluteFilePath(testCase.first);
        if (QFile::exists(fullPath)) {
            performXmlLoadTest(fullPath, testCase.second);
            testsRun++;
        } else {
            logTestSummary(QString("SKIP: %1 - file not found").arg(testCase.second));
        }
    }
    
    if (testsRun == 0) {
        logTestSummary("ERROR: No XML test files found for performance testing");
        QSKIP("No XML test files found for performance testing");
    } else {
        logTestSummary(QString("COMPLETE: %1 performance tests executed").arg(testsRun));
    }
}

// XML Dynamic Update Tests
void tst_Main::testNodePositionToXml()
{
    qDebug() << "\n=== Testing Node Position → XML Sync ===";
    QVERIFY(setupEnvironment());
    
    // Create a node at initial position
    auto node = m_factory->createNode("OUT", QPointF(100, 100), 0, 1);
    QVERIFY(node != nullptr);
    
    QUuid nodeId = node->getId();
    qDebug() << "Created node at (100, 100)";
    
    // Move the node to a new position
    QPointF newPos(250, 150);
    node->setPos(newPos);
    qDebug() << "Moved node to" << newPos;
    
    // Verify the node position was updated by checking node directly
    QPointF actualPos = node->pos();
    bool positionMatches = (actualPos.x() == newPos.x()) && (actualPos.y() == newPos.y());
    
    if (positionMatches) {
        qDebug() << "✓ Node position correctly updated to" << actualPos;
    } else {
        qDebug() << "✗ Node position mismatch. Expected:" << newPos << "Actual:" << actualPos;
    }
    
    QVERIFY(positionMatches);
    
    // TODO: Add XML serialization verification when save method is available
    qDebug() << "✓ Node position modification test passed";
}

void tst_Main::testEdgeModificationToXml()
{
    qDebug() << "\n=== Testing Edge Modifications → XML Sync ===";
    QVERIFY(setupEnvironment());
    
    // Create two nodes
    auto node1 = m_factory->createNode("OUT", QPointF(100, 100), 0, 1);
    auto node2 = m_factory->createNode("IN", QPointF(200, 100), 1, 0);
    QVERIFY(node1 && node2);
    
    QUuid node1Id = node1->getId();
    QUuid node2Id = node2->getId();
    
    // Check initial edge count in scene
    int edgeCountBefore = m_testScene->getEdges().size();
    qDebug() << "Initial edge count:" << edgeCountBefore;
    
    // Create an edge
    auto edge = m_factory->createEdge(node1, 0, node2, 0);
    QVERIFY(edge != nullptr);
    QVERIFY(edge->resolveConnections(m_testScene));
    
    // Verify edge appears in scene
    int edgeCountAfter = m_testScene->getEdges().size();
    qDebug() << "After adding edge:" << edgeCountAfter;
    
    QVERIFY(edgeCountAfter > edgeCountBefore);
    
    // Verify edge connection is correct
    bool edgeFound = false;
    for (auto it = m_testScene->getEdges().begin(); it != m_testScene->getEdges().end(); ++it) {
        Edge* sceneEdge = it.value();
        if (sceneEdge->isConnectedToNode(node1Id) && sceneEdge->isConnectedToNode(node2Id)) {
            edgeFound = true;
            break;
        }
    }
    
    if (edgeFound) {
        qDebug() << "✓ Edge correctly connects the two nodes";
    } else {
        qDebug() << "✗ Edge connection not found in scene";
    }
    
    QVERIFY(edgeFound);
    
    // TODO: Add XML serialization verification when save method is available  
    qDebug() << "✓ Edge modification test passed";
}

// Performance Test Helpers
void tst_Main::performXmlLoadTest(const QString& filename, const QString& testName)
{
    logTestSummary(QString("TEST: %1").arg(testName));
    QVERIFY(setupEnvironment());
    
    // Measure load time and track batch mode
    QElapsedTimer totalTimer;
    totalTimer.start();
    
    qint64 loadTime = measureXmlLoadTime(filename);
    qint64 totalTime = totalTimer.elapsed();
    
    // Get loaded graph stats
    int nodeCount = m_testScene->getNodes().size();
    int edgeCount = m_testScene->getEdges().size();
    
    // Log structured summary
    logTestSummary(QString("RESULT: %1 | Nodes: %2 | Edges: %3 | Load: %4ms | Total: %5ms")
                    .arg(testName)
                    .arg(nodeCount)
                    .arg(edgeCount)
                    .arg(loadTime)
                    .arg(totalTime));
    
    // Performance assertions - skip large files in regular testing
    if (nodeCount > 1000) {
        logTestSummary(QString("SKIP_PERF: %1 nodes too large for timing validation").arg(nodeCount));
        return;
    }
    
    // Check edge resolution success rate
    int expectedEdges = qMax(0, nodeCount - 1);  // Rough estimate for chain topology
    float edgeSuccessRate = expectedEdges > 0 ? (float)edgeCount / expectedEdges * 100 : 100;
    logTestSummary(QString("EDGES: %1/%2 connected (%.1f%% success)")
                    .arg(edgeCount).arg(expectedEdges).arg(edgeSuccessRate));
    
    QVERIFY(loadTime < 5000);  // Should load <1000 nodes within 5 seconds
    if (nodeCount == 0) {
        logTestSummary("WARNING: No nodes loaded from file");
    }
}

qint64 tst_Main::measureXmlLoadTime(const QString& filename)
{
    // Register node types
    NodeRegistry::instance().registerNode("IN", []() { 
        Node* node = new Node(); 
        node->setNodeType("IN"); 
        return node; 
    });
    NodeRegistry::instance().registerNode("OUT", []() { 
        Node* node = new Node(); 
        node->setNodeType("OUT"); 
        return node; 
    });
    
    logTestSummary(QString("LOAD_START: %1").arg(QFileInfo(filename).baseName()));
    
    QElapsedTimer timer;
    timer.start();
    
    // Load the XML file (will use batch mode optimization)
    bool success = m_factory->loadFromXmlFile(filename);
    
    qint64 elapsed = timer.elapsed();
    
    if (!success) {
        logTestSummary(QString("LOAD_FAILED: %1").arg(QFileInfo(filename).baseName()));
        return elapsed;
    }
    
    logTestSummary(QString("LOAD_SUCCESS: %1 in %2ms").arg(QFileInfo(filename).baseName()).arg(elapsed));
    return elapsed;
}

void tst_Main::validateLoadedGraph(int expectedNodes, int expectedEdges)
{
    int actualNodes = m_testScene->getNodes().size();
    int actualEdges = m_testScene->getEdges().size();
    
    qDebug() << QString("Graph validation: %1/%2 nodes, %3/%4 edges")
                .arg(actualNodes).arg(expectedNodes)
                .arg(actualEdges).arg(expectedEdges);
    
    QVERIFY(actualNodes >= expectedNodes * 0.8); // Allow 20% variance
    QVERIFY(actualEdges >= 0); // At least some edges should connect
}

// ============================================================================
// Built-in Destruction Safety Tests
// ============================================================================

void tst_Main::test_nodeDestroyedBeforeEdge()
{
    logTestSummary("SAFETY_TEST: Node destroyed before Edge");
    
    // Create two nodes and connect them
    Node* node1 = new Node(QUuid::createUuid(), QPointF(0, 0));
    Node* node2 = new Node(QUuid::createUuid(), QPointF(100, 0));
    
    node1->setNodeType("OUT");
    node1->createSocketsFromXml(0, 1);  // 1 output
    node2->setNodeType("IN"); 
    node2->createSocketsFromXml(1, 0);  // 1 input
    
    m_testScene->addItem(node1);
    m_testScene->addItem(node2);
    
    // Create edge
    Edge* edge = new Edge();
    edge->setResolvedSockets(node1->getSocketByIndex(0), node2->getSocketByIndex(0));
    m_testScene->addItem(edge);
    
    // Verify initial state
    QVERIFY(edge->getFromNode() == node1);
    QVERIFY(edge->getToNode() == node2);
    
    // CRITICAL TEST: Destroy node1 first, then check edge safety
    delete node1;  // This should call edge->onNodeDestroying(node1)
    
    // Edge should now return nullptr for the destroyed node
    QVERIFY(edge->getFromNode() == nullptr);  // Should be safe null
    QVERIFY(edge->getToNode() == node2);      // Should still be valid
    
    // Clean up remaining objects - should NOT crash
    delete edge;  
    delete node2;
    
    logTestSummary("SAFETY_TEST: ✓ Node destruction safety verified");
}

void tst_Main::test_edgeDestroyedBeforeNode()
{
    logTestSummary("SAFETY_TEST: Edge destroyed before Node");
    
    // Create two nodes and connect them
    Node* node1 = new Node(QUuid::createUuid(), QPointF(0, 0));
    Node* node2 = new Node(QUuid::createUuid(), QPointF(100, 0));
    
    node1->setNodeType("OUT");
    node1->createSocketsFromXml(0, 1);
    node2->setNodeType("IN");
    node2->createSocketsFromXml(1, 0);
    
    m_testScene->addItem(node1);
    m_testScene->addItem(node2);
    
    Edge* edge = new Edge();
    edge->setResolvedSockets(node1->getSocketByIndex(0), node2->getSocketByIndex(0));
    m_testScene->addItem(edge);
    
    // CRITICAL TEST: Destroy edge first, then nodes
    delete edge;  // This should safely unregister from both nodes
    
    // Nodes should still be valid and not crash
    QVERIFY(!node1->isBeingDestroyed());
    QVERIFY(!node2->isBeingDestroyed());
    
    // Clean up nodes - should not crash trying to notify destroyed edge
    delete node1;  
    delete node2;
    
    logTestSummary("SAFETY_TEST: ✓ Edge destruction safety verified");
}

void tst_Main::test_massDestructionStress()
{
    logTestSummary("SAFETY_TEST: Mass destruction stress test");
    
    QVector<Node*> nodes;
    QVector<Edge*> edges;
    
    // Create a grid of interconnected nodes
    const int gridSize = 5;  // Smaller for test performance
    
    // Create nodes
    for (int i = 0; i < gridSize * gridSize; ++i) {
        Node* node = new Node(QUuid::createUuid(), QPointF(i % gridSize * 50, i / gridSize * 50));
        node->setNodeType("OUT");
        node->createSocketsFromXml(2, 2);  // 2 inputs, 2 outputs each
        m_testScene->addItem(node);
        nodes.append(node);
    }
    
    // Create edges connecting adjacent nodes
    for (int i = 0; i < gridSize; ++i) {
        for (int j = 0; j < gridSize; ++j) {
            int nodeIndex = i * gridSize + j;
            Node* currentNode = nodes[nodeIndex];
            
            // Connect to right neighbor
            if (j < gridSize - 1) {
                Node* rightNode = nodes[nodeIndex + 1];
                Edge* edge = new Edge();
                edge->setResolvedSockets(currentNode->getSocketByIndex(1), rightNode->getSocketByIndex(0));
                m_testScene->addItem(edge);
                edges.append(edge);
            }
            
            // Connect to bottom neighbor
            if (i < gridSize - 1) {
                Node* bottomNode = nodes[nodeIndex + gridSize];
                Edge* edge = new Edge();
                edge->setResolvedSockets(currentNode->getSocketByIndex(3), bottomNode->getSocketByIndex(2));
                m_testScene->addItem(edge);
                edges.append(edge);
            }
        }
    }
    
    // STRESS TEST: Delete nodes in random order while edges exist
    QVector<int> nodeIndices;
    for (int i = 0; i < nodes.size(); ++i) {
        nodeIndices.append(i);
    }
    
    // Delete first half of nodes randomly
    for (int i = 0; i < nodes.size() / 2; ++i) {
        int index = nodeIndices[i];
        if (nodes[index]) {
            delete nodes[index];
            nodes[index] = nullptr;
        }
    }
    
    // Verify edges handle the destroyed nodes safely
    int nullFromNodes = 0, nullToNodes = 0;
    for (Edge* edge : edges) {
        if (edge->getFromNode() == nullptr) nullFromNodes++;
        if (edge->getToNode() == nullptr) nullToNodes++;
    }
    
    QVERIFY(nullFromNodes > 0 || nullToNodes > 0);  // Should have some nulled nodes
    
    // Clean up remaining objects
    for (Edge* edge : edges) {
        delete edge;
    }
    for (Node* node : nodes) {
        if (node) delete node;
    }
    
    logTestSummary(QString("SAFETY_TEST: ✓ Stress test passed - %1 null fromNodes, %2 null toNodes")
                   .arg(nullFromNodes).arg(nullToNodes));
}

// ============================================================================
// Live XML Synchronization Tests
// ============================================================================

void tst_Main::test_liveXmlNodePositionSync()
{
    logTestSummary("LIVE_XML_TEST: Node position synchronization");
    
    // Create XML live sync system
    XmlLiveSync* liveSync = new XmlLiveSync(m_testScene, m_xmlDoc);
    QVERIFY(liveSync != nullptr);
    QVERIFY(liveSync->isEnabled());
    
    // Create a test node
    Node* node = new Node(QUuid::createUuid(), QPointF(100, 100));
    node->setNodeType("OUT");
    node->createSocketsFromXml(0, 1);
    m_testScene->addNode(node);
    
    // Move the node to trigger live XML update
    QPointF oldPos = node->pos();
    QPointF newPos(250, 150);
    node->setPos(newPos);
    
    // Verify XML was updated immediately
    xmlNodePtr root = xmlDocGetRootElement(m_xmlDoc);
    QVERIFY(root != nullptr);
    
    // Find the node in XML and verify position
    bool foundNode = false;
    QString nodeId = node->getId().toString(QUuid::WithoutBraces);
    
    for (xmlNodePtr child = root->children; child; child = child->next) {
        if (child->type == XML_ELEMENT_NODE && 
            xmlStrcmp(child->name, BAD_CAST "nodes") == 0) {
            
            for (xmlNodePtr nodeXml = child->children; nodeXml; nodeXml = nodeXml->next) {
                if (nodeXml->type == XML_ELEMENT_NODE) {
                    xmlChar* idProp = xmlGetProp(nodeXml, BAD_CAST "id");
                    if (idProp && QString::fromUtf8((char*)idProp) == nodeId) {
                        xmlChar* xProp = xmlGetProp(nodeXml, BAD_CAST "x");
                        xmlChar* yProp = xmlGetProp(nodeXml, BAD_CAST "y");
                        
                        if (xProp && yProp) {
                            double xmlX = QString::fromUtf8((char*)xProp).toDouble();
                            double xmlY = QString::fromUtf8((char*)yProp).toDouble();
                            
                            QCOMPARE(xmlX, newPos.x());
                            QCOMPARE(xmlY, newPos.y());
                            foundNode = true;
                        }
                        
                        if (idProp) xmlFree(idProp);
                        if (xProp) xmlFree(xProp);
                        if (yProp) xmlFree(yProp);
                        break;
                    }
                    if (idProp) xmlFree(idProp);
                }
            }
        }
    }
    
    QVERIFY(foundNode);
    delete liveSync;
    logTestSummary("LIVE_XML_TEST: ✓ Node position sync verified");
}

void tst_Main::test_liveXmlEdgeCreationSync()
{
    logTestSummary("LIVE_XML_TEST: Edge creation synchronization");
    
    XmlLiveSync* liveSync = new XmlLiveSync(m_testScene, m_xmlDoc);
    
    // Create two nodes
    Node* node1 = new Node(QUuid::createUuid(), QPointF(0, 0));
    Node* node2 = new Node(QUuid::createUuid(), QPointF(100, 0));
    
    node1->setNodeType("OUT");
    node1->createSocketsFromXml(0, 1);
    node2->setNodeType("IN");
    node2->createSocketsFromXml(1, 0);
    
    m_testScene->addNode(node1);
    m_testScene->addNode(node2);
    
    // Count edges in XML before
    int edgeCountBefore = 0;
    xmlNodePtr root = xmlDocGetRootElement(m_xmlDoc);
    for (xmlNodePtr child = root->children; child; child = child->next) {
        if (child->type == XML_ELEMENT_NODE && 
            xmlStrcmp(child->name, BAD_CAST "edges") == 0) {
            for (xmlNodePtr edgeXml = child->children; edgeXml; edgeXml = edgeXml->next) {
                if (edgeXml->type == XML_ELEMENT_NODE) edgeCountBefore++;
            }
        }
    }
    
    // Create edge - should trigger live XML update
    Edge* edge = new Edge();
    edge->setResolvedSockets(node1->getSocketByIndex(0), node2->getSocketByIndex(0));
    m_testScene->addEdge(edge);
    
    // Count edges in XML after
    int edgeCountAfter = 0;
    for (xmlNodePtr child = root->children; child; child = child->next) {
        if (child->type == XML_ELEMENT_NODE && 
            xmlStrcmp(child->name, BAD_CAST "edges") == 0) {
            for (xmlNodePtr edgeXml = child->children; edgeXml; edgeXml = edgeXml->next) {
                if (edgeXml->type == XML_ELEMENT_NODE) edgeCountAfter++;
            }
        }
    }
    
    QVERIFY(edgeCountAfter > edgeCountBefore);
    delete liveSync;
    logTestSummary("LIVE_XML_TEST: ✓ Edge creation sync verified");
}

void tst_Main::test_liveXmlEdgeDeletionSync()
{
    logTestSummary("LIVE_XML_TEST: Edge deletion synchronization");
    
    XmlLiveSync* liveSync = new XmlLiveSync(m_testScene, m_xmlDoc);
    
    // Create nodes and edge
    Node* node1 = new Node(QUuid::createUuid(), QPointF(0, 0));
    Node* node2 = new Node(QUuid::createUuid(), QPointF(100, 0));
    
    node1->setNodeType("OUT");
    node1->createSocketsFromXml(0, 1);
    node2->setNodeType("IN");
    node2->createSocketsFromXml(1, 0);
    
    m_testScene->addNode(node1);
    m_testScene->addNode(node2);
    
    Edge* edge = new Edge();
    edge->setResolvedSockets(node1->getSocketByIndex(0), node2->getSocketByIndex(0));
    m_testScene->addEdge(edge);
    
    // Verify edge was added to XML
    int edgeCountWithEdge = 0;
    xmlNodePtr root = xmlDocGetRootElement(m_xmlDoc);
    for (xmlNodePtr child = root->children; child; child = child->next) {
        if (child->type == XML_ELEMENT_NODE && 
            xmlStrcmp(child->name, BAD_CAST "edges") == 0) {
            for (xmlNodePtr edgeXml = child->children; edgeXml; edgeXml = edgeXml->next) {
                if (edgeXml->type == XML_ELEMENT_NODE) edgeCountWithEdge++;
            }
        }
    }
    
    QVERIFY(edgeCountWithEdge > 0);
    
    // Delete edge - should trigger live XML update
    QUuid edgeId = edge->getId();
    m_testScene->removeEdge(edgeId);  // This calls delete internally
    
    // Verify edge was removed from XML
    int edgeCountAfterDelete = 0;
    for (xmlNodePtr child = root->children; child; child = child->next) {
        if (child->type == XML_ELEMENT_NODE && 
            xmlStrcmp(child->name, BAD_CAST "edges") == 0) {
            for (xmlNodePtr edgeXml = child->children; edgeXml; edgeXml = edgeXml->next) {
                if (edgeXml->type == XML_ELEMENT_NODE) edgeCountAfterDelete++;
            }
        }
    }
    
    QVERIFY(edgeCountAfterDelete < edgeCountWithEdge);
    delete liveSync;
    logTestSummary("LIVE_XML_TEST: ✓ Edge deletion sync verified");
}

void tst_Main::test_liveXmlFastSave()
{
    logTestSummary("LIVE_XML_TEST: Fast save performance");
    
    XmlLiveSync* liveSync = new XmlLiveSync(m_testScene, m_xmlDoc);
    
    // Create some test data
    Node* node = new Node(QUuid::createUuid(), QPointF(123, 456));
    node->setNodeType("OUT");
    node->createSocketsFromXml(0, 1);
    m_testScene->addNode(node);
    
    // Test fast save
    QString testFile = "logs/test_live_xml_save.xml";
    QElapsedTimer timer;
    timer.start();
    
    bool saveSuccess = liveSync->saveToFile(testFile);
    qint64 saveTime = timer.elapsed();
    
    QVERIFY(saveSuccess);
    QVERIFY(saveTime < 100);  // Should be very fast (< 100ms)
    
    // Verify file was created and contains our data
    QFile file(testFile);
    QVERIFY(file.exists());
    QVERIFY(file.size() > 0);
    
    delete liveSync;
    logTestSummary(QString("LIVE_XML_TEST: ✓ Fast save completed in %1ms").arg(saveTime));
}

void tst_Main::test_liveXmlRebuildFromScene()
{
    logTestSummary("LIVE_XML_TEST: Rebuild XML from scene");
    
    XmlLiveSync* liveSync = new XmlLiveSync(m_testScene, m_xmlDoc);
    
    // Create test data in scene
    Node* node1 = new Node(QUuid::createUuid(), QPointF(10, 20));
    Node* node2 = new Node(QUuid::createUuid(), QPointF(30, 40));
    
    node1->setNodeType("OUT");
    node1->createSocketsFromXml(0, 1);
    node2->setNodeType("IN");
    node2->createSocketsFromXml(1, 0);
    
    m_testScene->addNode(node1);
    m_testScene->addNode(node2);
    
    Edge* edge = new Edge();
    edge->setResolvedSockets(node1->getSocketByIndex(0), node2->getSocketByIndex(0));
    m_testScene->addEdge(edge);
    
    // Force rebuild from scene
    liveSync->rebuildXmlFromScene();
    
    // Verify XML contains all scene elements
    xmlNodePtr root = xmlDocGetRootElement(m_xmlDoc);
    QVERIFY(root != nullptr);
    
    int nodeCount = 0, edgeCount = 0;
    
    for (xmlNodePtr child = root->children; child; child = child->next) {
        if (child->type == XML_ELEMENT_NODE) {
            if (xmlStrcmp(child->name, BAD_CAST "nodes") == 0) {
                for (xmlNodePtr nodeXml = child->children; nodeXml; nodeXml = nodeXml->next) {
                    if (nodeXml->type == XML_ELEMENT_NODE) nodeCount++;
                }
            } else if (xmlStrcmp(child->name, BAD_CAST "edges") == 0) {
                for (xmlNodePtr edgeXml = child->children; edgeXml; edgeXml = edgeXml->next) {
                    if (edgeXml->type == XML_ELEMENT_NODE) edgeCount++;
                }
            }
        }
    }
    
    QCOMPARE(nodeCount, 2);
    QCOMPARE(edgeCount, 1);
    
    delete liveSync;
    logTestSummary("LIVE_XML_TEST: ✓ XML rebuild verified");
}

QTEST_MAIN(tst_Main)
#include "tst_main.moc"

// ====================================
// FILE: view.cpp
// LAST MODIFIED: 2025-07-14 09:13:24
// ====================================

#include "view.h"
#include "scene.h"
#include <QMouseEvent>
#include <QWheelEvent>
#include <QKeyEvent>
#include <QPainter>
#include <QScrollBar>
#include <QDebug>
#include <QDragEnterEvent>
#include <QDropEvent>
#include <QDragMoveEvent>
#include <QMimeData>

View::View(Scene* scene, QWidget* parent)
    : QGraphicsView(scene, parent)
    , m_scene(scene)
    , m_zoomLevel(1.0)
    , m_middleClickPanning(false)
    , m_showGrid(true)
    , m_gridSize(50.0)
{
    setRenderHint(QPainter::Antialiasing);
    setRenderHint(QPainter::SmoothPixmapTransform);
    setDragMode(QGraphicsView::RubberBandDrag);
    setViewportUpdateMode(QGraphicsView::FullViewportUpdate);
    
    // Enable focus for keyboard events
    setFocusPolicy(Qt::StrongFocus);
    
    // Enable drag and drop
    setAcceptDrops(true);
    
    // Optimize for performance
    setOptimizationFlag(QGraphicsView::DontSavePainterState);
    setOptimizationFlag(QGraphicsView::DontAdjustForAntialiasing);
    
    qDebug() << "VIEW: Enhanced view initialized with grid and zoom controls";
}

void View::mousePressEvent(QMouseEvent* event)
{
    if (event->button() == Qt::MiddleButton) {
        // Start middle-click panning
        m_middleClickPanning = true;
        m_lastPanPoint = event->pos();
        setCursor(Qt::ClosedHandCursor);
        event->accept();
        return;
    }
    
    QGraphicsView::mousePressEvent(event);
}

void View::mouseMoveEvent(QMouseEvent* event)
{
    if (m_middleClickPanning) {
        // Handle middle-click panning
        QPoint delta = event->pos() - m_lastPanPoint;
        horizontalScrollBar()->setValue(horizontalScrollBar()->value() - delta.x());
        verticalScrollBar()->setValue(verticalScrollBar()->value() - delta.y());
        m_lastPanPoint = event->pos();
        event->accept();
        return;
    }
    
    QGraphicsView::mouseMoveEvent(event);
}

void View::mouseReleaseEvent(QMouseEvent* event)
{
    if (event->button() == Qt::MiddleButton && m_middleClickPanning) {
        // End middle-click panning
        m_middleClickPanning = false;
        setCursor(Qt::ArrowCursor);
        event->accept();
        return;
    }
    
    QGraphicsView::mouseReleaseEvent(event);
}

void View::wheelEvent(QWheelEvent* event)
{
    // Enhanced zoom with center point
    qreal factor = (event->angleDelta().y() > 0) ? ZOOM_FACTOR : (1.0 / ZOOM_FACTOR);
    QPointF center = mapToScene(event->position().toPoint());
    updateZoom(factor, center);
    event->accept();
}

void View::keyPressEvent(QKeyEvent* event)
{
    switch (event->key()) {
        case Qt::Key_Plus:
        case Qt::Key_Equal:
            zoomIn();
            event->accept();
            return;
        case Qt::Key_Minus:
            zoomOut();
            event->accept();
            return;
        case Qt::Key_0:
            if (event->modifiers() & Qt::ControlModifier) {
                zoomReset();
                event->accept();
                return;
            }
            break;
        case Qt::Key_F:
            if (event->modifiers() & Qt::ControlModifier) {
                zoomToFit();
                event->accept();
                return;
            }
            break;
        case Qt::Key_Home:
            centerView();
            event->accept();
            return;
        case Qt::Key_G:
            m_showGrid = !m_showGrid;
            viewport()->update();
            qDebug() << "VIEW: Grid" << (m_showGrid ? "enabled" : "disabled");
            event->accept();
            return;
    }
    
    QGraphicsView::keyPressEvent(event);
}

// ============================================================================
// View Control Methods
// ============================================================================

void View::zoomIn()
{
    updateZoom(ZOOM_FACTOR);
}

void View::zoomOut()
{
    updateZoom(1.0 / ZOOM_FACTOR);
}

void View::zoomReset()
{
    setZoomLevel(1.0);
    qDebug() << "VIEW: Reset zoom to 100%";
}

void View::zoomToFit()
{
    if (m_scene) {
        QRectF itemsRect = m_scene->itemsBoundingRect();
        if (!itemsRect.isEmpty()) {
            fitInView(itemsRect, Qt::KeepAspectRatio);
            m_zoomLevel = transform().m11(); // Update zoom level
            emit zoomChanged(m_zoomLevel);
            qDebug() << "VIEW: Zoomed to fit items";
        }
    }
}

void View::centerView()
{
    if (m_scene) {
        QRectF itemsRect = m_scene->itemsBoundingRect();
        if (!itemsRect.isEmpty()) {
            centerOn(itemsRect.center());
            qDebug() << "VIEW: Centered on items";
        } else {
            centerOn(0, 0);
            qDebug() << "VIEW: Centered on origin";
        }
    }
}

void View::setZoomLevel(qreal zoom)
{
    zoom = qBound(MIN_ZOOM, zoom, MAX_ZOOM);
    if (qAbs(zoom - m_zoomLevel) > 0.01) {
        qreal factor = zoom / m_zoomLevel;
        m_zoomLevel = zoom;
        scale(factor, factor);
        emit zoomChanged(m_zoomLevel);
    }
}

void View::updateZoom(qreal factor, const QPointF& center)
{
    qreal newZoom = m_zoomLevel * factor;
    newZoom = qBound(MIN_ZOOM, newZoom, MAX_ZOOM);
    
    if (qAbs(newZoom - m_zoomLevel) > 0.01) {
        qreal actualFactor = newZoom / m_zoomLevel;
        m_zoomLevel = newZoom;
        
        if (!center.isNull()) {
            // Zoom towards specified center point
            QPointF viewCenter = mapFromScene(center);
            scale(actualFactor, actualFactor);
            QPointF newViewCenter = mapFromScene(center);
            QPointF delta = newViewCenter - viewCenter;
            horizontalScrollBar()->setValue(horizontalScrollBar()->value() - delta.x());
            verticalScrollBar()->setValue(verticalScrollBar()->value() - delta.y());
        } else {
            scale(actualFactor, actualFactor);
        }
        
        emit zoomChanged(m_zoomLevel);
    }
}

void View::drawBackground(QPainter* painter, const QRectF& rect)
{
    // Draw default background
    QGraphicsView::drawBackground(painter, rect);
    
    // Draw grid if enabled
    if (m_showGrid) {
        drawGrid(painter, rect);
    }
}

void View::drawGrid(QPainter* painter, const QRectF& rect)
{
    painter->save();
    
    // Grid color based on zoom level
    QColor gridColor = QColor(128, 128, 128, 30 + (m_zoomLevel * 20));
    painter->setPen(QPen(gridColor, 1));
    
    // Calculate grid spacing based on zoom
    qreal gridSpacing = m_gridSize;
    while (gridSpacing * m_zoomLevel < 20) gridSpacing *= 2;
    while (gridSpacing * m_zoomLevel > 100) gridSpacing /= 2;
    
    // Draw vertical lines
    qreal left = int(rect.left() / gridSpacing) * gridSpacing;
    qreal right = rect.right();
    for (qreal x = left; x <= right; x += gridSpacing) {
        painter->drawLine(QLineF(x, rect.top(), x, rect.bottom()));
    }
    
    // Draw horizontal lines
    qreal top = int(rect.top() / gridSpacing) * gridSpacing;
    qreal bottom = rect.bottom();
    for (qreal y = top; y <= bottom; y += gridSpacing) {
        painter->drawLine(QLineF(rect.left(), y, rect.right(), y));
    }
    
    painter->restore();
}

void View::scrollContentsBy(int dx, int dy)
{
    QGraphicsView::scrollContentsBy(dx, dy);
    emit viewChanged(mapToScene(viewport()->rect()).boundingRect());
}

// ============================================================================
// Drag and Drop Support
// ============================================================================

void View::dragEnterEvent(QDragEnterEvent* event)
{
    // Check if the drag contains node type data
    if (event->mimeData()->hasFormat("application/x-nodetype") || 
        event->mimeData()->hasText()) {
        event->acceptProposedAction();
        qDebug() << "Drag enter accepted - node type:" << event->mimeData()->text();
    } else {
        event->ignore();
    }
}

void View::dragMoveEvent(QDragMoveEvent* event)
{
    // Accept the drag move event if we can handle the data
    if (event->mimeData()->hasFormat("application/x-nodetype") || 
        event->mimeData()->hasText()) {
        event->acceptProposedAction();
    } else {
        event->ignore();
    }
}

void View::dropEvent(QDropEvent* event)
{
    // Get the node type from mime data
    QString nodeType;
    if (event->mimeData()->hasFormat("application/x-nodetype")) {
        nodeType = QString::fromUtf8(event->mimeData()->data("application/x-nodetype"));
    } else if (event->mimeData()->hasText()) {
        nodeType = event->mimeData()->text();
    }
    
    if (!nodeType.isEmpty()) {
        // Convert drop position to scene coordinates
        QPointF scenePos = mapToScene(event->pos());
        
        qDebug() << "✓ Node dropped:" << nodeType << "at scene position:" << scenePos;
        
        // Emit signal for the window to handle node creation
        emit nodeDropped(nodeType, scenePos);
        
        event->acceptProposedAction();
    } else {
        event->ignore();
        qDebug() << "✗ Drop ignored - no valid node type";
    }
}

// ====================================
// FILE: window.cpp
// LAST MODIFIED: 2025-07-14 09:14:50
// ====================================

#include "window.h"
#include "view.h"
#include "scene.h"
#include "node.h"
#include "edge.h"
#include "graph_factory.h"
#include "xml_autosave_observer.h"
#include "node_palette_bar.h"
#include <QKeyEvent>
#include <QFileDialog>
#include <QCloseEvent>
#include <QMessageBox>
#include <QDebug>
#include <QElapsedTimer>
#include <QFileInfo>
#include <QAction>
#include <QIcon>
#include <QRandomGenerator>
#include <QDockWidget>
#include <QLabel>
#include <QStatusBar>
#include <QMenuBar>
#include <QProgressBar>
#include <QApplication>
#include <QDesktopServices>
#include <QUrl>
#include <libxml/tree.h>
#include <libxml/xmlsave.h>

Window::Window(QWidget* parent)
    : QMainWindow(parent)
    , m_scene(new Scene(this))
    , m_view(new View(m_scene, this))
{
    setWindowTitle("NodeGraph - Self-Serializing Node Editor");
    resize(1400, 900);
    
    // Initialize UI components to nullptr
    m_nodePaletteDock = nullptr;
    m_nodePalette = nullptr;
    m_fileInfoLabel = nullptr;
    m_graphStatsLabel = nullptr;
    m_selectionLabel = nullptr;
    m_positionLabel = nullptr;
    m_zoomLabel = nullptr;
    m_operationProgress = nullptr;
    
    // Create XML document for factory
    m_xmlDocument = xmlNewDoc(BAD_CAST "1.0");
    xmlNodePtr root = xmlNewNode(nullptr, BAD_CAST "graph");
    xmlDocSetRootElement(m_xmlDocument, root);
    xmlSetProp(root, BAD_CAST "version", BAD_CAST "1.0");
    
    // Initialize factory for interactive node creation
    m_factory = new GraphFactory(m_scene, m_xmlDocument);
    
    // Initialize autosave observer for automatic XML saving
    m_autosaveObserver = new XmlAutosaveObserver(m_scene, "autosave.xml");
    m_autosaveObserver->setDelay(750); // 750ms delay after changes
    
    // CRITICAL: Attach observer to scene to receive notifications
    m_scene->attach(m_autosaveObserver);
    
    // Setup enhanced UI
    setupUI();
    setupActions();
    setupMenus();
    setupStatusBar();
    setupDockWidgets();
    
    // Connect scene signals for status updates
    connect(m_scene, &Scene::sceneChanged, this, &Window::onSceneChanged);
    
    // Connect view drag-and-drop signal
    connect(m_view, &View::nodeDropped, this, [this](const QString& nodeType, const QPointF& scenePos) {
        createNodeAtPosition(nodeType, scenePos);
    });
    
    // Initial status update
    updateStatusBar();
    
    // Enable keyboard shortcuts
    setFocusPolicy(Qt::StrongFocus);
}

Window::~Window()
{
    // Clean up autosave observer
    if (m_autosaveObserver) {
        m_scene->detach(m_autosaveObserver);
        delete m_autosaveObserver;
    }
    
    // Clean up XML document
    if (m_xmlDocument) {
        xmlFreeDoc(m_xmlDocument);
        m_xmlDocument = nullptr;
    }
}

void Window::setupActions()
{
    // Create actions for node creation
    m_addInputAction = new QAction("Add Input", this);
    m_addInputAction->setToolTip("Add Input Node (Ctrl+1)");
    m_addInputAction->setShortcut(QKeySequence("Ctrl+1"));
    connect(m_addInputAction, &QAction::triggered, this, &Window::createInputNode);
    
    m_addOutputAction = new QAction("Add Output", this);
    m_addOutputAction->setToolTip("Add Output Node (Ctrl+2)");
    m_addOutputAction->setShortcut(QKeySequence("Ctrl+2"));
    connect(m_addOutputAction, &QAction::triggered, this, &Window::createOutputNode);
    
    m_addProcessorAction = new QAction("Add Processor", this);
    m_addProcessorAction->setToolTip("Add Processor Node (Ctrl+3)");
    m_addProcessorAction->setShortcut(QKeySequence("Ctrl+3"));
    connect(m_addProcessorAction, &QAction::triggered, this, &Window::createProcessorNode);
}


void Window::keyPressEvent(QKeyEvent* event)
{
    if (event->modifiers() & Qt::ControlModifier) {
        switch (event->key()) {
            case Qt::Key_1:
                createInputNode();
                break;
            case Qt::Key_2:
                createOutputNode();
                break;
            case Qt::Key_3:
                createProcessorNode();
                break;
            case Qt::Key_S:
                if (event->modifiers() & Qt::ShiftModifier) {
                    // Ctrl+Shift+S = Save As
                    QString filename = QFileDialog::getSaveFileName(
                        this, 
                        "Save Graph As", 
                        "graph.xml", 
                        "XML Files (*.xml)");
                    if (!filename.isEmpty()) {
                        if (saveGraph(filename)) {
                            m_currentFile = filename;
                            setWindowTitle(QString("Node Editor - %1").arg(QFileInfo(filename).fileName()));
                        }
                    }
                } else {
                    // Ctrl+S = Save
                    if (m_currentFile.isEmpty()) {
                        // No current file, show Save As dialog
                        QString filename = QFileDialog::getSaveFileName(
                            this, 
                            "Save Graph", 
                            "graph.xml", 
                            "XML Files (*.xml)");
                        if (!filename.isEmpty()) {
                            if (saveGraph(filename)) {
                                m_currentFile = filename;
                                setWindowTitle(QString("Node Editor - %1").arg(QFileInfo(filename).fileName()));
                            }
                        }
                    } else {
                        // Save to current file
                        saveGraph(m_currentFile);
                    }
                }
                break;
            case Qt::Key_O:
                // Ctrl+O = Open
                {
                    QString filename = QFileDialog::getOpenFileName(
                        this, 
                        "Open Graph", 
                        "", 
                        "XML Files (*.xml)");
                    if (!filename.isEmpty()) {
                        if (loadGraph(filename)) {
                            m_currentFile = filename;
                            setWindowTitle(QString("Node Editor - %1").arg(QFileInfo(filename).fileName()));
                        }
                    }
                }
                break;
        }
    } else if (event->key() == Qt::Key_Delete || event->key() == Qt::Key_Backspace) {
        // Delete selected items
        qDebug() << "🗑️ Delete key pressed - deleting selected items";
        m_scene->deleteSelected();
    }
    QMainWindow::keyPressEvent(event);
}

void Window::setCurrentFile(const QString& filename)
{
    m_currentFile = filename;
    if (!filename.isEmpty()) {
        setWindowTitle(QString("Node Editor - %1").arg(QFileInfo(filename).fileName()));
        qDebug() << "📁 Current file set to:" << filename;
    } else {
        setWindowTitle("Node Editor");
        qDebug() << "📁 Current file cleared";
    }
}

bool Window::saveGraph(const QString& filename)
{
    qDebug() << "Saving graph to:" << filename;
    
    QElapsedTimer timer;
    timer.start();
    
    // Create XML document
    xmlDocPtr doc = xmlNewDoc(BAD_CAST "1.0");
    xmlNodePtr root = xmlNewNode(nullptr, BAD_CAST "graph");
    xmlDocSetRootElement(doc, root);
    xmlSetProp(root, BAD_CAST "version", BAD_CAST "1.0");
    
    // Step 1: Save all nodes
    for (Node* node : m_scene->getNodes().values()) {
        xmlNodePtr nodeXml = node->write(doc, root);
        Q_UNUSED(nodeXml)
    }
    
    // Step 2: Save all edges
    for (Edge* edge : m_scene->getEdges().values()) {
        xmlNodePtr edgeXml = edge->write(doc, root);
        Q_UNUSED(edgeXml)
    }
    
    // Step 3: Save to file
    int result = xmlSaveFormatFileEnc(filename.toUtf8().constData(), doc, "UTF-8", 1);
    xmlFreeDoc(doc);
    
    qint64 elapsed = timer.elapsed();
    
    if (result != -1) {
        QFileInfo fileInfo(filename);
        qint64 fileSize = fileInfo.size();
        int nodeCount = m_scene->getNodes().size();
        int edgeCount = m_scene->getEdges().size();
        
        qDebug() << "✅ MANUAL SAVE COMPLETE:";
        qDebug() << "   📁 File:" << fileInfo.fileName();
        qDebug() << "   ⏱️  Time:" << elapsed << "ms";
        qDebug() << "   📊 Size:" << (fileSize / 1024.0) << "KB";
        qDebug() << "   🔵 Nodes:" << nodeCount;
        qDebug() << "   🔗 Edges:" << edgeCount;
        
        QMessageBox::information(this, "Save Complete", 
            QString("Graph saved successfully!\n\n📁 File: %1\n🔵 Nodes: %2\n🔗 Edges: %3\n⏱️ Time: %4ms\n📊 Size: %5 KB")
            .arg(fileInfo.fileName())
            .arg(nodeCount)
            .arg(edgeCount)
            .arg(elapsed)
            .arg(fileSize / 1024.0, 0, 'f', 1));
        return true;
    } else {
        qDebug() << "✗ Failed to save graph";
        QMessageBox::critical(this, "Save Error", "Failed to save graph to file.");
        return false;
    }
}

bool Window::loadGraph(const QString& filename)
{
    qDebug() << "=== LOADING GRAPH ===" << filename;
    
    QElapsedTimer timer;
    timer.start();
    
    // Clear current scene AND registries to prevent dangling pointers
    qDebug() << "Clearing current graph...";
    m_scene->clearGraph();
    
    // Use GraphFactory to load from XML file
    qDebug() << "Starting GraphFactory XML load...";
    if (m_factory->loadFromXmlFile(filename)) {
        qint64 elapsed = timer.elapsed();
        
        // Set current file for Ctrl+S functionality
        m_currentFile = filename;
        setWindowTitle(QString("Node Editor - %1").arg(QFileInfo(filename).fileName()));
        
        qDebug() << "✓ Graph loaded successfully in" << elapsed << "ms";
        
        // DEBUGGING: Detailed count verification
        int nodeCount = m_scene->getNodes().size();
        int edgeCount = m_scene->getEdges().size();
        qDebug() << "DEBUG: Hash container sizes:";
        qDebug() << "  m_scene->getNodes().size() =" << nodeCount;
        qDebug() << "  m_scene->getEdges().size() =" << edgeCount;
        qDebug() << "  Qt scene items count:" << m_scene->items().size();
        qDebug() << "  Current file set to:" << m_currentFile;
        
        QMessageBox::information(this, "Load Complete", 
            QString("Graph loaded successfully!\n\nFile: %1\nNodes: %2\nEdges: %3\nTime: %4ms\n\nCtrl+S will now save to this file.")
            .arg(QFileInfo(filename).fileName())
            .arg(nodeCount)
            .arg(edgeCount)
            .arg(elapsed));
        return true;
    } else {
        qDebug() << "✗ Failed to load graph";
        QMessageBox::critical(this, "Load Error", 
            QString("Failed to load graph from file.\n\nFile: %1")
            .arg(QFileInfo(filename).fileName()));
        return false;
    }
}

void Window::createInputNode()
{
    // Find a nice position in the view center
    QPointF viewCenter = m_view->mapToScene(m_view->viewport()->rect().center());
    
    // Add some randomization so multiple nodes don't overlap
    qreal randomX = QRandomGenerator::global()->bounded(-50, 50);
    qreal randomY = QRandomGenerator::global()->bounded(-50, 50);
    QPointF position = viewCenter + QPointF(randomX, randomY);
    
    // Create input node using factory (XML-first approach)
    Node* node = m_factory->createNode("IN", position, 0, 2);  // 0 inputs, 2 outputs
    
    if (node) {
        qDebug() << "✓ Created input node at" << position;
    } else {
        qDebug() << "✗ Failed to create input node";
    }
}

void Window::createOutputNode()
{
    // Find a nice position in the view center
    QPointF viewCenter = m_view->mapToScene(m_view->viewport()->rect().center());
    
    // Add some randomization so multiple nodes don't overlap
    qreal randomX = QRandomGenerator::global()->bounded(-50, 50);
    qreal randomY = QRandomGenerator::global()->bounded(-50, 50);
    QPointF position = viewCenter + QPointF(randomX, randomY);
    
    // Create output node using factory (XML-first approach)
    Node* node = m_factory->createNode("OUT", position, 2, 0);  // 2 inputs, 0 outputs
    
    if (node) {
        qDebug() << "✓ Created output node at" << position;
    } else {
        qDebug() << "✗ Failed to create output node";
    }
}

void Window::createProcessorNode()
{
    // Find a nice position in the view center
    QPointF viewCenter = m_view->mapToScene(m_view->viewport()->rect().center());
    
    // Add some randomization so multiple nodes don't overlap
    qreal randomX = QRandomGenerator::global()->bounded(-50, 50);
    qreal randomY = QRandomGenerator::global()->bounded(-50, 50);
    QPointF position = viewCenter + QPointF(randomX, randomY);
    
    // Create processor node using factory (XML-first approach)
    Node* node = m_factory->createNode("PROC", position, 2, 2);  // 2 inputs, 2 outputs
    
    if (node) {
        qDebug() << "✓ Created processor node at" << position;
    } else {
        qDebug() << "✗ Failed to create processor node";
    }
}

// ============================================================================
// Enhanced UI Implementation - Lookatme + Inkscape Status Bar Patterns
// ============================================================================

void Window::setupUI()
{
    setCentralWidget(m_view);
    
    // Set application icon and improve window appearance
    setWindowIcon(QIcon(":/icons/app-icon.png")); // Optional - if you have icons
    
    // Enable dock widget features
    setDockOptions(QMainWindow::AllowNestedDocks | 
                   QMainWindow::AllowTabbedDocks | 
                   QMainWindow::AnimatedDocks);
}

void Window::setupMenus()
{
    createFileMenu();
    createEditMenu();
    createViewMenu();
    createToolsMenu();
    createHelpMenu();
}

void Window::createFileMenu()
{
    m_fileMenu = menuBar()->addMenu("&File");
    
    // New file
    QAction* newAction = new QAction("&New", this);
    newAction->setShortcut(QKeySequence::New);
    newAction->setStatusTip("Create a new graph");
    connect(newAction, &QAction::triggered, this, &Window::newFile);
    m_fileMenu->addAction(newAction);
    
    // Open file
    QAction* openAction = new QAction("&Open...", this);
    openAction->setShortcut(QKeySequence::Open);
    openAction->setStatusTip("Open an existing graph");
    connect(openAction, &QAction::triggered, this, &Window::openFile);
    m_fileMenu->addAction(openAction);
    
    m_fileMenu->addSeparator();
    
    // Save file
    QAction* saveAction = new QAction("&Save", this);
    saveAction->setShortcut(QKeySequence::Save);
    saveAction->setStatusTip("Save the current graph");
    connect(saveAction, &QAction::triggered, this, &Window::saveFile);
    m_fileMenu->addAction(saveAction);
    
    // Save As
    QAction* saveAsAction = new QAction("Save &As...", this);
    saveAsAction->setShortcut(QKeySequence::SaveAs);
    saveAsAction->setStatusTip("Save the graph with a new name");
    connect(saveAsAction, &QAction::triggered, this, &Window::saveAsFile);
    m_fileMenu->addAction(saveAsAction);
    
    m_fileMenu->addSeparator();
    
    // Export
    QAction* exportAction = new QAction("&Export...", this);
    exportAction->setStatusTip("Export graph to various formats");
    connect(exportAction, &QAction::triggered, this, &Window::exportGraph);
    m_fileMenu->addAction(exportAction);
    
    m_fileMenu->addSeparator();
    
    // Exit
    QAction* exitAction = new QAction("E&xit", this);
    exitAction->setShortcut(QKeySequence::Quit);
    exitAction->setStatusTip("Exit the application");
    connect(exitAction, &QAction::triggered, this, &QWidget::close);
    m_fileMenu->addAction(exitAction);
}

void Window::createEditMenu()
{
    m_editMenu = menuBar()->addMenu("&Edit");
    
    // Undo/Redo placeholders for future implementation
    QAction* undoAction = new QAction("&Undo", this);
    undoAction->setShortcut(QKeySequence::Undo);
    undoAction->setEnabled(false); // TODO: Implement undo system
    m_editMenu->addAction(undoAction);
    
    QAction* redoAction = new QAction("&Redo", this);
    redoAction->setShortcut(QKeySequence::Redo);
    redoAction->setEnabled(false); // TODO: Implement redo system
    m_editMenu->addAction(redoAction);
    
    m_editMenu->addSeparator();
    
    // Selection operations
    QAction* selectAllAction = new QAction("Select &All", this);
    selectAllAction->setShortcut(QKeySequence::SelectAll);
    selectAllAction->setStatusTip("Select all nodes and edges");
    m_editMenu->addAction(selectAllAction);
    
    QAction* deselectAction = new QAction("&Deselect All", this);
    deselectAction->setShortcut(QKeySequence("Ctrl+D"));
    deselectAction->setStatusTip("Clear selection");
    m_editMenu->addAction(deselectAction);
    
    m_editMenu->addSeparator();
    
    // Delete
    QAction* deleteAction = new QAction("&Delete Selected", this);
    deleteAction->setShortcut(QKeySequence::Delete);
    deleteAction->setStatusTip("Delete selected nodes and edges");
    m_editMenu->addAction(deleteAction);
}

void Window::createViewMenu()
{
    m_viewMenu = menuBar()->addMenu("&View");
    
    // Zoom operations
    QAction* zoomInAction = new QAction("Zoom &In", this);
    zoomInAction->setShortcut(QKeySequence::ZoomIn);
    zoomInAction->setStatusTip("Zoom in to the graph");
    connect(zoomInAction, &QAction::triggered, this, &Window::zoomIn);
    m_viewMenu->addAction(zoomInAction);
    
    QAction* zoomOutAction = new QAction("Zoom &Out", this);
    zoomOutAction->setShortcut(QKeySequence::ZoomOut);
    zoomOutAction->setStatusTip("Zoom out from the graph");
    connect(zoomOutAction, &QAction::triggered, this, &Window::zoomOut);
    m_viewMenu->addAction(zoomOutAction);
    
    QAction* zoomFitAction = new QAction("Zoom to &Fit", this);
    zoomFitAction->setShortcut(QKeySequence("Ctrl+0"));
    zoomFitAction->setStatusTip("Fit entire graph in view");
    connect(zoomFitAction, &QAction::triggered, this, &Window::zoomFit);
    m_viewMenu->addAction(zoomFitAction);
    
    QAction* zoomResetAction = new QAction("&Reset Zoom", this);
    zoomResetAction->setShortcut(QKeySequence("Ctrl+1"));
    zoomResetAction->setStatusTip("Reset zoom to 100%");
    connect(zoomResetAction, &QAction::triggered, this, &Window::zoomReset);
    m_viewMenu->addAction(zoomResetAction);
    
    m_viewMenu->addSeparator();
    
    // Dock widget toggles will be added after dock widgets are created
}

void Window::createToolsMenu()
{
    m_toolsMenu = menuBar()->addMenu("&Tools");
    
    // Node creation submenu
    QMenu* createNodeMenu = m_toolsMenu->addMenu("&Create Node");
    createNodeMenu->addAction(m_addInputAction);
    createNodeMenu->addAction(m_addOutputAction);
    createNodeMenu->addAction(m_addProcessorAction);
    
    m_toolsMenu->addSeparator();
    
    QAction* validateAction = new QAction("&Validate Graph", this);
    validateAction->setStatusTip("Check graph for errors and inconsistencies");
    m_toolsMenu->addAction(validateAction);
    
    QAction* statisticsAction = new QAction("Graph &Statistics", this);
    statisticsAction->setStatusTip("Show detailed graph statistics");
    m_toolsMenu->addAction(statisticsAction);
}

void Window::createHelpMenu()
{
    m_helpMenu = menuBar()->addMenu("&Help");
    
    QAction* aboutAction = new QAction("&About", this);
    aboutAction->setStatusTip("About this application");
    connect(aboutAction, &QAction::triggered, this, &Window::showAbout);
    m_helpMenu->addAction(aboutAction);
    
    QAction* aboutQtAction = new QAction("About &Qt", this);
    aboutQtAction->setStatusTip("About Qt Framework");
    connect(aboutQtAction, &QAction::triggered, qApp, &QApplication::aboutQt);
    m_helpMenu->addAction(aboutQtAction);
}

void Window::setupStatusBar()
{
    createStatusBarWidgets();
    connectStatusBarSignals();
}

void Window::createStatusBarWidgets()
{
    QStatusBar* statusBar = this->statusBar();
    statusBar->setStyleSheet(
        "QStatusBar {"
        "  border-top: 1px solid #bdc3c7;"
        "  background: #ecf0f1;"
        "}"
        "QStatusBar::item {"
        "  border: none;"
        "}"
    );
    
    // File info (leftmost)
    m_fileInfoLabel = new QLabel("No file loaded");
    m_fileInfoLabel->setStyleSheet("QLabel { color: #2c3e50; margin-right: 15px; }");
    statusBar->addWidget(m_fileInfoLabel);
    
    // Graph statistics
    m_graphStatsLabel = new QLabel("Nodes: 0 | Edges: 0");
    m_graphStatsLabel->setStyleSheet("QLabel { color: #27ae60; font-weight: bold; margin-right: 15px; }");
    statusBar->addWidget(m_graphStatsLabel);
    
    // Selection info
    m_selectionLabel = new QLabel("No selection");
    m_selectionLabel->setStyleSheet("QLabel { color: #8e44ad; margin-right: 15px; }");
    statusBar->addWidget(m_selectionLabel);
    
    // Add stretch to push remaining widgets to the right
    statusBar->addPermanentWidget(new QWidget(), 1);
    
    // Mouse position (right side)
    m_positionLabel = new QLabel("Position: (0, 0)");
    m_positionLabel->setStyleSheet("QLabel { color: #34495e; margin-right: 10px; }");
    statusBar->addPermanentWidget(m_positionLabel);
    
    // Zoom level (rightmost)
    m_zoomLabel = new QLabel("Zoom: 100%");
    m_zoomLabel->setStyleSheet("QLabel { color: #e74c3c; font-weight: bold; }");
    statusBar->addPermanentWidget(m_zoomLabel);
    
    // Operation progress (hidden by default)
    m_operationProgress = new QProgressBar();
    m_operationProgress->setVisible(false);
    m_operationProgress->setMaximumWidth(200);
    statusBar->addPermanentWidget(m_operationProgress);
}

void Window::connectStatusBarSignals()
{
    // Update status bar when scene changes
    connect(m_scene, &Scene::sceneChanged, this, &Window::updateStatusBar);
    
    // TODO: Connect view signals for mouse position and zoom updates
    // This would require extending the View class to emit these signals
}

void Window::setupDockWidgets()
{
    qDebug() << "Setting up professional node palette...";
    
    // Create the professional node palette bar
    m_nodePalette = new NodePaletteBar(this);
    
    // Create dock widget for the node palette
    m_nodePaletteDock = new QDockWidget(tr("Node Palette"), this);
    m_nodePaletteDock->setWidget(m_nodePalette);
    m_nodePaletteDock->setFixedWidth(130);  // Wider for categories
    m_nodePaletteDock->setFeatures(QDockWidget::DockWidgetMovable | QDockWidget::DockWidgetFloatable);
    m_nodePaletteDock->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    
    // Position on the left side of the main window
    addDockWidget(Qt::LeftDockWidgetArea, m_nodePaletteDock);
    
    // Note: Node creation now handled by drag-and-drop in createNodeAtPosition()
    
    // Add dock widget toggle to View menu
    m_viewMenu->addSeparator();
    m_viewMenu->addAction(m_nodePaletteDock->toggleViewAction());
    
    qDebug() << "✓ Professional node palette setup complete";
}

void Window::updateStatusBar()
{
    if (!m_scene) return;
    
    // Update graph statistics
    int nodeCount = m_scene->getNodes().size();
    int edgeCount = m_scene->getEdges().size();
    m_graphStatsLabel->setText(QString("Nodes: %1 | Edges: %2").arg(nodeCount).arg(edgeCount));
    
    // Update file info
    if (m_currentFile.isEmpty()) {
        m_fileInfoLabel->setText("No file loaded");
    } else {
        QFileInfo fileInfo(m_currentFile);
        m_fileInfoLabel->setText(QString("File: %1").arg(fileInfo.fileName()));
    }
    
    // Update selection info (placeholder for now)
    QList<QGraphicsItem*> selectedItems = m_scene->selectedItems();
    if (selectedItems.isEmpty()) {
        m_selectionLabel->setText("No selection");
    } else {
        m_selectionLabel->setText(QString("Selected: %1 items").arg(selectedItems.size()));
    }
}

// ============================================================================
// Slot Implementations
// ============================================================================

void Window::onSceneChanged()
{
    updateStatusBar();
}

void Window::onSelectionChanged()
{
    updateSelectionInfo();
}

void Window::updateSelectionInfo()
{
    if (!m_scene) return;
    
    QList<QGraphicsItem*> selectedItems = m_scene->selectedItems();
    if (selectedItems.isEmpty()) {
        m_selectionLabel->setText("No selection");
    } else {
        int nodeCount = 0;
        int edgeCount = 0;
        
        for (QGraphicsItem* item : selectedItems) {
            if (qgraphicsitem_cast<Node*>(item)) {
                nodeCount++;
            } else if (qgraphicsitem_cast<Edge*>(item)) {
                edgeCount++;
            }
        }
        
        QString selectionText;
        if (nodeCount > 0 && edgeCount > 0) {
            selectionText = QString("Selected: %1 nodes, %2 edges").arg(nodeCount).arg(edgeCount);
        } else if (nodeCount > 0) {
            selectionText = QString("Selected: %1 nodes").arg(nodeCount);
        } else if (edgeCount > 0) {
            selectionText = QString("Selected: %1 edges").arg(edgeCount);
        }
        
        m_selectionLabel->setText(selectionText);
    }
}

// ============================================================================
// Menu Action Implementations (Placeholders)
// ============================================================================

void Window::newFile()
{
    // TODO: Clear current scene and reset
    qDebug() << "🆕 New file requested";
}

void Window::openFile()
{
    qDebug() << "=== FILE OPEN DIALOG ===";
    QString fileName = QFileDialog::getOpenFileName(this, "Open Graph", "", "XML Files (*.xml)");
    if (!fileName.isEmpty()) {
        qDebug() << "File selected:" << fileName;
        if (loadGraph(fileName)) {
            setCurrentFile(fileName);
            updateStatusBar();
            qDebug() << "File loaded successfully";
        } else {
            qDebug() << "File load FAILED";
        }
    } else {
        qDebug() << "File dialog cancelled";
    }
}

void Window::saveFile()
{
    qDebug() << "=== CTRL+S SAVE TRIGGERED ===";
    qDebug() << "Current file:" << (m_currentFile.isEmpty() ? "NONE (will show Save As dialog)" : m_currentFile);
    
    if (m_currentFile.isEmpty()) {
        qDebug() << "No current file - opening Save As dialog...";
        saveAsFile();
    } else {
        qDebug() << "Saving to current file:" << m_currentFile;
        if (saveGraph(m_currentFile)) {
            qDebug() << "✓ Save successful";
            updateStatusBar();
        } else {
            qDebug() << "✗ Save FAILED";
        }
    }
}

void Window::saveAsFile()
{
    QString fileName = QFileDialog::getSaveFileName(this, "Save Graph", "", "XML Files (*.xml)");
    if (!fileName.isEmpty()) {
        if (saveGraph(fileName)) {
            setCurrentFile(fileName);
            updateStatusBar();
        }
    }
}

void Window::exportGraph()
{
    // TODO: Implement export functionality
    QMessageBox::information(this, "Export", "Export functionality will be implemented in a future update.");
}

void Window::showAbout()
{
    QMessageBox::about(this, "About NodeGraph",
        "<h3>NodeGraph - Self-Serializing Node Editor</h3>"
        "<p>A professional node-based graph editor with self-serializing architecture.</p>"
        "<p><b>Features:</b></p>"
        "<ul>"
        "<li>Self-serializing nodes with libxml2 backend</li>"
        "<li>Observer pattern with automatic XML persistence</li>"
        "<li>Professional UI with docking panels</li>"
        "<li>Enhanced visual selection highlighting</li>"
        "<li>Drag-and-drop node creation</li>"
        "</ul>"
        "<p>Built with Qt5 and modern C++ patterns.</p>");
}

void Window::zoomIn()
{
    m_view->scale(1.2, 1.2);
    // TODO: Update zoom label
}

void Window::zoomOut()
{
    m_view->scale(0.8, 0.8);
    // TODO: Update zoom label
}

void Window::zoomFit()
{
    m_view->fitInView(m_scene->itemsBoundingRect(), Qt::KeepAspectRatio);
    // TODO: Update zoom label
}

void Window::zoomReset()
{
    m_view->resetTransform();
    // TODO: Update zoom label
}

void Window::createNodeAtPosition(const QString& nodeType, const QPointF& scenePos)
{
    qDebug() << "Creating node type:" << nodeType << "at position:" << scenePos;
    
    Node* node = nullptr;
    
    // Create the 4 specific node types with exact socket configurations
    if (nodeType == "Source") {
        node = m_factory->createNode("Source", scenePos, 0, 1);  // 0 input, 1 output
    } else if (nodeType == "Sink") {
        node = m_factory->createNode("Sink", scenePos, 1, 0);    // 1 input, 0 output
    } else if (nodeType == "1-to-2") {
        node = m_factory->createNode("1-to-2", scenePos, 1, 2);  // 1 input, 2 output
    } else if (nodeType == "2-to-1") {
        node = m_factory->createNode("2-to-1", scenePos, 2, 1);  // 2 input, 1 output
    } else {
        qDebug() << "✗ Unknown node type:" << nodeType;
        return;
    }
    
    if (node) {
        qDebug() << "✓ Created" << nodeType << "node at" << scenePos;
        updateStatusBar();
    } else {
        qDebug() << "✗ Failed to create" << nodeType << "node";
    }
}

// ============================================================================
// PHASE 3: Safe Shutdown Coordination
// ============================================================================

void Window::closeEvent(QCloseEvent* event)
{
    qDebug() << "PHASE1: Window shutdown initiated";
    
    // PHASE 1.2: Prepare scene for safe shutdown
    if (m_scene) {
        m_scene->prepareForShutdown();
    }
    
    // Accept the close event (no dirty state tracking yet)
    QMainWindow::closeEvent(event);
    
    qDebug() << "PHASE1: ✓ Window shutdown complete";
}

// ====================================
// FILE: xml_autosave_observer.cpp
// LAST MODIFIED: 2025-07-14 03:03:20
// ====================================

#include "xml_autosave_observer.h"
#include "scene.h"
#include "node.h"
#include "edge.h"
#include "graph_observer.h"
#include <QTimer>
#include <QDebug>
#include <QElapsedTimer>
#include <QFileInfo>
#include <QFile>
#include <QTextStream>
#include <libxml/tree.h>
#include <libxml/parser.h>

XmlAutosaveObserver::XmlAutosaveObserver(Scene* scene, const QString& filename)
    : m_scene(scene)
    , m_filename(filename)
    , m_saveTimer(new QTimer())
    , m_enabled(true)
    , m_pendingChanges(false)
{
    // Configure timer for delayed saving
    m_saveTimer->setSingleShot(true);
    m_saveTimer->setInterval(2000); // 2 second delay by default
    
    // Connect timer to autosave
    QObject::connect(m_saveTimer, &QTimer::timeout, [this]() {
        performAutosave();
    });
    
    qDebug().noquote() << "[AUTOSAVE] Observer created. Subject:" << m_scene;
}

XmlAutosaveObserver::~XmlAutosaveObserver()
{
    if (m_pendingChanges && m_enabled) {
        saveNow(); // Save any pending changes before destruction
    }
    delete m_saveTimer;
}

void XmlAutosaveObserver::setFilename(const QString& filename)
{
    m_filename = filename;
    qDebug() << "XmlAutosaveObserver: Filename changed to" << m_filename;
}

void XmlAutosaveObserver::setDelay(int milliseconds)
{
    m_saveTimer->setInterval(milliseconds);
    qDebug() << "XmlAutosaveObserver: Delay changed to" << milliseconds << "ms";
}

void XmlAutosaveObserver::setEnabled(bool enabled)
{
    m_enabled = enabled;
    if (!enabled) {
        m_saveTimer->stop();
    }
    qDebug() << "XmlAutosaveObserver: Enabled =" << m_enabled;
}

void XmlAutosaveObserver::saveNow()
{
    m_saveTimer->stop();
    performAutosave();
}

void XmlAutosaveObserver::onNodeAdded(const Node& node)
{
    // Node added - minimal logging
    scheduleAutosave();
}

void XmlAutosaveObserver::onNodeRemoved(const QUuid& nodeId)
{
    Q_UNUSED(nodeId)
    scheduleAutosave();
}

void XmlAutosaveObserver::onNodeMoved(const QUuid& nodeId, QPointF oldPos, QPointF newPos)
{
    Q_UNUSED(nodeId)
    Q_UNUSED(oldPos)
    Q_UNUSED(newPos)
    scheduleAutosave();
}

void XmlAutosaveObserver::onEdgeAdded(const Edge& edge)
{
    // Edge added - minimal logging
    scheduleAutosave();
}

void XmlAutosaveObserver::onEdgeRemoved(const QUuid& edgeId)
{
    Q_UNUSED(edgeId)
    scheduleAutosave();
}

void XmlAutosaveObserver::onGraphCleared()
{
    scheduleAutosave();
}

void XmlAutosaveObserver::scheduleAutosave()
{
    if (!m_enabled) return;
    
    // OPTIMIZATION: Skip autosave scheduling during batch operations
    if (GraphSubject::isInBatch()) {
        qDebug().noquote() << "[AUTOSAVE] Skipping during batch mode";
        return;
    }
    
    m_pendingChanges = true;
    qDebug().noquote() << "[AUTOSAVE] markDirty() called. Timer started:" 
                       << m_saveTimer->interval() << "ms";
    m_saveTimer->start(); // Restart timer - delays save until activity stops
}

void XmlAutosaveObserver::performAutosave()
{
    qDebug().noquote() << "[AUTOSAVE] flushIfDirty() called. Enabled:" << m_enabled 
                       << "Pending:" << m_pendingChanges << "Scene:" << (m_scene ? "valid" : "NULL");
    
    if (!m_enabled || !m_pendingChanges || !m_scene) {
        return;
    }
    
    qDebug() << "XmlAutosaveObserver: Performing autosave to" << m_filename;
    
    QElapsedTimer timer;
    timer.start();
    
    // Create full XML serialization of the current graph
    QString xmlContent = generateFullXml();
    
    // Write to file (simplified)
    qDebug().noquote() << "[AUTOSAVE] writeAutosave() attempting to write to:" << m_filename;
    QFile file(m_filename);
    if (file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        QTextStream out(&file);
        out << xmlContent;
        file.close();
        
        qint64 elapsed = timer.elapsed();
        QFileInfo fileInfo(m_filename);
        qint64 fileSize = fileInfo.size();
        
        qDebug().noquote() << "[AUTOSAVE] writeAutosave() SUCCESS! File written to disk.";
        qDebug() << "✅ AUTOSAVE COMPLETE:";
        qDebug() << "   📁 File:" << fileInfo.fileName();
        qDebug() << "   ⏱️  Time:" << elapsed << "ms";
        qDebug() << "   📊 Size:" << (fileSize / 1024.0) << "KB";
        qDebug() << "   🔢 XML length:" << xmlContent.length() << "characters";
        
        m_pendingChanges = false;
    } else {
        qDebug().noquote() << "[AUTOSAVE] writeAutosave() FAILED! Cannot open file for writing.";
        qWarning() << "✗ XmlAutosaveObserver: Failed to save" << m_filename;
    }
}

QString XmlAutosaveObserver::generateFullXml() const
{
    if (!m_scene) {
        return "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<graph version=\"1.0\"/>\n";
    }
    
    // Create XML document
    xmlDocPtr doc = xmlNewDoc(BAD_CAST "1.0");
    xmlNodePtr root = xmlNewNode(nullptr, BAD_CAST "graph");
    xmlDocSetRootElement(doc, root);
    xmlSetProp(root, BAD_CAST "version", BAD_CAST "1.0");
    
    // Add nodes section
    xmlNodePtr nodesNode = xmlNewChild(root, nullptr, BAD_CAST "nodes", nullptr);
    for (auto it = m_scene->getNodes().begin(); it != m_scene->getNodes().end(); ++it) {
        Node* node = it.value();
        if (node) {
            xmlNodePtr nodeXml = node->write(doc, nullptr);
            if (nodeXml) {
                xmlAddChild(nodesNode, nodeXml);
            }
        }
    }
    
    // Add edges section
    xmlNodePtr edgesNode = xmlNewChild(root, nullptr, BAD_CAST "connections", nullptr);
    for (auto it = m_scene->getEdges().begin(); it != m_scene->getEdges().end(); ++it) {
        Edge* edge = it.value();
        if (edge) {
            xmlNodePtr edgeXml = edge->write(doc, nullptr);
            if (edgeXml) {
                xmlAddChild(edgesNode, edgeXml);
            }
        }
    }
    
    // Convert to string
    xmlChar* xmlBuffer;
    int bufferSize;
    xmlDocDumpFormatMemory(doc, &xmlBuffer, &bufferSize, 1);
    
    QString result = QString::fromUtf8(reinterpret_cast<const char*>(xmlBuffer));
    
    // Clean up
    xmlFree(xmlBuffer);
    xmlFreeDoc(doc);
    
    return result;
}

// ====================================
// FILE: xml_live_sync.cpp
// LAST MODIFIED: 2025-07-14 08:28:45
// ====================================

#include "xml_live_sync.h"
#include "scene.h"
#include "node.h"
#include "edge.h"
#include "socket.h"
#include <QDebug>
#include <QFile>
#include <libxml/xmlsave.h>

XmlLiveSync::XmlLiveSync(Scene* scene, xmlDocPtr xmlDocument)
    : m_scene(scene)
    , m_xmlDocument(xmlDocument)
    , m_enabled(true)
{
    if (!m_scene) {
        qCritical() << "XmlLiveSync: null scene provided";
        return;
    }
    
    if (!m_xmlDocument) {
        qCritical() << "XmlLiveSync: null XML document provided";
        return;
    }
    
    // Register as observer with the scene
    m_scene->attach(this);
    
    qDebug() << "✓ XmlLiveSync: Real-time XML synchronization enabled";
}

XmlLiveSync::~XmlLiveSync()
{
    if (m_scene) {
        m_scene->detach(this);
    }
    qDebug() << "✓ XmlLiveSync: Destroyed";
}

void XmlLiveSync::setEnabled(bool enabled)
{
    m_enabled = enabled;
    qDebug() << "XmlLiveSync:" << (enabled ? "ENABLED" : "DISABLED");
}

bool XmlLiveSync::saveToFile(const QString& filename)
{
    if (!m_xmlDocument) {
        qCritical() << "XmlLiveSync::saveToFile: No XML document";
        return false;
    }
    
    // Fast save - XML is already current
    xmlSaveCtxtPtr saveCtxt = xmlSaveToFilename(filename.toUtf8().constData(), "UTF-8", XML_SAVE_FORMAT);
    if (!saveCtxt) {
        qCritical() << "XmlLiveSync::saveToFile: Failed to create save context for" << filename;
        return false;
    }
    
    long bytesWritten = xmlSaveDoc(saveCtxt, m_xmlDocument);
    xmlSaveClose(saveCtxt);
    
    if (bytesWritten > 0) {
        qDebug() << "✓ XmlLiveSync: Fast save to" << filename << "(" << bytesWritten << "bytes)";
        return true;
    } else {
        qCritical() << "XmlLiveSync::saveToFile: Save failed for" << filename;
        return false;
    }
}

void XmlLiveSync::rebuildXmlFromScene()
{
    if (!m_enabled || !m_xmlDocument || !m_scene) return;
    
    qDebug() << "XmlLiveSync: Rebuilding XML from current scene state";
    
    // Clear existing XML content
    xmlNodePtr root = xmlDocGetRootElement(m_xmlDocument);
    if (root) {
        xmlUnlinkNode(root);
        xmlFreeNode(root);
    }
    
    // Create new root element
    root = xmlNewNode(nullptr, BAD_CAST "graph");
    xmlDocSetRootElement(m_xmlDocument, root);
    
    // Clear caches
    m_nodeXmlCache.clear();
    m_edgeXmlCache.clear();
    
    // Rebuild from scene
    const auto& nodes = m_scene->getNodes();
    const auto& edges = m_scene->getEdges();
    
    // Add all nodes
    for (auto it = nodes.constBegin(); it != nodes.constEnd(); ++it) {
        addNodeToXml(*it.value());
    }
    
    // Add all edges
    for (auto it = edges.constBegin(); it != edges.constEnd(); ++it) {
        addEdgeToXml(*it.value());
    }
    
    qDebug() << "✓ XmlLiveSync: Rebuilt XML with" << nodes.size() << "nodes," << edges.size() << "edges";
}

// GraphObserver interface implementations
void XmlLiveSync::onNodeAdded(const Node& node)
{
    if (!m_enabled) return;
    addNodeToXml(node);
    qDebug() << "XmlLiveSync: Added node" << node.getId().toString(QUuid::WithoutBraces).left(8) << "to XML";
}

void XmlLiveSync::onNodeRemoved(const QUuid& nodeId)
{
    if (!m_enabled) return;
    removeNodeFromXml(nodeId);
    qDebug() << "XmlLiveSync: Removed node" << nodeId.toString(QUuid::WithoutBraces).left(8) << "from XML";
}

void XmlLiveSync::onNodeMoved(const QUuid& nodeId, QPointF oldPos, QPointF newPos)
{
    if (!m_enabled) return;
    updateNodePositionInXml(nodeId, newPos);
    qDebug() << "XmlLiveSync: Updated node" << nodeId.toString(QUuid::WithoutBraces).left(8) 
             << "position" << oldPos << "→" << newPos;
}

void XmlLiveSync::onEdgeAdded(const Edge& edge)
{
    if (!m_enabled) return;
    addEdgeToXml(edge);
    qDebug() << "XmlLiveSync: Added edge" << edge.getId().toString(QUuid::WithoutBraces).left(8) << "to XML";
}

void XmlLiveSync::onEdgeRemoved(const QUuid& edgeId)
{
    if (!m_enabled) return;
    removeEdgeFromXml(edgeId);
    qDebug() << "XmlLiveSync: Removed edge" << edgeId.toString(QUuid::WithoutBraces).left(8) << "from XML";
}

void XmlLiveSync::onGraphCleared()
{
    if (!m_enabled) return;
    qDebug() << "XmlLiveSync: Graph cleared, rebuilding XML";
    rebuildXmlFromScene();
}

// Private implementation methods
xmlNodePtr XmlLiveSync::getOrCreateNodesElement()
{
    xmlNodePtr root = xmlDocGetRootElement(m_xmlDocument);
    if (!root) return nullptr;
    
    // Look for existing nodes element
    for (xmlNodePtr child = root->children; child; child = child->next) {
        if (child->type == XML_ELEMENT_NODE && 
            xmlStrcmp(child->name, BAD_CAST "nodes") == 0) {
            return child;
        }
    }
    
    // Create new nodes element
    xmlNodePtr nodesElement = xmlNewChild(root, nullptr, BAD_CAST "nodes", nullptr);
    return nodesElement;
}

xmlNodePtr XmlLiveSync::getOrCreateEdgesElement()
{
    xmlNodePtr root = xmlDocGetRootElement(m_xmlDocument);
    if (!root) return nullptr;
    
    // Look for existing edges element
    for (xmlNodePtr child = root->children; child; child = child->next) {
        if (child->type == XML_ELEMENT_NODE && 
            xmlStrcmp(child->name, BAD_CAST "edges") == 0) {
            return child;
        }
    }
    
    // Create new edges element
    xmlNodePtr edgesElement = xmlNewChild(root, nullptr, BAD_CAST "edges", nullptr);
    return edgesElement;
}

void XmlLiveSync::updateNodePositionInXml(const QUuid& nodeId, const QPointF& newPos)
{
    xmlNodePtr nodeXml = m_nodeXmlCache.value(nodeId, nullptr);
    if (!nodeXml) {
        nodeXml = findNodeXml(nodeId);
        if (nodeXml) {
            m_nodeXmlCache[nodeId] = nodeXml;
        }
    }
    
    if (nodeXml) {
        setXmlProperty(nodeXml, "x", QString::number(newPos.x()));
        setXmlProperty(nodeXml, "y", QString::number(newPos.y()));
    }
}

void XmlLiveSync::addNodeToXml(const Node& node)
{
    xmlNodePtr nodesElement = getOrCreateNodesElement();
    if (!nodesElement) return;
    
    xmlNodePtr nodeXml = xmlNewChild(nodesElement, nullptr, BAD_CAST "node", nullptr);
    if (!nodeXml) return;
    
    // Set node properties
    setXmlProperty(nodeXml, "id", node.getId().toString(QUuid::WithoutBraces));
    setXmlProperty(nodeXml, "type", node.getNodeType());
    setXmlProperty(nodeXml, "x", QString::number(node.pos().x()));
    setXmlProperty(nodeXml, "y", QString::number(node.pos().y()));
    // Count input/output sockets by iterating through all sockets
    int inputCount = 0, outputCount = 0;
    for (int i = 0; i < node.getSocketCount(); ++i) {
        Socket* socket = node.getSocketByIndex(i);
        if (socket) {
            if (socket->getRole() == Socket::Input) inputCount++;
            else if (socket->getRole() == Socket::Output) outputCount++;
        }
    }
    
    setXmlProperty(nodeXml, "inputs", QString::number(inputCount));
    setXmlProperty(nodeXml, "outputs", QString::number(outputCount));
    
    // Cache for fast updates
    m_nodeXmlCache[node.getId()] = nodeXml;
}

void XmlLiveSync::removeNodeFromXml(const QUuid& nodeId)
{
    xmlNodePtr nodeXml = m_nodeXmlCache.value(nodeId, nullptr);
    if (!nodeXml) {
        nodeXml = findNodeXml(nodeId);
    }
    
    if (nodeXml) {
        xmlUnlinkNode(nodeXml);
        xmlFreeNode(nodeXml);
        m_nodeXmlCache.remove(nodeId);
    }
}

void XmlLiveSync::addEdgeToXml(const Edge& edge)
{
    xmlNodePtr edgesElement = getOrCreateEdgesElement();
    if (!edgesElement) return;
    
    xmlNodePtr edgeXml = xmlNewChild(edgesElement, nullptr, BAD_CAST "edge", nullptr);
    if (!edgeXml) return;
    
    // Get edge connection data
    Node* fromNode = edge.getFromNode();
    Node* toNode = edge.getToNode();
    
    if (fromNode && toNode) {
        setXmlProperty(edgeXml, "id", edge.getId().toString(QUuid::WithoutBraces));
        setXmlProperty(edgeXml, "fromNode", fromNode->getId().toString(QUuid::WithoutBraces));
        setXmlProperty(edgeXml, "toNode", toNode->getId().toString(QUuid::WithoutBraces));
        
        // Get actual socket indices from edge
        setXmlProperty(edgeXml, "fromSocketIndex", QString::number(edge.getFromSocketIndex()));
        setXmlProperty(edgeXml, "toSocketIndex", QString::number(edge.getToSocketIndex()));
        
        // Cache for fast updates
        m_edgeXmlCache[edge.getId()] = edgeXml;
    }
}

void XmlLiveSync::removeEdgeFromXml(const QUuid& edgeId)
{
    xmlNodePtr edgeXml = m_edgeXmlCache.value(edgeId, nullptr);
    if (!edgeXml) {
        edgeXml = findEdgeXml(edgeId);
    }
    
    if (edgeXml) {
        xmlUnlinkNode(edgeXml);
        xmlFreeNode(edgeXml);
        m_edgeXmlCache.remove(edgeId);
    }
}

xmlNodePtr XmlLiveSync::findNodeXml(const QUuid& nodeId)
{
    xmlNodePtr nodesElement = getOrCreateNodesElement();
    if (!nodesElement) return nullptr;
    
    QString nodeIdStr = nodeId.toString(QUuid::WithoutBraces);
    
    for (xmlNodePtr child = nodesElement->children; child; child = child->next) {
        if (child->type == XML_ELEMENT_NODE && 
            xmlStrcmp(child->name, BAD_CAST "node") == 0) {
            
            QString id = getXmlProperty(child, "id");
            if (id == nodeIdStr) {
                return child;
            }
        }
    }
    return nullptr;
}

xmlNodePtr XmlLiveSync::findEdgeXml(const QUuid& edgeId)
{
    xmlNodePtr edgesElement = getOrCreateEdgesElement();
    if (!edgesElement) return nullptr;
    
    QString edgeIdStr = edgeId.toString(QUuid::WithoutBraces);
    
    for (xmlNodePtr child = edgesElement->children; child; child = child->next) {
        if (child->type == XML_ELEMENT_NODE && 
            xmlStrcmp(child->name, BAD_CAST "edge") == 0) {
            
            QString id = getXmlProperty(child, "id");
            if (id == edgeIdStr) {
                return child;
            }
        }
    }
    return nullptr;
}

void XmlLiveSync::setXmlProperty(xmlNodePtr node, const QString& name, const QString& value)
{
    if (node && !name.isEmpty()) {
        xmlSetProp(node, BAD_CAST name.toUtf8().constData(), BAD_CAST value.toUtf8().constData());
    }
}

QString XmlLiveSync::getXmlProperty(xmlNodePtr node, const QString& name)
{
    if (!node || name.isEmpty()) return QString();
    
    xmlChar* prop = xmlGetProp(node, BAD_CAST name.toUtf8().constData());
    if (prop) {
        QString result = QString::fromUtf8((char*)prop);
        xmlFree(prop);
        return result;
    }
    return QString();
}


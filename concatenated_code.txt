/// ===== FILE: node.h =====
#pragma once

#include <QGraphicsItem>
#include <QGraphicsScene>
#include <QPainter>
#include <QStyleOptionGraphicsItem>
#include <QWidget>
#include <QUuid>
#include <QPointF>
#include <QString>
#include <QVector>
#include <QRectF>
#include <QSizeF>
#include <QColor>
#include <QSet>
#include <libxml/tree.h>

// Forward declarations to avoid circular includes
class Socket;
class Edge;
class GraphFactory;

/**
 * Node - A self-serializing visual node
 * 
 * Core principles:
 * - Self-serialization via write()/read() methods
 * - Value semantics, no smart pointers
 * - No QObject inheritance or connect usage
 * - Sockets are children of nodes only
 * - Uses Qt containers instead of std library
 */
class Node : public QGraphicsItem
{
public:
    // QGraphicsItem type system (required by Qt, DO NOT USE in logic)
    // Policy: Use Gik::KindKey metadata instead of type() for type checking
    enum { Type = UserType + 1 };
    int type() const override { return Type; }

    Node(const QUuid& id = QUuid::createUuid(),
         const QPointF& position = QPointF(100, 100));
    ~Node(); // Destructor for safe edge invalidation

    // Core identity
    const QUuid& getId() const { return m_id; }
    
    // Self-serialization interface
    xmlNodePtr write(xmlDocPtr doc, xmlNodePtr repr = nullptr) const;
    virtual void read(xmlNodePtr node);
    
    // QGraphicsItem interface
    QRectF boundingRect() const override;
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) override;
    
    // Movement tracking for live XML updates
    QVariant itemChange(GraphicsItemChange change, const QVariant &value) override;
    
    // Node properties
    void setNodeSize(qreal width, qreal height);
    QSizeF getNodeSize() const { return QSizeF(m_width, m_height); }
    
    // Visual state - using Qt's selection system
    // Use QGraphicsItem::isSelected() and setSelected()
    
    // Socket management - O(1) performance
    Socket* getSocketByIndex(int index) const;
    int getSocketCount() const;
    void setNodeType(const QString& type);
    QString getNodeType() const { return m_nodeType; }
    
    // Socket registration for performance cache
    void registerSocket(Socket* socket, int index);
    
    // XML-driven socket creation
    void createSocketsFromXml(int inputCount, int outputCount);
    
    // ✅ Two-phase positioning: Position all sockets with complete information
    void positionAllSockets(int totalInputs, int totalOutputs);
    
    // Change notification - simple callback, no connect
    void setChangeCallback(void (*callback)(Node*));
    
    // Factory tracking for contract enforcement (type-safe)
    void setFactory(GraphFactory* factory) { m_factory = factory; }
    bool hasFactory() const { return m_factory != nullptr; }
    GraphFactory* getFactory() const { return m_factory; }
    
    // Edge connection management - O(degree) performance optimization
    void registerEdge(Edge* edge);
    void unregisterEdge(Edge* edge);
    void updateConnectedEdges();
    
    // Debug/testing helper
    int getIncidentEdgeCount() const { return m_incidentEdges.size(); }

private:
    QUuid m_id;
    QString m_nodeType;
    qreal m_width;
    qreal m_height;
    
    // Performance optimization: cache display string (created once, not every frame)
    mutable QString m_cachedDisplayId;
    
    // Socket cache for O(1) lookups - critical performance fix
    QVector<Socket*> m_sockets;  // Indexed by socket index for O(1) access
    
    // Edge adjacency set for O(degree) edge updates - performance optimization
    QSet<Edge*> m_incidentEdges;  // Edges touching this node (cleaned up by Edge destructor)
    
    // Simple callback - no QObject connect
    void (*m_changeCallback)(Node*);

    // Factory pointer for contract enforcement (type-safe, non-owning)
    GraphFactory* m_factory;
    
    // Per-node position tracking (fixes global static bug)
    QPointF m_lastPos;
    
    // Dynamic node sizing based on socket count
    void calculateNodeSize(int inputCount, int outputCount);
    
    // Socket creation
    void createStaticSockets();
    
    // Visual styling helpers
    void paintSockets(QPainter* painter) const;
};


/// ===== FILE: node.cpp =====
#include "node.h"
#include "socket.h"
#include "edge.h"
#include "scene.h"
#include "graphics_item_keys.h"
#include "layout_metrics.h"
#include "log_context.h"
#include <QPainter>
#include <QStyleOptionGraphicsItem>
#include <QWidget>
#include <QDebug>
#include <QTimer>
#include <libxml/tree.h>

Node::Node(const QUuid& id, const QPointF& position)
    : m_id(id)
    , m_nodeType("DEFAULT")
    , m_width(80.0)
    , m_height(50.0)
    , m_changeCallback(nullptr)
    , m_factory(nullptr)
    , m_lastPos(position)
{
    setPos(position);
    setFlag(QGraphicsItem::ItemIsMovable, true);
    setFlag(QGraphicsItem::ItemIsSelectable, true);
    setFlag(QGraphicsItem::ItemSendsGeometryChanges, true);

    // Metadata annotations for cast-free identification
    setData(Gik::KindKey, Gik::Kind_Node);
    setData(Gik::UuidKey, m_id.toString(QUuid::WithoutBraces));

    // Node creation logging removed - working correctly
}

Node::~Node()
{
    // SAFETY: Invalidate all connected edges before destruction
    // Copy the set to avoid modification during iteration
    QSet<Edge*> edgesCopy = m_incidentEdges;
    for (Edge* edge : edgesCopy) {
        edge->invalidateNode(this);
    }
    
    // Node destruction logging removed - working correctly
}

QRectF Node::boundingRect() const
{
    return QRectF(0, 0, m_width, m_height);
}

void Node::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
    Q_UNUSED(option)
    Q_UNUSED(widget)
    
    QRectF rect = boundingRect();
    
    // Draw node body with rounded corners and gradient
    painter->setRenderHint(QPainter::Antialiasing);
    
    // Enhanced selection highlight using Qt's selection system
    if (isSelected()) {
        // Draw selection glow effect
        painter->setPen(QPen(QColor(255, 69, 0), 6)); // Thick orange border
        painter->setBrush(QColor(255, 245, 205)); // Light orange background
        
        // Add outer glow
        QRectF glowRect = rect.adjusted(-3, -3, 3, 3);
        painter->setPen(QPen(QColor(255, 69, 0, 100), 8));
        painter->drawRoundedRect(glowRect, 10.0, 10.0);
        
        // Restore main border
        painter->setPen(QPen(QColor(255, 69, 0), 4));
    } else {
        painter->setPen(QPen(Qt::darkGray, 2));
        painter->setBrush(QColor(240, 240, 240)); // Light gray background
    }
    
    painter->drawRoundedRect(rect, 8.0, 8.0);
    
    // Draw node type with improved typography
    painter->setPen(Qt::black);
    
    // Performance optimization: static font (created once, not every frame)
    static const QFont nodeFont("Arial", 8, QFont::Bold);
    painter->setFont(nodeFont);
    
    // Draw node type instead of UUID
    QString displayText = m_nodeType;
    painter->drawText(rect, Qt::AlignCenter, displayText);
    
    // Draw subtle node ID below type (smaller)
    if (rect.height() > 35) {
        // Performance optimization: cache display string (created once, not every frame)
        if (m_cachedDisplayId.isEmpty()) {
            m_cachedDisplayId = m_id.toString(QUuid::WithoutBraces).left(6);
        }
        
        static const QFont idFont("Arial", 6);
        painter->setFont(idFont);
        painter->setPen(QColor(120, 120, 120));
        
        QRectF idRect = rect.adjusted(0, rect.height() * 0.6, 0, 0);
        painter->drawText(idRect, Qt::AlignCenter, m_cachedDisplayId);
    }
}

QVariant Node::itemChange(GraphicsItemChange change, const QVariant &value)
{
    if (change == ItemSelectedHasChanged) {
        // Selection tracking logging - what has been selected
        bool isNowSelected = value.toBool();
        LOG_NODE_SIMPLE() << (isNowSelected ? "SELECT" : "DESELECT") << m_nodeType;
        
        // Trigger visual update when selection changes
        update();
    } else if (change == ItemPositionHasChanged) {
        // Only update edges when position actually changes significantly
        QPointF currentPos = value.toPointF();
        if ((currentPos - m_lastPos).manhattanLength() > LayoutMetrics::edgeUpdateThreshold) {
            QPointF oldPos = m_lastPos;
            m_lastPos = currentPos;
            
            // Re-enabled with safer edge updates
            updateConnectedEdges();
            
            // Notify observers of node movement via scene
            if (Scene* typedScene = qobject_cast<Scene*>(scene())) {
                typedScene->notifyNodeMoved(m_id, oldPos, currentPos);
            }
        }
        
        if (m_changeCallback) {
            m_changeCallback(this);
        }
    }
    return QGraphicsItem::itemChange(change, value);
}

void Node::setNodeSize(qreal width, qreal height)
{
    prepareGeometryChange();
    m_width = width;
    m_height = height;
    update();
}

// Removed manual setSelected - using Qt's selection system

void Node::setNodeType(const QString& type)
{
    m_nodeType = type;
    createStaticSockets();
    update();
    
    qDebug() << "Node" << m_id.toString(QUuid::WithoutBraces).left(8) << "type:" << type;
}

void Node::createStaticSockets()
{
    // CRITICAL: Delete edges connected to this node BEFORE deleting sockets
    Scene* typedScene = qobject_cast<Scene*>(scene());
    if (typedScene) {
        QList<QUuid> edgesToDelete;
        for (auto it = typedScene->getEdges().begin(); it != typedScene->getEdges().end(); ++it) {
            Edge* edge = it.value();
            if (edge->isConnectedToNode(m_id)) {
                edgesToDelete.append(it.key());
            }
        }
        // Delete edges that reference old sockets
        for (const QUuid& edgeId : edgesToDelete) {
            typedScene->removeEdgeInternal(edgeId);
        }
        qDebug() << "Node::createStaticSockets - removed" << edgesToDelete.size() 
                 << "edges before socket recreation for node" << m_id.toString(QUuid::WithoutBraces).left(8);
    }
    
    // Remove existing sockets (Qt will auto-delete child items)
    for (QGraphicsItem* child : childItems()) {
        if (qgraphicsitem_cast<Socket*>(child)) {
            delete child;  // Qt removes from parent automatically
        }
    }
    m_sockets.clear();  // Clear cache to prevent dangling pointers
    
    // This method now does nothing - sockets are created during XML read()
    // based on XML attributes like inputs="2" outputs="3"
}

void Node::createSocketsFromXml(int inputCount, int outputCount)
{
    // CRITICAL: Delete edges connected to this node BEFORE deleting sockets
    // Otherwise edges keep stale Socket* pointers and crash on updatePath()
    Scene* typedScene = qobject_cast<Scene*>(scene());
    if (typedScene) {
        QList<QUuid> edgesToDelete;
        for (auto it = typedScene->getEdges().begin(); it != typedScene->getEdges().end(); ++it) {
            Edge* edge = it.value();
            if (edge->isConnectedToNode(m_id)) {
                edgesToDelete.append(it.key());
            }
        }
        // Delete edges that reference old sockets
        for (const QUuid& edgeId : edgesToDelete) {
            typedScene->removeEdgeInternal(edgeId);
        }
        qDebug() << "Node::createSocketsFromXml - removed" << edgesToDelete.size() 
                 << "edges before socket recreation for node" << m_id.toString(QUuid::WithoutBraces).left(8);
    }
    
    // Clear existing sockets - both graphics items AND cache
    for (QGraphicsItem* child : childItems()) {
        if (qgraphicsitem_cast<Socket*>(child)) {
            delete child;  // Qt removes from parent automatically
        }
    }
    m_sockets.clear();  // Clear cache to prevent dangling pointers
    
    // Calculate dynamic node size based on socket count
    calculateNodeSize(inputCount, outputCount);
    
    // Phase 1: Create all socket objects (no positioning yet)
    int socketIndex = 0;
    
    // Create input sockets (indexes 0, 1, 2, ...)
    for (int i = 0; i < inputCount; ++i) {
        Socket* inputSocket = new Socket(Socket::Input, this, socketIndex++);
        // Register socket with scene if node was created by factory
        if (hasFactory()) {
            Scene* scene = qobject_cast<Scene*>(this->scene());
            if (scene) {
                scene->addSocket(inputSocket);
            }
        }
    }

    // Create output sockets (continuing index sequence)
    for (int i = 0; i < outputCount; ++i) {
        Socket* outputSocket = new Socket(Socket::Output, this, socketIndex++);
        // Register socket with scene if node was created by factory
        if (hasFactory()) {
            Scene* scene = qobject_cast<Scene*>(this->scene());
            if (scene) {
                scene->addSocket(outputSocket);
            }
        }
    }
    
    // Phase 2: Position all sockets with complete information
    positionAllSockets(inputCount, outputCount);
    
    qDebug() << "Node" << m_id.toString(QUuid::WithoutBraces).left(8) << inputCount << "IN" << outputCount << "OUT";
}

void Node::positionAllSockets(int totalInputs, int totalOutputs)
{
    // Parse-then-position architecture: Position all sockets with complete information
    // Uses K/O formula: max((2*K + 1), (2*O + 1)) × socketSize with BALANCED CENTERING
    
    // ✅ Get actual socket size from existing socket - no fallbacks or magic numbers
    if (m_sockets.isEmpty()) {
        qWarning() << "Node::positionAllSockets() called with no sockets available";
        return;
    }
    
    QSizeF actualSocketSize = m_sockets[0]->getSocketSize();
    qreal socketSize = qMax(actualSocketSize.width(), actualSocketSize.height());

    const qreal socketOffset = LayoutMetrics::socketOffsetFromEdge;

    QRectF nodeRect = boundingRect();
    int inputIndex = 0;
    int outputIndex = 0;
    
    // VIRTUAL BOUNDING BOX APPROACH: Create centered virtual boxes for socket placement
    qreal nodeHeight = nodeRect.height();
    qreal nodeCenterY = nodeHeight * 0.6; // Visual center, moved down from geometric center
    
    // Create virtual bounding boxes for each socket group using (2*n + 1) * socketSize formula
    qreal inputBoxHeight = (totalInputs > 0) ? (2 * totalInputs + 1) * socketSize : 0;
    qreal outputBoxHeight = (totalOutputs > 0) ? (2 * totalOutputs + 1) * socketSize : 0;
    
    // Align the horizontal center lines: socket box center = node center
    qreal inputBoxCenterY = nodeCenterY;
    qreal outputBoxCenterY = nodeCenterY;
    qreal inputBoxStartY = inputBoxCenterY - (inputBoxHeight / 2.0);
    qreal outputBoxStartY = outputBoxCenterY - (outputBoxHeight / 2.0);
    
    // Calculate socket positions using balanced centering
    for (Socket* socket : m_sockets) {
        if (!socket) continue;
        
        if (socket->getRole() == Socket::Input) {
            // Place socket within the centered virtual input bounding box
            qreal x = -socketOffset;  // Left side of node
            qreal y = inputBoxStartY + socketSize * (2 * inputIndex + 1); // Position at center of each slot
            
            socket->setDirectPosition(x, y);
            inputIndex++;
            
            qDebug() << "VIRTUAL BOX INPUT socket" << inputIndex-1 << "positioned at" << QPointF(x, y);
        } else {
            // Place socket within the centered virtual output bounding box  
            qreal x = nodeRect.width() + socketOffset;  // Right side of node
            qreal y = outputBoxStartY + socketSize * (2 * outputIndex + 1); // Position at center of each slot
            
            socket->setDirectPosition(x, y);
            outputIndex++;
            
            qDebug() << "VIRTUAL BOX OUTPUT socket" << outputIndex-1 << "positioned at" << QPointF(x, y);
        }
    }
    
    // Verify balanced positioning
    qreal requiredInputHeight = (totalInputs > 0) ? (2 * totalInputs + 1) * socketSize : 0;
    qreal requiredOutputHeight = (totalOutputs > 0) ? (2 * totalOutputs + 1) * socketSize : 0;
    qreal requiredHeight = qMax(requiredInputHeight, requiredOutputHeight);
    
    qDebug() << "VIRTUAL BOX POSITIONING: K=" << totalInputs << "inputs (box start:" << inputBoxStartY 
             << "), O=" << totalOutputs << "outputs (box start:" << outputBoxStartY << ")"
             << "| Node height:" << nodeHeight << "| Required:" << requiredHeight
             << "for node" << m_id.toString(QUuid::WithoutBraces).left(8);
}

Socket* Node::getSocketByIndex(int index) const
{
    // O(1) socket lookup using cache - with safety validation
    if (index >= 0 && index < m_sockets.size()) {
        Socket* socket = m_sockets[index];
        if (!socket) {
            qCritical() << "Node::getSocketByIndex() - null socket at index" << index 
                       << "in node" << m_id.toString(QUuid::WithoutBraces).left(8);
            return nullptr;
        }
        // Belt-and-suspenders: check if socket has been deleted
        if (socket->scene() == nullptr) {
            qWarning() << "Node::getSocketByIndex() - socket at index" << index 
                      << "has been deleted (not in scene) in node" << m_id.toString(QUuid::WithoutBraces).left(8);
            return nullptr;
        }
        return socket;
    }
    qWarning() << "Node::getSocketByIndex() - index" << index << "out of bounds [0," 
               << m_sockets.size() << ") in node" << m_id.toString(QUuid::WithoutBraces).left(8);
    return nullptr;
}

int Node::getSocketCount() const
{
    // O(1) socket count using cache
    return m_sockets.size();
}

void Node::registerSocket(Socket* socket, int index)
{
    if (!socket) {
        qCritical() << "Node::registerSocket() - null socket passed for index" << index;
        return;
    }
    
    // Enforce contiguous indices - prevent sparse arrays with nullptr gaps
    if (index != m_sockets.size()) {
        qCritical() << "Node::registerSocket() - index" << index 
                   << "is not contiguous. Expected index" << m_sockets.size() 
                   << "for node" << m_id.toString(QUuid::WithoutBraces).left(8);
        Q_ASSERT(index == m_sockets.size());
        return;
    }
    
    // Append socket to maintain contiguous array
    m_sockets.append(socket);
    
    qDebug() << "Node" << m_id.toString(QUuid::WithoutBraces).left(8) << "socket" << index 
             << (socket->getRole() == Socket::Input ? "IN" : "OUT");
}

void Node::setChangeCallback(void (*callback)(Node*))
{
    m_changeCallback = callback;
}

// ============================================================================
// Edge Management - O(degree) Performance Optimization
// ============================================================================

void Node::registerEdge(Edge* edge)
{
    if (!edge) {
        qWarning() << "Node::registerEdge() - null edge pointer for node" << m_id.toString(QUuid::WithoutBraces).left(8);
        return;
    }
    
    // Debug assertion in development builds
    #ifdef QT_DEBUG
    if (m_incidentEdges.contains(edge)) {
        qWarning() << "Node::registerEdge() - edge already registered with node" << m_id.toString(QUuid::WithoutBraces).left(8);
        return;
    }
    #endif
    
    m_incidentEdges.insert(edge);
    // Edge registration logging removed - working correctly
}

void Node::unregisterEdge(Edge* edge)
{
    if (!edge) {
        qWarning() << "Node::unregisterEdge() - null edge pointer for node" << m_id.toString(QUuid::WithoutBraces).left(8);
        return;
    }
    
    // Debug assertion in development builds
    #ifdef QT_DEBUG
    if (!m_incidentEdges.contains(edge)) {
        qWarning() << "Node::unregisterEdge() - edge not found in node" << m_id.toString(QUuid::WithoutBraces).left(8);
        return;
    }
    #endif
    
    m_incidentEdges.remove(edge);
    // Edge unregistration logging removed - working correctly
}

void Node::updateConnectedEdges()
{
    // NEW: O(degree) performance - only update edges actually connected to this node
    for (Edge* edge : m_incidentEdges) {
        edge->updatePath();
    }
    
    // Edge update logging removed - working correctly
}


// Sockets now paint themselves as QGraphicsItems - no need for this method

xmlNodePtr Node::write(xmlDocPtr doc, xmlNodePtr repr) const
{
    xmlNodePtr node = xmlNewNode(nullptr, BAD_CAST "node");
    
    // Core attributes
    xmlSetProp(node, BAD_CAST "id", BAD_CAST m_id.toString(QUuid::WithoutBraces).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "x", BAD_CAST QString::number(pos().x()).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "y", BAD_CAST QString::number(pos().y()).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "type", BAD_CAST m_nodeType.toUtf8().constData());
    
    // Count sockets by role
    int inputCount = 0, outputCount = 0;
    for (QGraphicsItem* child : childItems()) {
        if (Socket* socket = qgraphicsitem_cast<Socket*>(child)) {
            if (socket->getRole() == Socket::Input) inputCount++;
            else if (socket->getRole() == Socket::Output) outputCount++;
        }
    }
    
    // Save socket configuration as XML attributes
    xmlSetProp(node, BAD_CAST "inputs", BAD_CAST QString::number(inputCount).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "outputs", BAD_CAST QString::number(outputCount).toUtf8().constData());
    
    if (repr) {
        xmlAddChild(repr, node);
    } else {
        xmlDocSetRootElement(doc, node);
    }
    
    return node;
}

void Node::read(xmlNodePtr node)
{
    if (!node) return;
    
    // Read UUID
    xmlChar* idStr = xmlGetProp(node, BAD_CAST "id");
    if (idStr) {
        m_id = QUuid(QString::fromUtf8((char*)idStr));
        // ✅ CRITICAL: Update metadata when UUID changes from XML
        setData(Gik::UuidKey, m_id.toString(QUuid::WithoutBraces));
        // ✅ CRITICAL: Invalidate cached display ID when UUID changes
        m_cachedDisplayId.clear();
        xmlFree(idStr);
    }
    
    // Read node type 
    xmlChar* typeStr = xmlGetProp(node, BAD_CAST "type");
    if (typeStr) {
        m_nodeType = QString::fromUtf8((char*)typeStr);
        xmlFree(typeStr);
    }
    
    // Read socket configuration from XML attributes
    int inputCount = 1;  // Default
    int outputCount = 1; // Default
    
    xmlChar* inputsStr = xmlGetProp(node, BAD_CAST "inputs");
    if (inputsStr) {
        inputCount = QString::fromUtf8((char*)inputsStr).toInt();
        xmlFree(inputsStr);
    }
    
    xmlChar* outputsStr = xmlGetProp(node, BAD_CAST "outputs");
    if (outputsStr) {
        outputCount = QString::fromUtf8((char*)outputsStr).toInt();
        xmlFree(outputsStr);
    }
    
    // Create sockets based on XML configuration
    createSocketsFromXml(inputCount, outputCount);
    
    // Read position
    xmlChar* xStr = xmlGetProp(node, BAD_CAST "x");
    xmlChar* yStr = xmlGetProp(node, BAD_CAST "y");
    if (xStr && yStr) {
        qreal x = QString::fromUtf8((char*)xStr).toDouble();
        qreal y = QString::fromUtf8((char*)yStr).toDouble();
        setPos(x, y);
        xmlFree(xStr);
        xmlFree(yStr);
    }
    
    update();
}

void Node::calculateNodeSize(int inputCount, int outputCount)
{
    // ✅ CRITICAL: Notify Qt BSP cache BEFORE changing geometry
    prepareGeometryChange();

    // Calculate required height based on socket count
    int maxSockets = qMax(inputCount, outputCount);

    // Use centralized layout metrics
    const qreal socketSpacing = LayoutMetrics::socketSpacing;
    const qreal minNodeHeight = LayoutMetrics::minNodeHeight;
    const qreal topPadding = LayoutMetrics::nodePaddingTop;
    const qreal bottomPadding = LayoutMetrics::nodePaddingBottom;
    const qreal minNodeWidth = LayoutMetrics::minNodeWidth;

    // Calculate height based on socket count
    if (maxSockets > 0) {
        // Height = top padding + (sockets * spacing) + bottom padding
        qreal requiredHeight = topPadding + (maxSockets - 1) * socketSpacing + LayoutMetrics::socketDiameter + bottomPadding;
        m_height = qMax(minNodeHeight, requiredHeight);
    } else {
        m_height = minNodeHeight;
    }

    // Calculate width based on node type and content
    QString displayText = m_nodeType + " " + m_id.toString(QUuid::WithoutBraces).left(8);
    QFont font("Arial", 10);
    QFontMetrics metrics(font);
    qreal textWidth = metrics.horizontalAdvance(displayText) + 20; // Add padding

    m_width = qMax(minNodeWidth, textWidth);

    // Ensure node is wide enough to accommodate sockets with proper spacing
    m_width = qMax(m_width, LayoutMetrics::socketDiameter * 2 + 20); // Minimum width for sockets
    
    qDebug() << "Node" << m_id.toString(QUuid::WithoutBraces).left(8) 
             << "resized to" << m_width << "x" << m_height 
             << "for" << inputCount << "inputs," << outputCount << "outputs";
}


/// ===== FILE: socket.h =====
#pragma once

#include <QGraphicsItem>
#include <QPainter>
#include <QStyleOptionGraphicsItem>
#include <QWidget>
#include <QGraphicsSceneMouseEvent>
#include <QUuid>
#include <QPointF>
#include <QString>
#include <QColor>
#include <QRectF>
#include <libxml/tree.h>

class Node;
class Edge;

/**
 * Socket - QGraphicsItem connection point on a node
 * 
 * Core principles:
 * - QGraphicsItem child of Node QGraphicsItem
 * - Self-serializing like its parent node
 * - Handles mouse events for connection creation
 * - Position managed by Qt parent-child system
 * - Index-based identification within parent node
 */
class Socket : public QGraphicsItem
{
public:
    enum Role {
        Input,
        Output
    };
    
    enum ConnectionState {
        Disconnected,
        Connecting,    // During ghost edge drag
        Connected,     // Has connected edge
        Highlighted    // Target of ghost edge
    };
    
    // Helper for debugging
    static const char* roleToString(Role role) {
        switch (role) {
            case Input: return "INPUT";
            case Output: return "OUTPUT";
            default: return "UNKNOWN";
        }
    }
    
    Socket(Role role, Node* parentNode, int index);
    
    // Core identity - NO UUID, just index within parent node
    int getIndex() const { return m_index; }
    Role getRole() const { return m_role; }
    // Access parent node via Qt's system  
    Node* getParentNode() const;
    
    // Self-serialization interface
    xmlNodePtr write(xmlDocPtr doc, xmlNodePtr repr = nullptr) const;
    void read(xmlNodePtr node);
    
    // QGraphicsItem interface
    QRectF boundingRect() const override;
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) override;
    
    // Mouse events for connection creation
    void mousePressEvent(QGraphicsSceneMouseEvent *event) override;
    void mouseReleaseEvent(QGraphicsSceneMouseEvent *event) override;
    void hoverEnterEvent(QGraphicsSceneHoverEvent *event) override;
    void hoverLeaveEvent(QGraphicsSceneHoverEvent *event) override;
    
    // Connection state
    bool isConnected() const { return m_connectedEdge != nullptr; }
    void setConnectedEdge(Edge* edge) { m_connectedEdge = edge; updateConnectionState(); }
    Edge* getConnectedEdge() const { return m_connectedEdge; }
    
    // Visual connection state
    ConnectionState getConnectionState() const { return m_connectionState; }
    void setConnectionState(ConnectionState state) { m_connectionState = state; update(); }
    void updateConnectionState() { 
        setConnectionState(m_connectedEdge ? Connected : Disconnected); 
    }
    
    // ✅ Direct position assignment - no calculations, just assignment
    void setDirectPosition(qreal x, qreal y) { setPos(x, y); }
    
    // Size properties for edge connection calculations
    qreal getRadius() const { return m_radius; }
    QSizeF getSocketSize() const { return boundingRect().size(); }
    
    // Visual state for drag-and-drop feedback (disabled)
    // VisualState getVisualState() const { return m_visualState; }
    // void setVisualState(VisualState state) { m_visualState = state; update(); }

private:
    Role m_role;
    int m_index;                 // Socket index within parent node (0, 1, 2...)
    Node* m_parentNode;          // Cached parent pointer (avoid qgraphicsitem_cast)
    Edge* m_connectedEdge;       // Connected edge (if any)
    ConnectionState m_connectionState; // Visual connection state
    qreal m_radius;
    bool m_hovered;
    qreal m_hoverOpacity; // Smooth hover opacity transition
    bool m_pressed; // Click feedback state

    // Performance optimization: cache index string (created once, not every frame)
    mutable QString m_cachedIndexString;
    
};


/// ===== FILE: socket.cpp =====
#include "socket.h"
#include "node.h"
#include "edge.h"
#include "scene.h"
#include "graphics_item_keys.h"
#include "layout_metrics.h"
#include <QPainter>
#include <QGraphicsSceneMouseEvent>
#include <QDebug>
#include <QDateTime>
#include <QtMath>

Socket::Socket(Role role, Node* parentNode, int index)
    : QGraphicsItem(parentNode)
    , m_role(role)
    , m_index(index)
    , m_parentNode(parentNode)
    , m_connectedEdge(nullptr)
    , m_connectionState(Disconnected)
    , m_radius(LayoutMetrics::socketRadius)
    , m_hovered(false)
    , m_hoverOpacity(0.0)
    , m_pressed(false)
{
    setAcceptHoverEvents(true);
    // ✅ Sockets should NOT be selectable - only nodes and edges
    // This prevents sockets from stealing selection from their parent node
    setFlag(QGraphicsItem::ItemIsSelectable, false);

    // ✅ Set socket z-order: above nodes (0) but below edges (2)
    setZValue(1);

    // ✅ Cast-free design: Set metadata for type checking without qgraphicsitem_cast
    setData(Gik::KindKey, Gik::Kind_Socket);

    // ✅ NO positioning in constructor - will be positioned later with complete information

    // Register with parent node for O(1) lookups
    if (parentNode) {
        parentNode->registerSocket(this, m_index);
    }

    qDebug() << "+Socket" << m_index << (m_role == Input ? "IN" : "OUT");
}

Node* Socket::getParentNode() const
{
    // Cast-free: return cached parent pointer
    return m_parentNode;
}

QRectF Socket::boundingRect() const
{
    // Smaller rounded square sockets with better proportions
    return QRectF(-7, -7, 14, 14);
}

void Socket::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
    Q_UNUSED(option)
    Q_UNUSED(widget)
    
    painter->setRenderHint(QPainter::Antialiasing);
    
    // Color-coded sockets like upper level system
    QColor socketColor;
    QColor borderColor;
    
    if (m_role == Input) {
        socketColor = QColor(100, 149, 237); // Cornflower blue
        borderColor = QColor(70, 130, 180);  // Steel blue
    } else {
        socketColor = QColor(220, 20, 60);    // Crimson red
        borderColor = QColor(178, 34, 34);    // Fire brick
    }
    
    // Add smooth hover effect with opacity
    if (m_hovered || m_hoverOpacity > 0.0) {
        qreal hoverAmount = m_hovered ? 1.0 : m_hoverOpacity;
        socketColor = QColor::fromRgb(
            socketColor.red() + (50 * hoverAmount),
            socketColor.green() + (50 * hoverAmount),
            socketColor.blue() + (50 * hoverAmount)
        );
        borderColor = QColor::fromRgb(
            borderColor.red() + (30 * hoverAmount),
            borderColor.green() + (30 * hoverAmount),
            borderColor.blue() + (30 * hoverAmount)
        );
    }
    
    // Draw socket as circular with enhanced styling
    QRectF rect = boundingRect();
    
    // Apply pressed state effect
    if (m_pressed) {
        socketColor = socketColor.darker(120);
        borderColor = borderColor.darker(120);
        rect = rect.adjusted(1, 1, -1, -1); // Slight inset when pressed
    }
    
    // Add connection state visual feedback
    switch (m_connectionState) {
        case Connected:
            {
                // ✅ ENHANCED: Clear visual feedback for connected sockets
                
                // Draw socket body (slightly dimmed to show "occupied" state)
                painter->setBrush(socketColor.darker(110));
                painter->setPen(QPen(borderColor, 2));
                painter->drawRoundedRect(rect, 3.0, 3.0);
                
                // ✅ Draw prominent connection dot in center
                QRectF dotRect = rect.adjusted(3, 3, -3, -3); // Larger dot for visibility
                painter->setBrush(QBrush(Qt::white));
                painter->setPen(QPen(borderColor.darker(150), 1));
                painter->drawEllipse(dotRect); // Circular dot
                
                // Optional: Add subtle glow around socket
                if (m_hovered) {
                    painter->setBrush(Qt::NoBrush);
                    painter->setPen(QPen(borderColor.lighter(150), 1));
                    painter->drawRoundedRect(rect.adjusted(-1, -1, 1, 1), 4.0, 4.0);
                }
            }
            break;
            
        case Highlighted:
            {
                // Draw pulsing highlight for valid connection targets
                // Use time-based pulsing effect
                qreal pulse = 0.5 + 0.5 * qSin(QDateTime::currentMSecsSinceEpoch() * 0.01);
                QColor highlightColor = QColor(0, 255, 0, 80 + 40 * pulse);
                painter->setBrush(QBrush(highlightColor));
                painter->setPen(QPen(QColor(0, 255, 0, 150 + 50 * pulse), 2));
                painter->drawRoundedRect(rect.adjusted(-2, -2, 2, 2), 4.0, 4.0);
                
                painter->setBrush(socketColor.lighter(130));
                painter->setPen(QPen(borderColor, 2));
                painter->drawRoundedRect(rect, 3.0, 3.0);
            }
            break;
            
        case Connecting:
            // Draw connecting state (for source socket during drag)
            painter->setBrush(QBrush(socketColor.lighter(110)));
            painter->setPen(QPen(borderColor.darker(120), 3));
            painter->drawRoundedRect(rect, 3.0, 3.0);
            break;
            
        case Disconnected:
        default:
            // Normal socket appearance - rounded square
            painter->setBrush(socketColor);
            painter->setPen(QPen(borderColor, 2));
            painter->drawRoundedRect(rect, 3.0, 3.0);
            break;
    }
    
    // Draw socket index number with better contrast
    if (rect.width() > 8) { // Only draw index if socket is large enough
        painter->setPen(Qt::white);
        
        // Performance optimization: static font (created once, not every frame)
        static const QFont socketFont("Arial", 7, QFont::Bold);
        painter->setFont(socketFont);
        
        // Performance optimization: cache index string (created once, not every frame)
        if (m_cachedIndexString.isEmpty()) {
            m_cachedIndexString = QString::number(m_index);
        }
        painter->drawText(rect, Qt::AlignCenter, m_cachedIndexString);
    }
}

void Socket::mousePressEvent(QGraphicsSceneMouseEvent *event)
{
    // ✅ Check connection status BEFORE setting pressed state
    // to avoid "stuck pressed" visuals when event is ignored
    if (isConnected()) {
        m_pressed = false;
        update();
        qDebug() << "Socket" << m_index << "is connected - dragging disabled";
        event->ignore(); // Don't start drag operations on connected sockets
        return;
    }

    if (event->button() == Qt::LeftButton) {
        m_pressed = true;
        update(); // Show pressed state
        qDebug() << "Socket clicked: index:" << m_index << "role:" << (m_role == Input ? "Input" : "Output");
        // TODO: Start edge creation drag
        event->accept();
    } else if (event->button() == Qt::RightButton && m_role == Output) {
        m_pressed = true;
        update(); // Show pressed state
        qDebug() << "Socket right-clicked: index:" << m_index << "role:" << (m_role == Input ? "Input" : "Output");
        // Start ghost edge from output socket
        Scene* scene = qobject_cast<Scene*>(this->scene());
        if (scene) {
            scene->startGhostEdge(this, event->scenePos());
        }
        event->accept();
    }
    QGraphicsItem::mousePressEvent(event);
}

void Socket::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)
{
    m_pressed = false;
    update(); // Remove pressed state
    
    if (event->button() == Qt::LeftButton) {
        qDebug() << "Socket released: index:" << m_index;
        // TODO: Complete edge connection
        event->accept();
    }
    QGraphicsItem::mouseReleaseEvent(event);
}

void Socket::hoverEnterEvent(QGraphicsSceneHoverEvent *event)
{
    Q_UNUSED(event)
    m_hovered = true;
    m_hoverOpacity = 1.0; // Animate to full opacity
    update();
}

void Socket::hoverLeaveEvent(QGraphicsSceneHoverEvent *event)
{
    Q_UNUSED(event)
    m_hovered = false;
    m_hoverOpacity = 0.0; // Animate to no opacity
    update();
}


xmlNodePtr Socket::write(xmlDocPtr doc, xmlNodePtr repr) const
{
    Q_UNUSED(doc)
    Q_UNUSED(repr)
    // Sockets are written as part of their parent node
    return nullptr;
}

void Socket::read(xmlNodePtr node)
{
    Q_UNUSED(node)
    // Socket properties read from parent node's socket definitions
    // Position is set by parent node's positionAllSockets() method
}





/// ===== FILE: edge.h =====
#pragma once

#include <QGraphicsItem>
#include <QPainter>
#include <QStyleOptionGraphicsItem>
#include <QWidget>
#include <QUuid>
#include <QString>
#include <QColor>
#include <QPainterPath>
#include <QPainterPathStroker>
#include <QPointF>
#include <functional>
#include <libxml/tree.h>

class Socket;
class Node;

/**
 * Edge - Connection between two sockets
 * 
 * Core principles:
 * - Self-serializing connection between socket UUIDs
 * - No QObject inheritance or connect usage
 * - Draws path from socket to socket
 * - References sockets by UUID, not pointers
 */
class Edge : public QGraphicsItem
{
public:
    // QGraphicsItem type system (required by Qt, DO NOT USE in logic)
    // Policy: Use Gik::KindKey metadata instead of type() for type checking
    enum { Type = UserType + 2 };
    int type() const override { return Type; }

    Edge(const QUuid& id = QUuid::createUuid(),
         const QUuid& fromSocketId = QUuid(),
         const QUuid& toSocketId = QUuid());
    ~Edge(); // Destructor for node unregistration
    
    // Core identity
    const QUuid& getId() const { return m_id; }
    
    // Self-serialization interface
    xmlNodePtr write(xmlDocPtr doc, xmlNodePtr repr = nullptr) const;
    void read(xmlNodePtr node);
    
    // QGraphicsItem interface
    QRectF boundingRect() const override;
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) override;
    QPainterPath shape() const override;
    QVariant itemChange(GraphicsItemChange change, const QVariant &value) override;
    
    // Connection management - clean design uses node+index only
    // No socket UUIDs - edges resolved via resolveConnections() method
    
    // Visual state uses Qt's selection system
    // Use QGraphicsItem::isSelected() and setSelected()
    
    // Path update - call when socket positions change
    void updatePath();
    
    // Mouse event debugging and interaction
    void mousePressEvent(QGraphicsSceneMouseEvent *event) override;
    void mouseReleaseEvent(QGraphicsSceneMouseEvent *event) override;
    void hoverEnterEvent(QGraphicsSceneHoverEvent *event) override;
    void hoverLeaveEvent(QGraphicsSceneHoverEvent *event) override;
    
    // Connection checking
    bool isConnectedToNode(const QString& nodeId) const;
    bool isConnectedToNode(const QUuid& nodeId) const;  // Optimized UUID version
    
    // Socket resolution after all nodes are loaded
    bool resolveConnections(class Scene* scene);
    
    // Direct connection methods (optimization for GraphFactory)
    void setConnectionData(const QString& fromNodeId, const QString& toNodeId, 
                          int fromSocketIndex, int toSocketIndex);
    void setResolvedSockets(Socket* fromSocket, Socket* toSocket);
    
    // Manual weak pointer system for safe destruction
    void invalidateNode(const Node* node);  // Legacy method
    void onNodeDestroying(const Node* node);  // New: Safe destruction callback
    
    // Public accessors for layout engine
    Node* getFromNode() const { return m_fromNode; }
    Node* getToNode() const { return m_toNode; }
    Socket* getFromSocket() const { return m_fromSocket; }
    Socket* getToSocket() const { return m_toSocket; }

private:
    QUuid m_id;
    QString m_fromNodeId;     // Store node IDs from XML (for serialization)
    QString m_toNodeId;
    QUuid m_fromNodeUuid;     // Cached UUIDs for fast comparison
    QUuid m_toNodeUuid;
    int m_fromSocketIndex;    // Store socket indices from XML
    int m_toSocketIndex;
    Socket* m_fromSocket;     // Resolved socket pointers
    Socket* m_toSocket;
    
    // Manual weak pointers for safe destruction (nulled by Node::~Node)
    Node* m_fromNode;         // Source node (may be nullptr during destruction)
    Node* m_toNode;           // Destination node (may be nullptr during destruction)
    bool m_fromNodeValid;     // Safety flag: true if m_fromNode is safe to access
    bool m_toNodeValid;       // Safety flag: true if m_toNode is safe to access
    
    // Cached path for rendering
    QPainterPath m_path;
    QRectF m_boundingRect;
    
    // Interaction state
    bool m_hovered;
    
    #ifdef QT_DEBUG
    // Per-edge debug counter (thread-safe, per-instance)
    mutable int m_shapeCallCount;
    #endif
    
    // Visual styling
    void buildPath(const QPointF& start, const QPointF& end);
};


/// ===== FILE: edge.cpp =====
#include "edge.h"
#include "socket.h"
#include "node.h"
#include "scene.h"
#include "graphics_item_keys.h"
#include "layout_metrics.h"
#include "log_context.h"
#include <QPainter>
#include <QStyleOptionGraphicsItem>
#include <QWidget>
#include <QDebug>
#include <libxml/tree.h>
#include <cmath>

Edge::Edge(const QUuid& id, const QUuid& fromSocketId, const QUuid& toSocketId)
    : m_id(id)
    , m_fromNodeId()
    , m_toNodeId()
    , m_fromNodeUuid()
    , m_toNodeUuid()
    , m_fromSocketIndex(-1)
    , m_toSocketIndex(-1)
    , m_fromSocket(nullptr)
    , m_toSocket(nullptr)
    , m_fromNode(nullptr)
    , m_toNode(nullptr)
    , m_fromNodeValid(false)
    , m_toNodeValid(false)
    , m_hovered(false)
    #ifdef QT_DEBUG
    , m_shapeCallCount(0)
    #endif
{
    Q_UNUSED(fromSocketId)  // Legacy parameter, not used in clean design
    Q_UNUSED(toSocketId)    // Legacy parameter, not used in clean design
    setFlag(QGraphicsItem::ItemIsSelectable, true);
    setFlag(QGraphicsItem::ItemHasNoContents, false); // Ensure we control our own drawing
    setAcceptHoverEvents(true);  // Enable hover events for better interaction

    // ✅ Z-order hierarchy: Nodes(0) < Sockets(1) < Edges(2)
    // Edges appear on top of sockets for "plugged-in" visual effect
    setZValue(2);

    // Metadata annotations for cast-free identification
    setData(Gik::KindKey, Gik::Kind_Edge);
    setData(Gik::UuidKey, m_id.toString(QUuid::WithoutBraces));

    LOG_EDGE_SIMPLE() << "constructor";
    // Don't call updatePath() here - sockets not resolved yet
}

Edge::~Edge()
{
    // SAFETY: Use validity flags to prevent use-after-free during shutdown
    // Only unregister if the node pointer is valid (not being destroyed)
    if (m_fromNodeValid && m_fromNode) {
        m_fromNode->unregisterEdge(this);
    }
    if (m_toNodeValid && m_toNode) {
        m_toNode->unregisterEdge(this);
    }

    LOG_EDGE_SIMPLE() << "destructor";
}

void Edge::invalidateNode(const Node* node)
{
    // Legacy method: Manual weak pointer nulling - called by Node::~Node()
    if (node == m_fromNode) {
        m_fromNode = nullptr;
        m_fromNodeValid = false;
    }
    if (node == m_toNode) {
        m_toNode = nullptr;
        m_toNodeValid = false;
    }
}

void Edge::onNodeDestroying(const Node* node)
{
    // New safety method: Mark node as invalid without nulling pointer
    // This prevents use-after-free while keeping pointer for debugging
    if (node == m_fromNode) {
        m_fromNodeValid = false;
        LOG_EDGE() << "SAFETY: fromNode destroying";
    }
    if (node == m_toNode) {
        m_toNodeValid = false;
        LOG_EDGE() << "SAFETY: toNode destroying";
    }
}

QRectF Edge::boundingRect() const
{
    return m_boundingRect;
}

void Edge::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
    Q_UNUSED(widget)
    Q_UNUSED(option) // Don't use Qt's default drawing options
    
    painter->setRenderHint(QPainter::Antialiasing);
    
    // Save painter state to ensure no side effects
    painter->save();
    
    // Make sure no brush is set (no fill)
    painter->setBrush(Qt::NoBrush);
    
    // IMPROVED: Multi-layer cable-like rendering with depth
    if (isSelected()) {
        // Selection: bright orange with glow effect
        QPen glowPen(QColor(255, 69, 0, 100), LayoutMetrics::edgeVisualGlowWidth);
        glowPen.setCapStyle(Qt::RoundCap);
        painter->setPen(glowPen);
        painter->drawPath(m_path);

        QPen selectionPen(QColor(255, 69, 0), LayoutMetrics::edgeVisualCoreWidth);
        selectionPen.setCapStyle(Qt::RoundCap);
        painter->setPen(selectionPen);
        painter->drawPath(m_path);
    } else if (m_hovered) {
        // Hover: blue with subtle glow
        QPen hoverGlowPen(QColor(100, 150, 255, 80), LayoutMetrics::edgeHoverGlowWidth);
        hoverGlowPen.setCapStyle(Qt::RoundCap);
        painter->setPen(hoverGlowPen);
        painter->drawPath(m_path);

        QPen hoverPen(QColor(100, 150, 255), LayoutMetrics::edgeHoverCoreWidth);
        hoverPen.setCapStyle(Qt::RoundCap);
        painter->setPen(hoverPen);
        painter->drawPath(m_path);
    } else {
        // Normal: layered cable appearance with depth
        // Layer 1: Shadow for depth
        QPen shadowPen(QColor(0, 0, 0, 60), 5);
        shadowPen.setCapStyle(Qt::RoundCap);
        painter->setPen(shadowPen);
        QPainterPath shadowPath = m_path;
        shadowPath.translate(1.5, 1.5);
        painter->drawPath(shadowPath);
        
        // Layer 2: Dark outline for definition
        QPen outlinePen(QColor(40, 40, 40), 4);
        outlinePen.setCapStyle(Qt::RoundCap);
        painter->setPen(outlinePen);
        painter->drawPath(m_path);
        
        // Layer 3: Main cable body with subtle gradient effect
        QPen mainPen(QColor(85, 85, 85), LayoutMetrics::edgeNormalWidth);
        mainPen.setCapStyle(Qt::RoundCap);
        painter->setPen(mainPen);
        painter->drawPath(m_path);
        
        // Layer 4: Highlight for 3D cable effect
        QPen highlightPen(QColor(120, 120, 120), 1);
        highlightPen.setCapStyle(Qt::RoundCap);
        painter->setPen(highlightPen);
        painter->drawPath(m_path);
    }
    
    // Restore painter state
    painter->restore();
}

QPainterPath Edge::shape() const
{
    // Create a much wider path for easier selection - very generous selection area
    QPainterPathStroker stroker;
    stroker.setWidth(LayoutMetrics::edgeSelectionWidth);  // Wide selection area for easy clicking
    stroker.setCapStyle(Qt::RoundCap);
    stroker.setJoinStyle(Qt::RoundJoin);
    QPainterPath selectionPath = stroker.createStroke(m_path);
    
    #ifdef QT_DEBUG
    // Debug: Log when shape is queried (indicates potential interaction)
    // Per-edge counter avoids thread safety issues with global static
    ++m_shapeCallCount;
    if (m_shapeCallCount % 100 == 0) {  // Throttled logging to avoid spam
        qDebug() << "Edge" << m_id.toString(QUuid::WithoutBraces).left(8) 
                 << "shape() called" << m_shapeCallCount << "times";
    }
    #endif
    
    return selectionPath;
}

// Removed manual setSelected - using Qt's selection system

QVariant Edge::itemChange(GraphicsItemChange change, const QVariant &value)
{
    if (change == ItemSelectedHasChanged) {
        // Selection tracking logging - what has been selected
        bool isNowSelected = value.toBool();
        qDebug() << "Edge" << m_id.toString(QUuid::WithoutBraces).left(8) 
                 << (isNowSelected ? "SELECT" : "DESELECT");
        
        // Trigger visual update when selection changes
        update();
    }
    return QGraphicsItem::itemChange(change, value);
}

void Edge::mousePressEvent(QGraphicsSceneMouseEvent *event)
{
    qDebug() << "Edge" << m_id.toString(QUuid::WithoutBraces).left(8) << "mousePressEvent at" << event->pos();
    QGraphicsItem::mousePressEvent(event);
}

void Edge::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)
{
    qDebug() << "Edge" << m_id.toString(QUuid::WithoutBraces).left(8) << "mouseReleaseEvent at" << event->pos();
    QGraphicsItem::mouseReleaseEvent(event);
}

void Edge::hoverEnterEvent(QGraphicsSceneHoverEvent *event)
{
    Q_UNUSED(event)
    m_hovered = true;
    qDebug() << "Edge" << m_id.toString(QUuid::WithoutBraces).left(8) << "HOVER ENTER";
    update();  // Redraw to show hover effect
    QGraphicsItem::hoverEnterEvent(event);
}

void Edge::hoverLeaveEvent(QGraphicsSceneHoverEvent *event)
{
    Q_UNUSED(event)
    m_hovered = false;
    qDebug() << "Edge" << m_id.toString(QUuid::WithoutBraces).left(8) << "HOVER LEAVE";
    update();  // Redraw to remove hover effect
    QGraphicsItem::hoverLeaveEvent(event);
}

void Edge::updatePath()
{
    // Simple and clean: use direct socket pointers
    if (!m_fromSocket || !m_toSocket) {
        // Edge not resolved yet - notify BSP cache before clearing
        prepareGeometryChange();
        m_path = QPainterPath();
        m_boundingRect = QRectF();
        return;
    }
    
    // ✅ FIXED: Connect to exact socket centers in scene coordinates
    // Use mapToScene to get the socket's center point in scene coordinates
    QRectF fromRect = m_fromSocket->boundingRect();
    QRectF toRect = m_toSocket->boundingRect();
    
    // Get the center of each socket in its local coordinates, then map to scene
    QPointF start = m_fromSocket->mapToScene(fromRect.center());
    QPointF end = m_toSocket->mapToScene(toRect.center());
    
    buildPath(start, end);
}



void Edge::buildPath(const QPointF& start, const QPointF& end)
{
    // Validate input points
    if (start.isNull() || end.isNull() || !qIsFinite(start.x()) || !qIsFinite(start.y()) ||
        !qIsFinite(end.x()) || !qIsFinite(end.y())) {
        // Notify BSP cache before clearing
        prepareGeometryChange();
        m_path = QPainterPath();
        m_boundingRect = QRectF();
        return;
    }

    // ✅ CRITICAL: Notify Qt BSP cache BEFORE modifying path
    // clear() changes geometry, so we must call prepareGeometryChange() first
    prepareGeometryChange();

    // Clear and rebuild path safely
    m_path.clear();

    // ✅ ENHANCED: Connect directly to socket centers (no adjustment needed)
    // Since updatePath() now provides socket centers, use them directly
    QPointF adjustedStart = start;
    QPointF adjustedEnd = end;

    // IMPROVED: Dynamic curve calculation based on distance and orientation
    qreal dx = adjustedEnd.x() - adjustedStart.x();
    qreal dy = adjustedEnd.y() - adjustedStart.y();
    qreal distance = std::sqrt(dx * dx + dy * dy);

    // ✅ GUARD: Check for zero-length edges (degenerate case)
    // If sockets are at same position, draw straight line instead of curve
    constexpr qreal kMinEdgeLength = 1.0;  // Minimum 1 pixel
    if (distance < kMinEdgeLength) {
        m_path.moveTo(adjustedStart);
        m_path.lineTo(adjustedEnd);  // Degenerate to straight line

        // Set minimal bounding rect
        const qreal margin = LayoutMetrics::edgeSelectionMargin;
        m_boundingRect = QRectF(start, end).normalized().adjusted(-margin, -margin, margin, margin);
        return;
    }

    // ✅ GUARD: Validate calculated distance for NaN/Inf
    if (!qIsFinite(distance)) {
        m_path.moveTo(adjustedStart);
        m_path.lineTo(adjustedEnd);  // Fallback to straight line

        const qreal margin = LayoutMetrics::edgeSelectionMargin;
        m_boundingRect = QRectF(start, end).normalized().adjusted(-margin, -margin, margin, margin);
        return;
    }

    m_path.moveTo(adjustedStart);

    // Adaptive control point calculation for better curves
    qreal horizontalFactor = qAbs(dx) / qMax(distance, 1.0);

    // Dynamic control offset based on distance and direction
    qreal controlOffset;
    if (horizontalFactor > 0.8) {
        // Mostly horizontal: use classic Bezier with distance-based offset
        controlOffset = qMax(qAbs(dx) * 0.4, qMin(distance * 0.3, 150.0));
    } else {
        // More vertical: tighter curves for better routing
        controlOffset = qMax(40.0, qMin(distance * 0.2, 80.0));
    }

    // ✅ GUARD: Clamp control offset to reasonable bounds
    // Prevent extreme offsets that create wild curves or overflow
    constexpr qreal kMinControlOffset = 5.0;   // Minimum 5 pixels for visible curve
    constexpr qreal kMaxControlOffset = 300.0; // Maximum 300 pixels to prevent overflow
    controlOffset = qBound(kMinControlOffset, controlOffset, kMaxControlOffset);

    // Enhanced control point positioning for natural cable-like curves
    QPointF control1, control2;

    if (dx >= 0) {
        // Left-to-right: standard horizontal Bezier
        control1 = adjustedStart + QPointF(controlOffset, 0);
        control2 = adjustedEnd - QPointF(controlOffset, 0);
    } else {
        // Right-to-left: S-curve for better visual routing
        qreal verticalOffset = qAbs(dy) * 0.3;
        control1 = adjustedStart + QPointF(controlOffset * 0.6, dy > 0 ? verticalOffset : -verticalOffset);
        control2 = adjustedEnd - QPointF(controlOffset * 0.6, dy > 0 ? verticalOffset : -verticalOffset);
    }

    // ✅ GUARD: Validate control points before creating curve
    // Ensure control points are finite and not degenerate
    if (!qIsFinite(control1.x()) || !qIsFinite(control1.y()) ||
        !qIsFinite(control2.x()) || !qIsFinite(control2.y())) {
        // Fallback to straight line if control points invalid
        m_path.lineTo(adjustedEnd);

        const qreal margin = LayoutMetrics::edgeSelectionMargin;
        m_boundingRect = QRectF(start, end).normalized().adjusted(-margin, -margin, margin, margin);
        return;
    }

    // Create smooth cubic Bezier curve
    m_path.cubicTo(control1, control2, adjustedEnd);

    // Update bounding rectangle with validation
    // (prepareGeometryChange() already called at function start)
    QRectF pathBounds = m_path.boundingRect();
    const qreal margin = LayoutMetrics::edgeSelectionMargin;  // Matches shape() stroker width
    if (pathBounds.isValid()) {
        m_boundingRect = pathBounds.adjusted(-margin, -margin, margin, margin);
    } else {
        m_boundingRect = QRectF(start, end).normalized().adjusted(-margin, -margin, margin, margin);
    }
}


xmlNodePtr Edge::write(xmlDocPtr doc, xmlNodePtr repr) const
{
    xmlNodePtr node = xmlNewNode(nullptr, BAD_CAST "edge");
    
    // Core attributes - clean design uses node+index format
    xmlSetProp(node, BAD_CAST "id", BAD_CAST m_id.toString(QUuid::WithoutBraces).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "fromNode", BAD_CAST m_fromNodeId.toUtf8().constData());
    xmlSetProp(node, BAD_CAST "toNode", BAD_CAST m_toNodeId.toUtf8().constData());
    xmlSetProp(node, BAD_CAST "fromSocketIndex", BAD_CAST QString::number(m_fromSocketIndex).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "toSocketIndex", BAD_CAST QString::number(m_toSocketIndex).toUtf8().constData());
    
    if (repr) {
        xmlAddChild(repr, node);
    } else {
        xmlDocSetRootElement(doc, node);
    }
    
    return node;
}

void Edge::read(xmlNodePtr node)
{
    if (!node) return;
    
    // Read UUID
    xmlChar* idStr = xmlGetProp(node, BAD_CAST "id");
    if (idStr) {
        m_id = QUuid(QString::fromUtf8((char*)idStr));
        // ✅ CRITICAL: Update metadata when UUID changes from XML
        setData(Gik::UuidKey, m_id.toString(QUuid::WithoutBraces));
        xmlFree(idStr);
    }
    
    // Read node+index references - store for later resolution
    // Support both formats: new (fromNode/toNode) and legacy (from/to)
    xmlChar* fromNodeStr = xmlGetProp(node, BAD_CAST "fromNode");
    if (!fromNodeStr) fromNodeStr = xmlGetProp(node, BAD_CAST "from");
    
    xmlChar* toNodeStr = xmlGetProp(node, BAD_CAST "toNode");
    if (!toNodeStr) toNodeStr = xmlGetProp(node, BAD_CAST "to");
    
    xmlChar* fromIndexStr = xmlGetProp(node, BAD_CAST "fromSocketIndex");
    if (!fromIndexStr) fromIndexStr = xmlGetProp(node, BAD_CAST "from-socket");
    
    xmlChar* toIndexStr = xmlGetProp(node, BAD_CAST "toSocketIndex");
    if (!toIndexStr) toIndexStr = xmlGetProp(node, BAD_CAST "to-socket");
    
    if (!fromNodeStr || !toNodeStr || !fromIndexStr || !toIndexStr) {
        qCritical() << "Edge::read() - Missing required node+index attributes";
        if (fromNodeStr) xmlFree(fromNodeStr);
        if (toNodeStr) xmlFree(toNodeStr);
        if (fromIndexStr) xmlFree(fromIndexStr);
        if (toIndexStr) xmlFree(toIndexStr);
        return;
    }
    
    // Store data for later resolution - don't try to resolve now
    m_fromNodeId = QString::fromUtf8((char*)fromNodeStr);
    m_toNodeId = QString::fromUtf8((char*)toNodeStr);
    m_fromSocketIndex = QString::fromUtf8((char*)fromIndexStr).toInt();
    m_toSocketIndex = QString::fromUtf8((char*)toIndexStr).toInt();
    
    // Performance optimization: cache UUIDs for fast comparison
    m_fromNodeUuid = QUuid(m_fromNodeId);
    m_toNodeUuid = QUuid(m_toNodeId);
    
    qDebug() << "Edge: Stored connection data fromNode" << m_fromNodeId.left(8) 
             << "socket" << m_fromSocketIndex << "-> toNode" << m_toNodeId.left(8) 
             << "socket" << m_toSocketIndex;
    
    xmlFree(fromNodeStr);
    xmlFree(toNodeStr);
    xmlFree(fromIndexStr);
    xmlFree(toIndexStr);
    
    // DON'T call updatePath() here - scene may not be ready
    // Socket resolution will happen later via resolveConnections()
}

bool Edge::isConnectedToNode(const QString& nodeId) const
{
    return (m_fromNodeId == nodeId || m_toNodeId == nodeId);
}

bool Edge::isConnectedToNode(const QUuid& nodeId) const
{
    // Optimized: Fast UUID comparison (no string conversion)
    return (m_fromNodeUuid == nodeId || m_toNodeUuid == nodeId);
}

bool Edge::resolveConnections(Scene* scene)
{
    if (!scene) {
        qCritical() << "Edge::resolveConnections - null scene";
        return false;
    }
    
    if (m_fromNodeId.isEmpty() || m_toNodeId.isEmpty()) {
        qCritical() << "Edge::resolveConnections - empty node IDs";
        return false;
    }
    
    // Find nodes by UUID
    Node* fromNode = scene->getNode(QUuid(m_fromNodeId));
    Node* toNode = scene->getNode(QUuid(m_toNodeId));
    
    if (!fromNode) {
        qCritical() << "Edge::resolveConnections - fromNode not found:" << m_fromNodeId.left(8);
        return false;
    }
    if (!toNode) {
        qCritical() << "Edge::resolveConnections - toNode not found:" << m_toNodeId.left(8);
        return false;
    }
    
    // Find sockets by index
    Socket* fromSocket = fromNode->getSocketByIndex(m_fromSocketIndex);
    Socket* toSocket = toNode->getSocketByIndex(m_toSocketIndex);
    
    qDebug() << "Edge resolve: fromNode" << m_fromNodeId.left(8) << "type:" << fromNode->getNodeType()
             << "socket" << m_fromSocketIndex << "role:" << (fromSocket ? Socket::roleToString(fromSocket->getRole()) : "NULL");
    qDebug() << "Edge resolve: toNode" << m_toNodeId.left(8) << "type:" << toNode->getNodeType()
             << "socket" << m_toSocketIndex << "role:" << (toSocket ? Socket::roleToString(toSocket->getRole()) : "NULL");
    
    if (!fromSocket) {
        qCritical() << "Edge::resolveConnections - fromSocket index" << m_fromSocketIndex 
                   << "not found in node" << m_fromNodeId.left(8) 
                   << "with" << fromNode->getSocketCount() << "sockets";
        return false;
    }
    if (!toSocket) {
        qCritical() << "Edge::resolveConnections - toSocket index" << m_toSocketIndex 
                   << "not found in node" << m_toNodeId.left(8) 
                   << "with" << toNode->getSocketCount() << "sockets";
        return false;
    }
    
    // Validate connection rules
    if (fromSocket->getRole() != Socket::Output) {
        qCritical() << "ERROR: Edge::resolveConnections - fromSocket must be Output role"
                   << "- fromNode:" << m_fromNodeId.left(8) << "socket" << m_fromSocketIndex 
                   << "has role:" << Socket::roleToString(fromSocket->getRole());
        return false;
    }
    if (toSocket->getRole() != Socket::Input) {
        qCritical() << "ERROR: Edge::resolveConnections - toSocket must be Input role"
                   << "- toNode:" << m_toNodeId.left(8) << "socket" << m_toSocketIndex 
                   << "has role:" << Socket::roleToString(toSocket->getRole());
        return false;
    }
    
    // Store socket references directly - NO UUIDs
    m_fromSocket = fromSocket;
    m_toSocket = toSocket;

    // Cache node pointers for safe destruction
    m_fromNode = fromNode;
    m_toNode = toNode;
    m_fromNodeValid = true;  // Mark as valid - safe to access
    m_toNodeValid = true;    // Mark as valid - safe to access

    // PERFORMANCE OPTIMIZATION: Register this edge with both connected nodes
    // This enables O(degree) edge updates instead of O(totalEdges)
    fromNode->registerEdge(this);
    toNode->registerEdge(this);

    // CRITICAL: Connect sockets atomically - set bidirectional references
    fromSocket->setConnectedEdge(this);
    toSocket->setConnectedEdge(this);

    qDebug() << "Edge" << m_id.toString(QUuid::WithoutBraces).left(8) << "resolved"
             << m_fromSocketIndex << "->" << m_toSocketIndex;

    updatePath();
    return true;
}

void Edge::setConnectionData(const QString& fromNodeId, const QString& toNodeId, 
                            int fromSocketIndex, int toSocketIndex)
{
    m_fromNodeId = fromNodeId;
    m_toNodeId = toNodeId;
    m_fromSocketIndex = fromSocketIndex;
    m_toSocketIndex = toSocketIndex;
    
    // Performance optimization: cache UUIDs for fast comparison
    m_fromNodeUuid = QUuid(fromNodeId);
    m_toNodeUuid = QUuid(toNodeId);
    
    qDebug() << "Edge: Set connection data" << fromNodeId.left(8) 
             << "socket" << fromSocketIndex << "-> " << toNodeId.left(8) 
             << "socket" << toSocketIndex;
}

void Edge::setResolvedSockets(Socket* fromSocket, Socket* toSocket)
{
    if (!fromSocket || !toSocket) {
        qCritical() << "Edge::setResolvedSockets - null socket(s) provided";
        return;
    }
    
    // Validate socket roles
    if (fromSocket->getRole() != Socket::Output) {
        qCritical() << "Edge::setResolvedSockets - fromSocket must be Output role";
        return;
    }
    if (toSocket->getRole() != Socket::Input) {
        qCritical() << "Edge::setResolvedSockets - toSocket must be Input role";
        return;
    }
    
    m_fromSocket = fromSocket;
    m_toSocket = toSocket;

    // Cache node pointers for safe destruction
    Node* fromNode = fromSocket->getParentNode();
    Node* toNode = toSocket->getParentNode();
    m_fromNode = fromNode;
    m_toNode = toNode;
    m_fromNodeValid = (fromNode != nullptr);  // Mark as valid if node exists
    m_toNodeValid = (toNode != nullptr);      // Mark as valid if node exists
    
    // PERFORMANCE OPTIMIZATION: Register this edge with both connected nodes
    // This enables O(degree) edge updates instead of O(totalEdges)
    if (fromNode) fromNode->registerEdge(this);
    if (toNode) toNode->registerEdge(this);
    
    qDebug() << "✓ Edge: Set resolved sockets directly (optimization)";
    updatePath();
}


/// ===== FILE: ghost_edge.h =====
#pragma once

#include <QGraphicsItem>
#include <QPainterPath>
#include <QPen>
#include <QPainter>

class GhostEdge : public QGraphicsItem {
public:
    explicit GhostEdge(QGraphicsItem* parent = nullptr);
    
    void setPath(const QPainterPath& path);
    QPainterPath path() const { return m_path; }
    
    QRectF boundingRect() const override;
    void paint(QPainter* painter, const QStyleOptionGraphicsItem* option, QWidget* widget) override;
    
private:
    QPainterPath m_path;
    QRectF m_boundingRect;
};


/// ===== FILE: ghost_edge.cpp =====
#include "ghost_edge.h"

GhostEdge::GhostEdge(QGraphicsItem* parent)
    : QGraphicsItem(parent)
{
    setFlag(QGraphicsItem::ItemIsSelectable, false);
    setFlag(QGraphicsItem::ItemIsMovable, false);
    setFlag(QGraphicsItem::ItemIsFocusable, false);
    setAcceptHoverEvents(false);
    setAcceptedMouseButtons(Qt::NoButton);
    setAcceptTouchEvents(false);
    setCacheMode(QGraphicsItem::NoCache);
    setZValue(-10);
}

void GhostEdge::setPath(const QPainterPath& path)
{
    prepareGeometryChange();
    m_path = path;
    m_boundingRect = path.boundingRect().adjusted(-2, -2, 2, 2);
}

QRectF GhostEdge::boundingRect() const
{
    return m_boundingRect;
}

void GhostEdge::paint(QPainter* painter, const QStyleOptionGraphicsItem*, QWidget*)
{
    painter->setRenderHint(QPainter::Antialiasing);
    QPen pen(QColor(0, 255, 0, 150), 2, Qt::DashLine);
    pen.setCapStyle(Qt::RoundCap);
    painter->setPen(pen);
    painter->setBrush(Qt::NoBrush);
    painter->drawPath(m_path);
}


/// ===== FILE: qgraph.h =====
#pragma once

#include <QObject>
#include <QPointF>
#include <QString>
#include <QVariantMap>
#include <QVariantList>

class QGraphicsScene;
class Socket;
class Scene;

/**
 * QGraph - Central graph data model and orchestration layer
 *
 * Separates graph semantics from visual rendering (Scene).
 * Handles all graph mutations, XML I/O, and business logic.
 *
 * Design principles:
 * - QGraph owns graph semantics (create, connect, delete)
 * - Scene handles only visual rendering and registries
 * - O(1) lookups via UUID-based maps
 * - O(degree) edge updates (only notify connected nodes)
 *
 * Note: Q_INVOKABLE methods use QString for UUIDs (not QUuid) because:
 * - JavaScript/QML doesn't have a native QUuid type
 * - QString converts seamlessly to/from JavaScript strings
 * - Internally we still use QUuid for type safety
 */
class QGraph : public QObject
{
    Q_OBJECT

public:
    // Take a concrete Scene* (no QGraphicsScene*), so we never need runtime casts.
    explicit QGraph(Scene* scene, QObject* parent = nullptr);
    ~QGraph() = default;

    // Node operations
    Q_INVOKABLE QString createNode(const QString& type, qreal x, qreal y);
    Q_INVOKABLE bool deleteNode(const QString& nodeId);
    Q_INVOKABLE bool moveNode(const QString& nodeId, qreal dx, qreal dy);
    Q_INVOKABLE QVariantMap getNode(const QString& nodeId);
    Q_INVOKABLE QVariantList getNodes();

    // Edge operations
    Q_INVOKABLE QString connect(const QString& fromNodeId, int fromIdx,
                                const QString& toNodeId, int toIdx);
    Q_INVOKABLE bool deleteEdge(const QString& edgeId);
    Q_INVOKABLE QVariantList getEdges();

    // Graph-wide operations
    Q_INVOKABLE bool deleteSelected();  // Delete all selected items
    Q_INVOKABLE void clear();
    Q_INVOKABLE void saveXml(const QString& path);
    Q_INVOKABLE bool loadXml(const QString& path);
    Q_INVOKABLE QString getXmlString();
    Q_INVOKABLE QVariantMap getStats();

    // Load state tracking for JavaScript coordination
    Q_INVOKABLE bool isLoadingXml() const;
    Q_INVOKABLE bool isStable() const;
    Q_INVOKABLE int getUnresolvedEdgeCount() const;

    // Ghost-edge preview orchestration (Scene renders, QGraph orchestrates)
    Q_INVOKABLE void beginPreview(Socket* from, const QPointF& start);
    Q_INVOKABLE void updatePreview(const QPointF& pos);
    Q_INVOKABLE void endPreview(Socket* to);

    // Utility functions
    Q_INVOKABLE bool isValidNodeType(const QString& type);
    Q_INVOKABLE QStringList getValidNodeTypes();

signals:
    void nodeCreated(QString id);
    void nodeDeleted(QString id);
    void edgeConnected(QString id);
    void edgeDeleted(QString id);
    void graphCleared();
    void xmlSaved(QString path);
    void xmlLoaded(QString path);
    void error(QString message);

    // XML load coordination signals
    void xmlLoadStarted(QString path);
    void xmlLoadProgress(int nodesLoaded, int edgesLoaded);
    void xmlLoadComplete(QString path, bool success);
    void graphStabilized();

private:
    Scene* scene_;  // Access to visual layer and registries (typed, no casts)

    // Load state tracking
    bool m_isLoadingXml;
    int m_unresolvedEdges;

    // Helper methods
    class Node* findNode(const QString& uuid);
    class Edge* findEdge(const QString& uuid);
    QVariantMap nodeToVariant(Node* node);
    QVariantMap edgeToVariant(Edge* edge);
    void updateUnresolvedEdgeCount();
};


/// ===== FILE: qgraph.cpp =====
#include "qgraph.h"
#include "scene.h"
#include "node.h"
#include "edge.h"
#include "socket.h"
#include "node_templates.h"
#include "graph_factory.h"
#include <QDebug>
#include <QUuid>
#include <libxml/tree.h>
#include <libxml/parser.h>

QGraph::QGraph(Scene* scene, QObject* parent)
    : QObject(parent)
    , scene_(scene)
    , m_isLoadingXml(false)
    , m_unresolvedEdges(0)
{
    Q_ASSERT(scene_ && "QGraph requires a typed Scene*");
}

QString QGraph::createNode(const QString& type, qreal x, qreal y)
{
    if (!scene_) {
        emit error("QGraph: Scene not initialized");
        return QString();
    }

    if (!NodeTypeTemplates::hasNodeType(type)) {
        emit error(QString("QGraph: Unknown node type: %1").arg(type));
        return QString();
    }

    try {
        // Generate UUID for new node
        QUuid nodeId = QUuid::createUuid();

        // Use template system to generate XML with correct socket counts
        QString xmlString = NodeTypeTemplates::generateNodeXml(type, QPointF(x, y), QVariantMap(), nodeId);
        if (xmlString.isEmpty()) {
            emit error(QString("QGraph: Failed to generate XML for node type: %1").arg(type));
            return QString();
        }

        qDebug() << "QGraph: Generated XML for" << type << ":" << xmlString;

        // Parse XML string into DOM
        xmlDocPtr doc = xmlParseMemory(xmlString.toUtf8().constData(), xmlString.toUtf8().size());
        if (!doc) {
            emit error(QString("QGraph: Failed to parse generated XML for type: %1").arg(type));
            return QString();
        }

        xmlNodePtr root = xmlDocGetRootElement(doc);
        if (!root) {
            xmlFreeDoc(doc);
            emit error(QString("QGraph: No root element in generated XML for type: %1").arg(type));
            return QString();
        }

        // Create node via GraphFactory (handles socket creation from XML attributes)
        // GraphFactory adds node to scene automatically
        GraphFactory factory(scene_, doc);
        Node* node = factory.createNodeFromXml(root);

        xmlFreeDoc(doc);

        if (!node) {
            emit error(QString("QGraph: GraphFactory failed to create node of type: %1").arg(type));
            return QString();
        }

        // Note: Node already added to scene by GraphFactory

        QString nodeIdStr = node->getId().toString();
        emit nodeCreated(nodeIdStr);

        qDebug() << "QGraph: Created node" << type << "at" << x << "," << y << "id:" << nodeIdStr.left(8);
        return nodeIdStr;

    } catch (const std::exception& e) {
        emit error(QString("QGraph: Exception creating node: %1").arg(e.what()));
        return QString();
    }
}

bool QGraph::deleteNode(const QString& nodeId)
{
    if (!scene_) {
        emit error("QGraph: Scene not initialized");
        return false;
    }

    Node* node = findNode(nodeId);
    if (!node) {
        emit error(QString("QGraph: Node not found: %1").arg(nodeId));
        return false;
    }

    try {
        // Scene handles deletion and registry cleanup
        scene_->removeNodeInternal(QUuid(nodeId));
        emit nodeDeleted(nodeId);

        qDebug() << "QGraph: Deleted node" << nodeId.left(8);
        return true;

    } catch (const std::exception& e) {
        emit error(QString("QGraph: Exception deleting node: %1").arg(e.what()));
        return false;
    }
}

bool QGraph::moveNode(const QString& nodeId, qreal dx, qreal dy)
{
    Node* node = findNode(nodeId);
    if (!node) {
        emit error(QString("QGraph: Node not found: %1").arg(nodeId));
        return false;
    }

    QPointF currentPos = node->pos();
    node->setPos(currentPos.x() + dx, currentPos.y() + dy);

    return true;
}

QVariantMap QGraph::getNode(const QString& nodeId)
{
    Node* node = findNode(nodeId);
    if (!node) {
        return QVariantMap();
    }
    return nodeToVariant(node);
}

QVariantList QGraph::getNodes()
{
    QVariantList result;
    if (!scene_) return result;

    const QHash<QUuid, Node*>& nodes = scene_->getNodes();
    for (Node* node : nodes.values()) {
        result.append(nodeToVariant(node));
    }

    return result;
}

QString QGraph::connect(const QString& fromNodeId, int fromIdx,
                        const QString& toNodeId, int toIdx)
{
    if (!scene_) {
        emit error("QGraph: Scene not initialized");
        return QString();
    }

    Node* fromNode = findNode(fromNodeId);
    Node* toNode = findNode(toNodeId);

    if (!fromNode || !toNode) {
        emit error("QGraph: Source or target node not found");
        return QString();
    }

    Socket* fromSocket = fromNode->getSocketByIndex(fromIdx);
    Socket* toSocket = toNode->getSocketByIndex(toIdx);

    if (!fromSocket || !toSocket) {
        emit error("QGraph: Socket not found at specified index");
        return QString();
    }

    try {
        // Create edge with empty socket UUIDs (Edge uses node IDs + socket indices)
        Edge* edge = new Edge(QUuid::createUuid(), QUuid(), QUuid());

        // Set connection data (node IDs + socket indices)
        edge->setConnectionData(fromNodeId, toNodeId, fromIdx, toIdx);

        // Add to scene
        scene_->addEdge(edge);

        // CRITICAL: Resolve connections to set socket->edge references
        if (!edge->resolveConnections(scene_)) {
            qWarning() << "QGraph: Failed to resolve edge connections";
            scene_->removeEdgeInternal(edge->getId());  // This deletes the edge
            emit error("QGraph: Failed to resolve edge connections");
            return QString();
        }

        QString edgeId = edge->getId().toString();
        emit edgeConnected(edgeId);

        qDebug() << "QGraph: Connected" << fromNodeId.left(8) << "to" << toNodeId.left(8);
        return edgeId;

    } catch (const std::exception& e) {
        emit error(QString("QGraph: Exception connecting nodes: %1").arg(e.what()));
        return QString();
    }
}

bool QGraph::deleteEdge(const QString& edgeId)
{
    if (!scene_) {
        emit error("QGraph: Scene not initialized");
        return false;
    }

    Edge* edge = findEdge(edgeId);
    if (!edge) {
        emit error(QString("QGraph: Edge not found: %1").arg(edgeId));
        return false;
    }

    try {
        scene_->removeEdgeInternal(QUuid(edgeId));
        emit edgeDeleted(edgeId);

        qDebug() << "QGraph: Deleted edge" << edgeId.left(8);
        return true;

    } catch (const std::exception& e) {
        emit error(QString("QGraph: Exception deleting edge: %1").arg(e.what()));
        return false;
    }
}

QVariantList QGraph::getEdges()
{
    QVariantList result;
    if (!scene_) return result;

    const QHash<QUuid, Edge*>& edges = scene_->getEdges();
    for (Edge* edge : edges.values()) {
        result.append(edgeToVariant(edge));
    }

    return result;
}

void QGraph::clear()
{
    if (!scene_) {
        emit error("QGraph: Scene not initialized");
        return;
    }

    scene_->clearGraphInternal();
    emit graphCleared();

    qDebug() << "QGraph: Graph cleared";
}

bool QGraph::deleteSelected()
{
    if (!scene_) {
        emit error("QGraph: Scene not initialized");
        return false;
    }

    scene_->removeSelectedInternal();
    // Note: Individual node/edge deleted signals will be emitted by Scene
    qDebug() << "QGraph: Deleted selected items";
    return true;
}

void QGraph::saveXml(const QString& path)
{
    if (!scene_) {
        emit error("QGraph: Scene not initialized");
        return;
    }

    qDebug() << "QGraph: Saving XML to" << path;

    try {
        // Create XML document
        xmlDocPtr doc = xmlNewDoc(BAD_CAST "1.0");
        xmlNodePtr root = xmlNewNode(nullptr, BAD_CAST "graph");
        xmlDocSetRootElement(doc, root);
        xmlNewProp(root, BAD_CAST "version", BAD_CAST "1.0");

        // Serialize all nodes
        const QHash<QUuid, Node*>& nodes = scene_->getNodes();
        for (Node* node : nodes.values()) {
            node->write(doc, root);
        }

        // Serialize all edges
        const QHash<QUuid, Edge*>& edges = scene_->getEdges();
        for (Edge* edge : edges.values()) {
            edge->write(doc, root);
        }

        // Save to file
        int result = xmlSaveFileEnc(path.toUtf8().constData(), doc, "UTF-8");
        xmlFreeDoc(doc);

        if (result != -1) {
            qDebug() << "QGraph: XML saved successfully to" << path;
            emit xmlSaved(path);
        } else {
            emit error(QString("QGraph: Failed to save XML to %1").arg(path));
        }
    } catch (const std::exception& e) {
        emit error(QString("QGraph: Exception saving XML: %1").arg(e.what()));
    }
}


bool QGraph::loadXml(const QString& path)
{
    if (!scene_) {
        emit error("QGraph: Scene not initialized");
        return false;
    }

    qDebug() << "QGraph: Loading XML from" << path;
    emit xmlLoadStarted(path);
    m_isLoadingXml = true;

    // Parse file
    xmlDocPtr doc = xmlParseFile(path.toUtf8().constData());
    if (!doc) {
        m_isLoadingXml = false;
        emit error(QString("QGraph: Failed to parse XML file: %1").arg(path));
        emit xmlLoadComplete(path, false);
        return false;
    }

    // Get <graph> root
    xmlNodePtr root = xmlDocGetRootElement(doc);
    if (!root) {
        xmlFreeDoc(doc);
        m_isLoadingXml = false;
        emit error(QString("QGraph: XML has no root element: %1").arg(path));
        emit xmlLoadComplete(path, false);
        return false;
    }

    // Bulk update: suppress observer storms
    GraphSubject::beginBatch();

    bool ok = true;
    try {
        // Start clean
        scene_->clearGraphInternal();

        // Factory uses doc+scene to create nodes from XML
        GraphFactory factory(scene_, doc);

        // 1) Load NODES (support both <graph><nodes><node/></nodes> and flat <graph><node/>)
        auto loadNodeEl = [&](xmlNodePtr n) {
            if (n && xmlStrcmp(n->name, BAD_CAST "node") == 0) {
                if (!factory.createNodeFromXml(n)) {
                    qWarning() << "QGraph: Failed to create node from XML";
                    ok = false;
                }
            }
            };
        for (xmlNodePtr c = root->children; c; c = c->next) {
            if (xmlStrcmp(c->name, BAD_CAST "nodes") == 0) {
                for (xmlNodePtr n = c->children; n; n = n->next) loadNodeEl(n);
            }
            else {
                loadNodeEl(c);
            }
        }

        // 2) Load EDGES after nodes exist (support <connections><edge/> and flat <edge/>)
        QVector<Edge*> edgesToResolve;

        auto loadEdgeEl = [&](xmlNodePtr e) {
            if (e && xmlStrcmp(e->name, BAD_CAST "edge") == 0) {
                Edge* edge = new Edge(QUuid::createUuid(), QUuid(), QUuid());
                edge->read(e);               // stores node UUIDs + socket indices
                scene_->addEdge(edge);
                edgesToResolve.push_back(edge);
            }
            };
        for (xmlNodePtr c = root->children; c; c = c->next) {
            if (xmlStrcmp(c->name, BAD_CAST "connections") == 0) {
                for (xmlNodePtr e = c->children; e; e = e->next) loadEdgeEl(e);
            }
            else {
                loadEdgeEl(c);
            }
        }

        // 3) Resolve edge endpoints now that all nodes exist
        for (Edge* e : edgesToResolve) {
            if (!e->resolveConnections(scene_)) {
                qWarning() << "QGraph: Failed to resolve edge" << e->getId().toString(QUuid::WithoutBraces);
                ok = false;
            }
        }

    }
    catch (const std::exception& ex) {
        qCritical() << "QGraph: Exception during load:" << ex.what();
        ok = false;
    }
    catch (...) {
        qCritical() << "QGraph: Unknown exception during load";
        ok = false;
    }

    GraphSubject::endBatch();
    xmlFreeDoc(doc);

    m_isLoadingXml = false;

    if (ok) {
        updateUnresolvedEdgeCount();
        qDebug() << "QGraph: XML loaded successfully from" << path;
        emit xmlLoadComplete(path, true);
        if (isStable()) emit graphStabilized();
        return true;
    }
    else {
        emit error(QString("QGraph: Failed to fully load/resolve XML from %1").arg(path));
        emit xmlLoadComplete(path, false);
        return false;
    }
}

QString QGraph::getXmlString()
{
    if (!scene_) {
        return QString("<graph></graph>");
    }

    try {
        // Create XML document
        xmlDocPtr doc = xmlNewDoc(BAD_CAST "1.0");
        xmlNodePtr root = xmlNewNode(nullptr, BAD_CAST "graph");
        xmlDocSetRootElement(doc, root);
        xmlNewProp(root, BAD_CAST "version", BAD_CAST "1.0");

        // Serialize all nodes
        const QHash<QUuid, Node*>& nodes = scene_->getNodes();
        for (Node* node : nodes.values()) {
            node->write(doc, root);
        }

        // Serialize all edges
        const QHash<QUuid, Edge*>& edges = scene_->getEdges();
        for (Edge* edge : edges.values()) {
            edge->write(doc, root);
        }

        // Convert to string
        xmlChar* xmlBuff;
        int bufferSize;
        xmlDocDumpFormatMemory(doc, &xmlBuff, &bufferSize, 1);
        QString result = QString::fromUtf8((const char*)xmlBuff);
        xmlFree(xmlBuff);
        xmlFreeDoc(doc);

        return result;
    } catch (const std::exception& e) {
        emit error(QString("QGraph: Exception generating XML string: %1").arg(e.what()));
        return QString("<graph></graph>");
    }
}

QVariantMap QGraph::getStats()
{
    QVariantMap stats;
    if (!scene_) {
        stats["nodes"] = 0;
        stats["edges"] = 0;
        return stats;
    }

    stats["nodes"] = scene_->getNodes().size();
    stats["edges"] = scene_->getEdges().size();

    return stats;
}

void QGraph::beginPreview(Socket* from, const QPointF& start)
{
    if (scene_) {
        scene_->startGhostEdge(from, start);
    }
}

void QGraph::updatePreview(const QPointF& pos)
{
    if (scene_) {
        scene_->updateGhostEdge(pos);
    }
}

void QGraph::endPreview(Socket* to)
{
    if (scene_) {
        scene_->finishGhostEdge(to);
    }
}

bool QGraph::isValidNodeType(const QString& type)
{
    return NodeTypeTemplates::hasNodeType(type);
}

QStringList QGraph::getValidNodeTypes()
{
    return NodeTypeTemplates::getAvailableTypes();
}

// Helper methods

Node* QGraph::findNode(const QString& uuid)
{
    if (!scene_) return nullptr;
    return scene_->getNode(QUuid(uuid));
}

Edge* QGraph::findEdge(const QString& uuid)
{
    if (!scene_) return nullptr;
    return scene_->getEdge(QUuid(uuid));
}

QVariantMap QGraph::nodeToVariant(Node* node)
{
    QVariantMap map;
    if (!node) return map;

    map["id"] = node->getId().toString();
    map["type"] = node->getNodeType();
    map["x"] = node->pos().x();
    map["y"] = node->pos().y();
    map["socketCount"] = node->getSocketCount();

    return map;
}

QVariantMap QGraph::edgeToVariant(Edge* edge)
{
    QVariantMap map;
    if (!edge) return map;

    map["id"] = edge->getId().toString();

    // Add connection information using Edge's public accessors
    Node* fromNode = edge->getFromNode();
    Node* toNode = edge->getToNode();
    Socket* fromSocket = edge->getFromSocket();
    Socket* toSocket = edge->getToSocket();

    if (fromNode) {
        map["fromNode"] = fromNode->getId().toString();
    }
    if (toNode) {
        map["toNode"] = toNode->getId().toString();
    }
    if (fromSocket) {
        map["fromSocket"] = fromSocket->getIndex();
    }
    if (toSocket) {
        map["toSocket"] = toSocket->getIndex();
    }

    return map;
}

// Load state tracking implementation

bool QGraph::isLoadingXml() const
{
    return m_isLoadingXml;
}

bool QGraph::isStable() const
{
    return !m_isLoadingXml && m_unresolvedEdges == 0;
}

int QGraph::getUnresolvedEdgeCount() const
{
    return m_unresolvedEdges;
}

void QGraph::updateUnresolvedEdgeCount()
{
    if (!scene_) {
        m_unresolvedEdges = 0;
        return;
    }

    // Count edges without valid socket connections
    int unresolved = 0;
    const QHash<QUuid, Edge*>& edges = scene_->getEdges();
    for (Edge* edge : edges.values()) {
        if (!edge) continue;

        Socket* fromSocket = edge->getFromSocket();
        Socket* toSocket = edge->getToSocket();

        // Edge is unresolved if either socket is null
        if (!fromSocket || !toSocket) {
            unresolved++;
        }
    }

    m_unresolvedEdges = unresolved;
    qDebug() << "QGraph: Unresolved edges:" << m_unresolvedEdges;
}


/// ===== FILE: graph_factory.h =====
#pragma once

#include <QGraphicsScene>
#include <QUuid>
#include <QString>
#include <QPointF>
#include <QDebug>
#include <libxml/tree.h>
#include "socket.h"

class Node;
class Edge;
class Scene;  // Forward declaration for custom scene type

/**
 * GraphFactory - XML-First Object Creation with Templates
 *
 * Simplified factory that uses NodeTypeTemplates for type-based creation.
 * Enforces XML-first discipline while allowing extensible node types.
 */
class GraphFactory
{
public:
    // Initialize factory with scene and XML document
    GraphFactory(Scene* scene, xmlDocPtr xmlDoc);

    // XML-first creation methods
    Node* createNodeFromXml(xmlNodePtr xmlNode);

    // Runtime creation (creates XML first, then objects)
    Node* createNode(const QString& nodeType, const QPointF& position, int inputs = 1, int outputs = 1);

    // Utility to get XML property
    static QString getXmlProperty(xmlNodePtr node, const QString& name);

private:
    Scene* m_scene;  // ✅ Type-safe: GraphFactory always requires custom Scene
    xmlDocPtr m_xmlDocument;

    // Helper methods
    xmlNodePtr createXmlNode(const QString& nodeType, const QPointF& position, int inputs = 1, int outputs = 1);
    xmlNodePtr getNodesElement();
};


/// ===== FILE: graph_factory.cpp =====
#include "graph_factory.h"
#include "node.h"
#include "socket.h"
#include "edge.h"
#include "scene.h"
#include "node_templates.h"  // Template system - NO NodeRegistry needed
#include "graph_observer.h"
#include <QDateTime>
#include <QDebug>

GraphFactory::GraphFactory(Scene* scene, xmlDocPtr xmlDoc)
    : m_scene(scene)
    , m_xmlDocument(xmlDoc)
{
    qDebug() << "GraphFactory initialized with scene and XML document";
}

Node* GraphFactory::createNodeFromXml(xmlNodePtr xmlNode)
{
    if (!xmlNode) {
        qWarning() << "GraphFactory::createNodeFromXml - null XML node";
        return nullptr;
    }
    
    // Get node type from XML (for logging only)
    QString nodeType = getXmlProperty(xmlNode, "type");
    if (nodeType.isEmpty()) {
        qWarning() << "GraphFactory::createNodeFromXml - missing type attribute";
        return nullptr;
    }

    // Validate node type against template system (no NodeRegistry needed)
    if (!NodeTypeTemplates::hasNodeType(nodeType)) {
        qCritical() << "GraphFactory::createNodeFromXml - Invalid node type:" << nodeType;
        qCritical() << "Available types:" << NodeTypeTemplates::getAvailableTypes();
        return nullptr;
    }

    // Create node directly - template system is the authority
    Node* node = new Node();
    if (!node) {
        qCritical() << "GraphFactory::createNodeFromXml - failed to create node";
        return nullptr;
    }

    // Set node type BEFORE reading XML
    node->setNodeType(nodeType);

    // Attach factory pointer before reading XML - contract requirement
    node->setFactory(this);

    // Let the node read its XML and configure itself
    node->read(xmlNode);

    // Verify factory pointer is still attached
    if (!node->hasFactory()) {
        qCritical() << "GraphFactory::createNodeFromXml - factory detached during read";
        delete node;
        return nullptr;
    }
    
    // Add to scene's typed collection
    m_scene->addNode(node);
    
    qDebug() << "GraphFactory: Created node from XML, type:" << nodeType 
             << "id:" << node->getId().toString(QUuid::WithoutBraces).left(8);
    
    return node;
}


Node* GraphFactory::createNode(const QString& nodeType, const QPointF& position, int inputs, int outputs)
{
    if (!m_xmlDocument) {
        qCritical() << "GraphFactory::createNode - no XML document";
        return nullptr;
    }
    
    // Create XML node first with socket configuration
    xmlNodePtr xmlNode = createXmlNode(nodeType, position, inputs, outputs);
    if (!xmlNode) {
        qCritical() << "GraphFactory::createNode - failed to create XML node";
        return nullptr;
    }
    
    // Create object from XML
    return createNodeFromXml(xmlNode);
}


QString GraphFactory::getXmlProperty(xmlNodePtr node, const QString& name)
{
    if (!node) return QString();
    
    xmlChar* prop = xmlGetProp(node, BAD_CAST name.toUtf8().constData());
    if (!prop) return QString();
    
    QString result = QString::fromUtf8((char*)prop);
    xmlFree(prop);
    return result;
}

xmlNodePtr GraphFactory::createXmlNode(const QString& nodeType, const QPointF& position, int inputs, int outputs)
{
    xmlNodePtr nodesElement = getNodesElement();
    if (!nodesElement) {
        qCritical() << "GraphFactory::createXmlNode - no nodes element in XML";
        return nullptr;
    }
    
    // Create new node element
    xmlNodePtr nodeElement = xmlNewChild(nodesElement, nullptr, BAD_CAST "node", nullptr);
    
    // Set attributes including socket configuration
    QUuid nodeId = QUuid::createUuid();
    xmlSetProp(nodeElement, BAD_CAST "id", BAD_CAST nodeId.toString(QUuid::WithoutBraces).toUtf8().constData());
    xmlSetProp(nodeElement, BAD_CAST "type", BAD_CAST nodeType.toUtf8().constData());
    xmlSetProp(nodeElement, BAD_CAST "x", BAD_CAST QString::number(position.x()).toUtf8().constData());
    xmlSetProp(nodeElement, BAD_CAST "y", BAD_CAST QString::number(position.y()).toUtf8().constData());
    xmlSetProp(nodeElement, BAD_CAST "inputs", BAD_CAST QString::number(inputs).toUtf8().constData());
    xmlSetProp(nodeElement, BAD_CAST "outputs", BAD_CAST QString::number(outputs).toUtf8().constData());
    
    qDebug() << "GraphFactory: Created XML node, type:" << nodeType << "id:" << nodeId.toString(QUuid::WithoutBraces).left(8)
             << "inputs:" << inputs << "outputs:" << outputs;
    
    return nodeElement;
}


xmlNodePtr GraphFactory::getNodesElement()
{
    if (!m_xmlDocument) return nullptr;
    
    xmlNodePtr root = xmlDocGetRootElement(m_xmlDocument);
    if (!root) return nullptr;
    
    // Find or create <nodes> element
    for (xmlNodePtr child = root->children; child; child = child->next) {
        if (xmlStrcmp(child->name, BAD_CAST "nodes") == 0) {
            return child;
        }
    }
    
    // Create nodes element if it doesn't exist
    xmlNodePtr nodesElement = xmlNewChild(root, nullptr, BAD_CAST "nodes", nullptr);
    return nodesElement;
}




/// ===== FILE: window.h =====
#pragma once

#include <QMainWindow>
#include <QString>
#include <QToolBar>
#include <QAction>
#include <QDockWidget>
#include <QLabel>
#include <QStatusBar>
#include <QMenuBar>
#include <QProgressBar>
#include <QSpinBox>
#include <QComboBox>
#include <libxml/tree.h>

class View;
class Scene;
class QGraph;
class GraphFactory;
class JavaScriptEngine;
class XmlAutosaveObserver;
class NodePaletteWidget;
// class JavaScriptConsole;  // Disabled for now

/**
 * Window - Enhanced main window for self-serializing node editor
 * 
 * Features:
 * - Professional UI with dock widgets and status bar
 * - Node palette with drag-and-drop functionality
 * - Multi-section status bar with graph statistics
 * - Menu system with proper actions
 * - Integration with self-serializing architecture
 */
class Window : public QMainWindow
{
public:
    explicit Window(QWidget* parent = nullptr);
    ~Window();
    
    // Access to scene for testing
    Scene* getScene() const { return m_scene; }

    // Update status bar with current graph information
    void updateStatusBar();

    // Create node at specific position (disabled for now)
    // void createNodeAtPosition(const QString& nodeType, const QPointF& scenePos);

    // Simple script execution
    void loadAndExecuteScript();
    void executeScriptFile(const QString& filePath);

    // Command-line driven initialization
    void setAutoTestScript(const QString& scriptPath);

protected:
    // PHASE 3: Safe shutdown coordination
    void closeEvent(QCloseEvent* event) override;
    void showEvent(QShowEvent* event) override;
public slots:
    // Scene event handlers
    void onSceneChanged();
    void onSelectionChanged();
    
    // Basic XML saving functionality
    bool saveGraph(const QString& filename);
    bool loadGraph(const QString& filename);
    
    // File management
    void setCurrentFile(const QString& filename);
    QString getCurrentFile() const { return m_currentFile; }

    // Node creation from palette (template system only)
    void createNodeFromPalette(const QPointF& scenePos, const QString& nodeType, 
                              const QString& name, int inputSockets, int outputSockets);
    
private slots:
    // Menu actions
    void newFile();
    void openFile();
    void saveFile();
    void saveAsFile();
    void exportGraph();
    void showAbout();
    
    // View actions
    void zoomIn();
    void zoomOut();
    void zoomFit();
    void zoomReset();
    
    // Selection info update
    void updateSelectionInfo();

    // Palette integration removed - nodes created via drag-and-drop only

protected:
    // Handle keyboard shortcuts
    void keyPressEvent(QKeyEvent* event) override;

private:
    Scene* m_scene;
    QGraph* m_graph;  // Graph orchestration layer
    View* m_view;
    GraphFactory* m_factory;
    JavaScriptEngine* m_jsEngine;  // Application logic layer
    xmlDocPtr m_xmlDocument;
    XmlAutosaveObserver* m_autosaveObserver;

    // UI elements - legacy actions removed (use NodePalette instead)

    // Professional node palette system
    QDockWidget* m_nodePaletteDock;
    NodePaletteWidget* m_nodePalette;
    
    // JavaScript console (disabled for now)
    // QDockWidget* m_javaScriptConsoleDock;
    // JavaScriptConsole* m_javaScriptConsole;
    
    // Status bar components
    QLabel* m_fileInfoLabel;      // Current file info
    QLabel* m_graphStatsLabel;    // Node/edge count
    QLabel* m_selectionLabel;     // Selection information
    QLabel* m_positionLabel;      // Mouse position
    QLabel* m_zoomLabel;          // Current zoom level
    QProgressBar* m_operationProgress; // For long operations
    
    // Menu system
    QMenu* m_fileMenu;
    QMenu* m_editMenu;
    QMenu* m_viewMenu;
    QMenu* m_toolsMenu;
    QMenu* m_helpMenu;
    
    // File management
    QString m_currentFile;

    // Command-line driven initialization
    QString m_autoTestScript;
    bool m_firstShow;

    // Setup methods
    void setupUI();
    void setupMenus();
    void setupActions();
    void setupStatusBar();
    void setupDockWidgets();
    
    // Menu creation helpers
    void createFileMenu();
    void createEditMenu();
    void createViewMenu();
    void createToolsMenu();
    void createHelpMenu();
    
    // Status bar helpers
    void createStatusBarWidgets();
    void connectStatusBarSignals();
};


/// ===== FILE: window.cpp =====
#include "window.h"
#include "view.h"
#include "scene.h"
#include "qgraph.h"
#include "node.h"
#include "edge.h"
#include "graph_factory.h"
#include "xml_autosave_observer.h"
#include "javascript_engine.h"
#include "node_palette_widget.h"
#include "graphics_item_keys.h"
// #include "javascript_console.h"  // Disabled for now
#include <QKeyEvent>
#include <QFileDialog>
#include <QMessageBox>
#include <QDebug>
#include <QElapsedTimer>
#include <QFileInfo>
#include <QAction>
#include <QIcon>
#include <QRandomGenerator>
#include <QDockWidget>
#include <QLabel>
#include <QStatusBar>
#include <QMenuBar>
#include <QProgressBar>
#include <QApplication>
#include <QDesktopServices>
#include <QUrl>
#include <QJSValue>
#include <libxml/tree.h>
#include <libxml/xmlsave.h>

Window::Window(QWidget* parent)
    : QMainWindow(parent)
    , m_scene(new Scene(this))
    , m_graph(new QGraph(m_scene, this))  // QGraph wraps Scene
    , m_view(new View(m_scene, this))
    , m_jsEngine(new JavaScriptEngine(this))  // Application logic layer
    , m_firstShow(true)
{
    setWindowTitle("NodeGraph - Self-Serializing Node Editor");
    resize(1400, 900);
    
    // Initialize UI components to nullptr
    m_nodePaletteDock = nullptr;
    m_nodePalette = nullptr;
    // m_javaScriptConsoleDock = nullptr;
    // m_javaScriptConsole = nullptr;
    m_fileInfoLabel = nullptr;
    m_graphStatsLabel = nullptr;
    m_selectionLabel = nullptr;
    m_positionLabel = nullptr;
    m_zoomLabel = nullptr;
    m_operationProgress = nullptr;
    
    // Create XML document for factory
    m_xmlDocument = xmlNewDoc(BAD_CAST "1.0");
    xmlNodePtr root = xmlNewNode(nullptr, BAD_CAST "graph");
    xmlDocSetRootElement(m_xmlDocument, root);
    xmlSetProp(root, BAD_CAST "version", BAD_CAST "1.0");
    
    // Initialize factory for interactive node creation
    m_factory = new GraphFactory(m_scene, m_xmlDocument);

    // Initialize JavaScript engine with API bindings
    if (m_jsEngine) {
        m_jsEngine->registerNodeAPI(m_scene);
        m_jsEngine->registerGraphAPI();
        m_jsEngine->registerQGraph(m_graph);
        qDebug() << "Window: JavaScript engine initialized and APIs registered";
    }

    // Initialize autosave observer for automatic XML saving
    m_autosaveObserver = new XmlAutosaveObserver(m_scene, "autosave.xml");
    m_autosaveObserver->setDelay(750); // 750ms delay after changes
    
    // CRITICAL: Attach observer to scene to receive notifications
    m_scene->attach(m_autosaveObserver);
    
    // Setup enhanced UI
    setupUI();
    setupActions();
    setupMenus();
    setupStatusBar();
    setupDockWidgets(); // JavaScript console disabled for now
    
    // Connect scene signals for status updates
    connect(m_scene, &Scene::sceneChanged, this, &Window::onSceneChanged);
    
    // Connect view signals for drag-and-drop
    connect(m_view, &View::nodeDropped, this, &Window::createNodeFromPalette);
    
    // Initial status update
    updateStatusBar();
    
    // Enable keyboard shortcuts
    setFocusPolicy(Qt::StrongFocus);
}

Window::~Window()
{
    // Clean up autosave observer
    if (m_autosaveObserver) {
        m_scene->detach(m_autosaveObserver);
        delete m_autosaveObserver;
    }
    
    // Clean up XML document
    if (m_xmlDocument) {
        xmlFreeDoc(m_xmlDocument);
        m_xmlDocument = nullptr;
    }
}

void Window::setupActions()
{
    // Legacy node creation actions removed - use NodePalette instead
    // All node types are created through the template system (SOURCE, SINK, TRANSFORM, MERGE, SPLIT)
}


void Window::keyPressEvent(QKeyEvent* event)
{
    if (event->modifiers() & Qt::ControlModifier) {
        switch (event->key()) {
            case Qt::Key_S:
                if (event->modifiers() & Qt::ShiftModifier) {
                    // Ctrl+Shift+S = Save As
                    QString filename = QFileDialog::getSaveFileName(
                        this, 
                        "Save Graph As", 
                        "graph.xml", 
                        "XML Files (*.xml)");
                    if (!filename.isEmpty()) {
                        if (saveGraph(filename)) {
                            m_currentFile = filename;
                            setWindowTitle(QString("Node Editor - %1").arg(QFileInfo(filename).fileName()));
                        }
                    }
                } else {
                    // Ctrl+S = Save
                    if (m_currentFile.isEmpty()) {
                        // No current file, show Save As dialog
                        QString filename = QFileDialog::getSaveFileName(
                            this, 
                            "Save Graph", 
                            "graph.xml", 
                            "XML Files (*.xml)");
                        if (!filename.isEmpty()) {
                            if (saveGraph(filename)) {
                                m_currentFile = filename;
                                setWindowTitle(QString("Node Editor - %1").arg(QFileInfo(filename).fileName()));
                            }
                        }
                    } else {
                        // Save to current file
                        saveGraph(m_currentFile);
                    }
                }
                break;
            case Qt::Key_O:
                // Ctrl+O = Open
                {
                    QString filename = QFileDialog::getOpenFileName(
                        this, 
                        "Open Graph", 
                        "", 
                        "XML Files (*.xml)");
                    if (!filename.isEmpty()) {
                        if (loadGraph(filename)) {
                            m_currentFile = filename;
                            setWindowTitle(QString("Node Editor - %1").arg(QFileInfo(filename).fileName()));
                        }
                    }
                }
                break;
        }
    } else if (event->key() == Qt::Key_Delete || event->key() == Qt::Key_Backspace) {
        // Delete selected items
        qDebug() << "🗑️ Delete key pressed - deleting selected items";
        m_graph->deleteSelected();  // Use QGraph instead of Scene
    }
    QMainWindow::keyPressEvent(event);
}

void Window::setCurrentFile(const QString& filename)
{
    m_currentFile = filename;
    if (!filename.isEmpty()) {
        setWindowTitle(QString("Node Editor - %1").arg(QFileInfo(filename).fileName()));
        qDebug() << "📁 Current file set to:" << filename;
    } else {
        setWindowTitle("Node Editor");
        qDebug() << "📁 Current file cleared";
    }
}

bool Window::saveGraph(const QString& filename)
{
    qDebug() << "Saving graph to:" << filename;
    
    QElapsedTimer timer;
    timer.start();
    
    // Create XML document
    xmlDocPtr doc = xmlNewDoc(BAD_CAST "1.0");
    xmlNodePtr root = xmlNewNode(nullptr, BAD_CAST "graph");
    xmlDocSetRootElement(doc, root);
    xmlSetProp(root, BAD_CAST "version", BAD_CAST "1.0");
    
    // Step 1: Save all nodes
    for (Node* node : m_scene->getNodes().values()) {
        xmlNodePtr nodeXml = node->write(doc, root);
        Q_UNUSED(nodeXml)
    }
    
    // Step 2: Save all edges
    for (Edge* edge : m_scene->getEdges().values()) {
        xmlNodePtr edgeXml = edge->write(doc, root);
        Q_UNUSED(edgeXml)
    }
    
    // Step 3: Save to file
    int result = xmlSaveFormatFileEnc(filename.toUtf8().constData(), doc, "UTF-8", 1);
    xmlFreeDoc(doc);
    
    qint64 elapsed = timer.elapsed();
    
    if (result != -1) {
        QFileInfo fileInfo(filename);
        qint64 fileSize = fileInfo.size();
        int nodeCount = m_scene->getNodes().size();
        int edgeCount = m_scene->getEdges().size();
        
        qDebug() << "✅ MANUAL SAVE COMPLETE:";
        qDebug() << "   📁 File:" << fileInfo.fileName();
        qDebug() << "   ⏱️  Time:" << elapsed << "ms";
        qDebug() << "   📊 Size:" << (fileSize / 1024.0) << "KB";
        qDebug() << "   🔵 Nodes:" << nodeCount;
        qDebug() << "   🔗 Edges:" << edgeCount;
        
        QMessageBox::information(this, "Save Complete", 
            QString("Graph saved successfully!\n\n📁 File: %1\n🔵 Nodes: %2\n🔗 Edges: %3\n⏱️ Time: %4ms\n📊 Size: %5 KB")
            .arg(fileInfo.fileName())
            .arg(nodeCount)
            .arg(edgeCount)
            .arg(elapsed)
            .arg(fileSize / 1024.0, 0, 'f', 1));
        return true;
    } else {
        qDebug() << "✗ Failed to save graph";
        QMessageBox::critical(this, "Save Error", "Failed to save graph to file.");
        return false;
    }
}

bool Window::loadGraph(const QString& filename)
{
    qDebug() << "=== LOADING GRAPH ===" << filename;
    
    QElapsedTimer timer;
    timer.start();
    
    // Clear current scene AND registries to prevent dangling pointers
    qDebug() << "Clearing current graph...";
    m_graph->clear();
    
    // Use GraphFactory to load from XML file
    qDebug() << "Starting GraphFactory XML load...";
    if (m_graph->loadXml(filename)) {
        qint64 elapsed = timer.elapsed();
        
        // Set current file for Ctrl+S functionality
        m_currentFile = filename;
        setWindowTitle(QString("Node Editor - %1").arg(QFileInfo(filename).fileName()));
        
        qDebug() << "✓ Graph loaded successfully in" << elapsed << "ms";
        
        // DEBUGGING: Detailed count verification
        int nodeCount = m_scene->getNodes().size();
        int edgeCount = m_scene->getEdges().size();
        qDebug() << "DEBUG: Hash container sizes:";
        qDebug() << "  m_scene->getNodes().size() =" << nodeCount;
        qDebug() << "  m_scene->getEdges().size() =" << edgeCount;
        qDebug() << "  Qt scene items count:" << m_scene->items().size();
        qDebug() << "  Current file set to:" << m_currentFile;
        
        QMessageBox::information(this, "Load Complete", 
            QString("Graph loaded successfully!\n\nFile: %1\nNodes: %2\nEdges: %3\nTime: %4ms\n\nCtrl+S will now save to this file.")
            .arg(QFileInfo(filename).fileName())
            .arg(nodeCount)
            .arg(edgeCount)
            .arg(elapsed));
        return true;
    } else {
        qDebug() << "✗ Failed to load graph";
        QMessageBox::critical(this, "Load Error", 
            QString("Failed to load graph from file.\n\nFile: %1")
            .arg(QFileInfo(filename).fileName()));
        return false;
    }
}

void Window::createNodeFromPalette(const QPointF& scenePos, const QString& nodeType, 
                                  const QString& name, int inputSockets, int outputSockets)
{
    qDebug() << "========================================";
    qDebug() << "Window: RECEIVED nodeDropped signal";
    qDebug() << "Window: Creating node from palette:";
    qDebug() << "  - Name:" << name;
    qDebug() << "  - Type:" << nodeType;
    qDebug() << "  - Position:" << scenePos;
    qDebug() << "  - Input sockets:" << inputSockets;
    qDebug() << "  - Output sockets:" << outputSockets;
    qDebug() << "Window: Calling factory->createNode()";
    
    // Create node using factory with the exact specifications from the palette
    Node* node = m_factory->createNode(nodeType, scenePos, inputSockets, outputSockets);
    
    if (node) {
        qDebug() << "✓ Window: Factory successfully created" << name << "node";
        qDebug() << "Window: Node created at scene position:" << scenePos;
        qDebug() << "Window: Updating status bar";
        
        // Update status bar to reflect the new node
        updateStatusBar();
        statusBar()->showMessage(QString("Created %1 node").arg(name), 2000);
        
        qDebug() << "✓ Window: Node creation process completed successfully";
    } else {
        qDebug() << "✗ Window: Factory FAILED to create" << name << "node";
        qDebug() << "Window: This may indicate factory or scene issues";
        statusBar()->showMessage(QString("Failed to create %1 node").arg(name), 3000);
    }
    qDebug() << "========================================";
}

// ============================================================================
// Enhanced UI Implementation - Lookatme + Inkscape Status Bar Patterns
// ============================================================================

void Window::setupUI()
{
    setCentralWidget(m_view);
    
    // Set application icon and improve window appearance
    setWindowIcon(QIcon(":/icons/app-icon.png")); // Optional - if you have icons
    
    // Enable dock widget features
    setDockOptions(QMainWindow::AllowNestedDocks | 
                   QMainWindow::AllowTabbedDocks | 
                   QMainWindow::AnimatedDocks);
}

void Window::setupMenus()
{
    createFileMenu();
    createEditMenu();
    createViewMenu();
    createToolsMenu();
    createHelpMenu();
}

void Window::createFileMenu()
{
    m_fileMenu = menuBar()->addMenu("&File");
    
    // New file
    QAction* newAction = new QAction("&New", this);
    newAction->setShortcut(QKeySequence::New);
    newAction->setStatusTip("Create a new graph");
    connect(newAction, &QAction::triggered, this, &Window::newFile);
    m_fileMenu->addAction(newAction);
    
    // Open file
    QAction* openAction = new QAction("&Open...", this);
    openAction->setShortcut(QKeySequence::Open);
    openAction->setStatusTip("Open an existing graph");
    connect(openAction, &QAction::triggered, this, &Window::openFile);
    m_fileMenu->addAction(openAction);
    
    m_fileMenu->addSeparator();
    
    // Save file
    QAction* saveAction = new QAction("&Save", this);
    saveAction->setShortcut(QKeySequence::Save);
    saveAction->setStatusTip("Save the current graph");
    connect(saveAction, &QAction::triggered, this, &Window::saveFile);
    m_fileMenu->addAction(saveAction);
    
    // Save As
    QAction* saveAsAction = new QAction("Save &As...", this);
    saveAsAction->setShortcut(QKeySequence::SaveAs);
    saveAsAction->setStatusTip("Save the graph with a new name");
    connect(saveAsAction, &QAction::triggered, this, &Window::saveAsFile);
    m_fileMenu->addAction(saveAsAction);
    
    m_fileMenu->addSeparator();
    
    // Export
    QAction* exportAction = new QAction("&Export...", this);
    exportAction->setStatusTip("Export graph to various formats");
    connect(exportAction, &QAction::triggered, this, &Window::exportGraph);
    m_fileMenu->addAction(exportAction);
    
    m_fileMenu->addSeparator();
    
    // Exit
    QAction* exitAction = new QAction("E&xit", this);
    exitAction->setShortcut(QKeySequence::Quit);
    exitAction->setStatusTip("Exit the application");
    connect(exitAction, &QAction::triggered, this, &QWidget::close);
    m_fileMenu->addAction(exitAction);
}

void Window::createEditMenu()
{
    m_editMenu = menuBar()->addMenu("&Edit");
    
    // Undo/Redo placeholders for future implementation
    QAction* undoAction = new QAction("&Undo", this);
    undoAction->setShortcut(QKeySequence::Undo);
    undoAction->setEnabled(false); // TODO: Implement undo system
    m_editMenu->addAction(undoAction);
    
    QAction* redoAction = new QAction("&Redo", this);
    redoAction->setShortcut(QKeySequence::Redo);
    redoAction->setEnabled(false); // TODO: Implement redo system
    m_editMenu->addAction(redoAction);
    
    m_editMenu->addSeparator();
    
    // Selection operations
    QAction* selectAllAction = new QAction("Select &All", this);
    selectAllAction->setShortcut(QKeySequence::SelectAll);
    selectAllAction->setStatusTip("Select all nodes and edges");
    m_editMenu->addAction(selectAllAction);
    
    QAction* deselectAction = new QAction("&Deselect All", this);
    deselectAction->setShortcut(QKeySequence("Ctrl+D"));
    deselectAction->setStatusTip("Clear selection");
    m_editMenu->addAction(deselectAction);
    
    m_editMenu->addSeparator();
    
    // Delete
    QAction* deleteAction = new QAction("&Delete Selected", this);
    deleteAction->setShortcut(QKeySequence::Delete);
    deleteAction->setStatusTip("Delete selected nodes and edges");
    m_editMenu->addAction(deleteAction);
}

void Window::createViewMenu()
{
    m_viewMenu = menuBar()->addMenu("&View");
    
    // Zoom operations
    QAction* zoomInAction = new QAction("Zoom &In", this);
    zoomInAction->setShortcut(QKeySequence::ZoomIn);
    zoomInAction->setStatusTip("Zoom in to the graph");
    connect(zoomInAction, &QAction::triggered, this, &Window::zoomIn);
    m_viewMenu->addAction(zoomInAction);
    
    QAction* zoomOutAction = new QAction("Zoom &Out", this);
    zoomOutAction->setShortcut(QKeySequence::ZoomOut);
    zoomOutAction->setStatusTip("Zoom out from the graph");
    connect(zoomOutAction, &QAction::triggered, this, &Window::zoomOut);
    m_viewMenu->addAction(zoomOutAction);
    
    QAction* zoomFitAction = new QAction("Zoom to &Fit", this);
    zoomFitAction->setShortcut(QKeySequence("Ctrl+0"));
    zoomFitAction->setStatusTip("Fit entire graph in view");
    connect(zoomFitAction, &QAction::triggered, this, &Window::zoomFit);
    m_viewMenu->addAction(zoomFitAction);
    
    QAction* zoomResetAction = new QAction("&Reset Zoom", this);
    zoomResetAction->setShortcut(QKeySequence("Ctrl+1"));
    zoomResetAction->setStatusTip("Reset zoom to 100%");
    connect(zoomResetAction, &QAction::triggered, this, &Window::zoomReset);
    m_viewMenu->addAction(zoomResetAction);
    
    m_viewMenu->addSeparator();
    
    // Dock widget toggles will be added after dock widgets are created
}

void Window::createToolsMenu()
{
    m_toolsMenu = menuBar()->addMenu("&Tools");

    // Legacy "Create Node" submenu removed - use NodePalette instead
    // All node creation now goes through template system (drag from palette)
    
    QAction* validateAction = new QAction("&Validate Graph", this);
    validateAction->setStatusTip("Check graph for errors and inconsistencies");
    m_toolsMenu->addAction(validateAction);
    
    QAction* statisticsAction = new QAction("Graph &Statistics", this);
    statisticsAction->setStatusTip("Show detailed graph statistics");
    m_toolsMenu->addAction(statisticsAction);

    // Simple script execution
    m_toolsMenu->addSeparator();
    QAction* jsScriptAction = new QAction("📝 Load &Script", this);
    jsScriptAction->setStatusTip("Load and execute JavaScript script");
    jsScriptAction->setShortcut(QKeySequence("Ctrl+Shift+L"));
    connect(jsScriptAction, &QAction::triggered, this, &Window::loadAndExecuteScript);
    m_toolsMenu->addAction(jsScriptAction);
}

void Window::createHelpMenu()
{
    m_helpMenu = menuBar()->addMenu("&Help");
    
    QAction* aboutAction = new QAction("&About", this);
    aboutAction->setStatusTip("About this application");
    connect(aboutAction, &QAction::triggered, this, &Window::showAbout);
    m_helpMenu->addAction(aboutAction);
    
    QAction* aboutQtAction = new QAction("About &Qt", this);
    aboutQtAction->setStatusTip("About Qt Framework");
    connect(aboutQtAction, &QAction::triggered, qApp, &QApplication::aboutQt);
    m_helpMenu->addAction(aboutQtAction);
}

void Window::setupStatusBar()
{
    createStatusBarWidgets();
    connectStatusBarSignals();
}

void Window::createStatusBarWidgets()
{
    QStatusBar* statusBar = this->statusBar();
    statusBar->setStyleSheet(
        "QStatusBar {"
        "  border-top: 1px solid #bdc3c7;"
        "  background: #ecf0f1;"
        "}"
        "QStatusBar::item {"
        "  border: none;"
        "}"
    );
    
    // File info (leftmost)
    m_fileInfoLabel = new QLabel("No file loaded");
    m_fileInfoLabel->setStyleSheet("QLabel { color: #2c3e50; margin-right: 15px; }");
    statusBar->addWidget(m_fileInfoLabel);
    
    // Graph statistics
    m_graphStatsLabel = new QLabel("Nodes: 0 | Edges: 0");
    m_graphStatsLabel->setStyleSheet("QLabel { color: #27ae60; font-weight: bold; margin-right: 15px; }");
    statusBar->addWidget(m_graphStatsLabel);
    
    // Selection info
    m_selectionLabel = new QLabel("No selection");
    m_selectionLabel->setStyleSheet("QLabel { color: #8e44ad; margin-right: 15px; }");
    statusBar->addWidget(m_selectionLabel);
    
    // Add stretch to push remaining widgets to the right
    statusBar->addPermanentWidget(new QWidget(), 1);
    
    // Mouse position (right side)
    m_positionLabel = new QLabel("Position: (0, 0)");
    m_positionLabel->setStyleSheet("QLabel { color: #34495e; margin-right: 10px; }");
    statusBar->addPermanentWidget(m_positionLabel);
    
    // Zoom level (rightmost)
    m_zoomLabel = new QLabel("Zoom: 100%");
    m_zoomLabel->setStyleSheet("QLabel { color: #e74c3c; font-weight: bold; }");
    statusBar->addPermanentWidget(m_zoomLabel);
    
    // Operation progress (hidden by default)
    m_operationProgress = new QProgressBar();
    m_operationProgress->setVisible(false);
    m_operationProgress->setMaximumWidth(200);
    statusBar->addPermanentWidget(m_operationProgress);
}

void Window::connectStatusBarSignals()
{
    // Update status bar when scene changes
    connect(m_scene, &Scene::sceneChanged, this, &Window::updateStatusBar);
    
    // TODO: Connect view signals for mouse position and zoom updates
    // This would require extending the View class to emit these signals
}

void Window::setupDockWidgets()
{
    // Create node palette dock widget
    m_nodePaletteDock = new QDockWidget("Node Palette", this);
    m_nodePaletteDock->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    m_nodePaletteDock->setFeatures(QDockWidget::DockWidgetMovable | QDockWidget::DockWidgetFloatable);
    
    // Create palette widget
    m_nodePalette = new NodePaletteWidget();
    m_nodePaletteDock->setWidget(m_nodePalette);
    
    // Add dock widget to left side
    addDockWidget(Qt::LeftDockWidgetArea, m_nodePaletteDock);
    
    // Note: Node creation handled via drag-and-drop (View::nodeDropped signal)
    // NodeCreationRequested signal not used - nodes created only through template system
    
}

void Window::updateStatusBar()
{
    if (!m_scene) return;
    
    // Update graph statistics
    int nodeCount = m_scene->getNodes().size();
    int edgeCount = m_scene->getEdges().size();
    m_graphStatsLabel->setText(QString("Nodes: %1 | Edges: %2").arg(nodeCount).arg(edgeCount));
    
    // Update file info
    if (m_currentFile.isEmpty()) {
        m_fileInfoLabel->setText("No file loaded");
    } else {
        QFileInfo fileInfo(m_currentFile);
        m_fileInfoLabel->setText(QString("File: %1").arg(fileInfo.fileName()));
    }
    
    // Update selection info (placeholder for now)
    QList<QGraphicsItem*> selectedItems = m_scene->selectedItems();
    if (selectedItems.isEmpty()) {
        m_selectionLabel->setText("No selection");
    } else {
        m_selectionLabel->setText(QString("Selected: %1 items").arg(selectedItems.size()));
    }
}

// ============================================================================
// Slot Implementations
// ============================================================================

void Window::onSceneChanged()
{
    updateStatusBar();
}

void Window::onSelectionChanged()
{
    updateSelectionInfo();
}

void Window::updateSelectionInfo()
{
    if (!m_scene) return;
    
    // ✅ CAST-FREE IMPLEMENTATION using metadata keys
    QList<QGraphicsItem*> selectedItems = m_scene->selectedItems();
    if (selectedItems.isEmpty()) {
        m_selectionLabel->setText("No selection");
    } else {
        int nodeCount = 0;
        int edgeCount = 0;

        for (QGraphicsItem* item : selectedItems) {
            const auto k = item->data(Gik::KindKey);
            if (!k.isValid()) continue;

            if (k.toInt() == Gik::Kind_Node) {
                nodeCount++;
            } else if (k.toInt() == Gik::Kind_Edge) {
                edgeCount++;
            }
        }

        QString selectionText;
        if (nodeCount > 0 && edgeCount > 0) {
            selectionText = QString("Selected: %1 nodes, %2 edges").arg(nodeCount).arg(edgeCount);
        } else if (nodeCount > 0) {
            selectionText = QString("Selected: %1 nodes").arg(nodeCount);
        } else if (edgeCount > 0) {
            selectionText = QString("Selected: %1 edges").arg(edgeCount);
        }

        m_selectionLabel->setText(selectionText);
    }
}

// ============================================================================
// Menu Action Implementations (Placeholders)
// ============================================================================

void Window::newFile()
{
    // TODO: Clear current scene and reset
    qDebug() << "🆕 New file requested";
}

void Window::openFile()
{
    qDebug() << "=== FILE OPEN DIALOG ===";
    QString fileName = QFileDialog::getOpenFileName(this, "Open Graph", "", "XML Files (*.xml)");
    if (!fileName.isEmpty()) {
        qDebug() << "File selected:" << fileName;
        if (loadGraph(fileName)) {
            setCurrentFile(fileName);
            updateStatusBar();
            qDebug() << "File loaded successfully";
        } else {
            qDebug() << "File load FAILED";
        }
    } else {
        qDebug() << "File dialog cancelled";
    }
}

void Window::saveFile()
{
    qDebug() << "=== CTRL+S SAVE TRIGGERED ===";
    qDebug() << "Current file:" << (m_currentFile.isEmpty() ? "NONE (will show Save As dialog)" : m_currentFile);
    
    if (m_currentFile.isEmpty()) {
        qDebug() << "No current file - opening Save As dialog...";
        saveAsFile();
    } else {
        qDebug() << "Saving to current file:" << m_currentFile;
        if (saveGraph(m_currentFile)) {
            qDebug() << "✓ Save successful";
            updateStatusBar();
        } else {
            qDebug() << "✗ Save FAILED";
        }
    }
}

void Window::saveAsFile()
{
    QString fileName = QFileDialog::getSaveFileName(this, "Save Graph", "", "XML Files (*.xml)");
    if (!fileName.isEmpty()) {
        if (saveGraph(fileName)) {
            setCurrentFile(fileName);
            updateStatusBar();
        }
    }
}

void Window::exportGraph()
{
    // TODO: Implement export functionality
    QMessageBox::information(this, "Export", "Export functionality will be implemented in a future update.");
}

void Window::showAbout()
{
    QMessageBox::about(this, "About NodeGraph",
        "<h3>NodeGraph - Self-Serializing Node Editor</h3>"
        "<p>A professional node-based graph editor with self-serializing architecture.</p>"
        "<p><b>Features:</b></p>"
        "<ul>"
        "<li>Self-serializing nodes with libxml2 backend</li>"
        "<li>Observer pattern with automatic XML persistence</li>"
        "<li>Professional UI with docking panels</li>"
        "<li>Enhanced visual selection highlighting</li>"
        "<li>Drag-and-drop node creation</li>"
        "</ul>"
        "<p>Built with Qt5 and modern C++ patterns.</p>");
}

void Window::zoomIn()
{
    m_view->scale(1.2, 1.2);
    // TODO: Update zoom label
}

void Window::zoomOut()
{
    m_view->scale(0.8, 0.8);
    // TODO: Update zoom label
}

void Window::zoomFit()
{
    m_view->fitInView(m_scene->itemsBoundingRect(), Qt::KeepAspectRatio);
    // TODO: Update zoom label
}

void Window::zoomReset()
{
    m_view->resetTransform();
    // TODO: Update zoom label
}

/*
void Window::createNodeAtPosition(const QString& nodeType, const QPointF& scenePos)
{
    // Drag-and-drop node creation disabled for now
    // Focus on JavaScript integration
}
*/

// ============================================================================
// PHASE 3: Safe Shutdown Coordination
// ============================================================================

void Window::closeEvent(QCloseEvent* event)
{
    qDebug() << "PHASE1: Window shutdown initiated";
    
    // PHASE 1.2: Prepare scene for safe shutdown
    if (m_scene) {
        m_scene->prepareForShutdown();
    }
    
    // Accept the close event (no dirty state tracking yet)
    QMainWindow::closeEvent(event);
    
    qDebug() << "PHASE1: ✓ Window shutdown complete";
}

void Window::loadAndExecuteScript()
{
    QString fileName = QFileDialog::getOpenFileName(
        this,
        "Load JavaScript File",
        "./scripts/",
        "JavaScript Files (*.js);;All Files (*)"
    );

    if (!fileName.isEmpty()) {
        if (!m_jsEngine) {
            QMessageBox::warning(this, "JavaScript Error", "JavaScript engine not initialized");
            return;
        }

        // Test engine functionality
        QJSValue quickTest = m_jsEngine->evaluate("1 + 1");
        if (quickTest.isError()) {
            QMessageBox::warning(this, "JavaScript Error", "JavaScript engine is not functional");
            return;
        }

        QJSValue result = m_jsEngine->evaluateFile(fileName);

        if (result.isError()) {
            QMessageBox::critical(this, "Script Error",
                                 QString("Script execution failed: %1").arg(result.toString()));
        } else {
            QString resultText = result.isUndefined() ? "Script executed successfully" : result.toString();
            QMessageBox::information(this, "Script Executed",
                                   QString("Script completed: %1").arg(resultText));
        }

        updateStatusBar();
    }
}

void Window::executeScriptFile(const QString& filePath)
{
    qDebug() << "Window: Executing script file:" << filePath;

    if (!m_jsEngine) {
        qCritical() << "JavaScript engine not initialized";
        return;
    }

    // Test engine functionality
    QJSValue quickTest = m_jsEngine->evaluate("1 + 1");
    if (quickTest.isError()) {
        qCritical() << "JavaScript engine is not functional";
        return;
    }

    qDebug() << "Window: Evaluating script file...";
    QJSValue result = m_jsEngine->evaluateFile(filePath);

    if (result.isError()) {
        qCritical() << "Script error:" << result.toString();
    } else {
        QString resultText = result.isUndefined() ? "Script executed successfully" : result.toString();
        qDebug() << "Script result:" << resultText;
    }

    updateStatusBar();
}

void Window::setAutoTestScript(const QString& scriptPath)
{
    m_autoTestScript = scriptPath;
    qDebug() << "Window: Auto-test script set to:" << scriptPath;
}

void Window::showEvent(QShowEvent* event)
{
    QMainWindow::showEvent(event);

    // Run auto-test on first show (if requested via command line)
    if (m_firstShow && !m_autoTestScript.isEmpty()) {
        m_firstShow = false;

        qDebug() << "Window: Running auto-test script on first show...";
        QTimer::singleShot(100, this, [this]() {
            executeScriptFile(m_autoTestScript);
        });
    }
}

// onNodeCreationRequested() removed - nodes created only via drag-and-drop from palette




/// ===== FILE: view.h =====
#pragma once

#include <QGraphicsView>
#include <QMouseEvent>
#include <QWheelEvent>
#include <QDragEnterEvent>
#include <QDragMoveEvent>
#include <QDropEvent>

class Scene;

/**
 * View - Custom graphics view for node editor
 * 
 * Simple boilerplate extending QGraphicsView
 * Handles basic mouse and keyboard events
 */
class View : public QGraphicsView
{
    Q_OBJECT

public:
    explicit View(Scene* scene, QWidget* parent = nullptr);

protected:
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void wheelEvent(QWheelEvent* event) override;

    // Drag and drop support
    void dragEnterEvent(QDragEnterEvent* event) override;
    void dragMoveEvent(QDragMoveEvent* event) override;
    void dropEvent(QDropEvent* event) override;

    // Grid rendering
    void drawBackground(QPainter* painter, const QRectF& rect) override;

signals:
    // Signal emitted when a node is dropped
    void nodeDropped(const QPointF& scenePos, const QString& nodeType, const QString& name, 
                    int inputSockets, int outputSockets);

private:
    Scene* m_scene;
};


/// ===== FILE: view.cpp =====
#include "view.h"
#include "scene.h"
#include "layout_metrics.h"
#include <QMouseEvent>
#include <QWheelEvent>
#include <QDragEnterEvent>
#include <QDragMoveEvent>
#include <QDropEvent>
#include <QMimeData>
#include <QDebug>
#include <cmath>

View::View(Scene* scene, QWidget* parent)
    : QGraphicsView(scene, parent)
    , m_scene(scene)
{
    setRenderHint(QPainter::Antialiasing);
    setRenderHint(QPainter::SmoothPixmapTransform);
    setDragMode(QGraphicsView::NoDrag);  // Temporarily disable rubber band
    setViewportUpdateMode(QGraphicsView::FullViewportUpdate);
    
    // Disable any debug drawing of item bounding rectangles
    setRenderHint(QPainter::Qt4CompatiblePainting, false);
    
    // Additional optimizations to prevent bounding box artifacts
    setOptimizationFlags(QGraphicsView::DontSavePainterState | 
                        QGraphicsView::DontAdjustForAntialiasing);
    
    // Enable drag and drop
    setAcceptDrops(true);
}

void View::mousePressEvent(QMouseEvent* event)
{
    QGraphicsView::mousePressEvent(event);
}

void View::mouseMoveEvent(QMouseEvent* event)
{
    QGraphicsView::mouseMoveEvent(event);
}

void View::mouseReleaseEvent(QMouseEvent* event)
{
    QGraphicsView::mouseReleaseEvent(event);
}

void View::wheelEvent(QWheelEvent* event)
{
    // Simple zoom
    const qreal scaleFactor = 1.15;
    if (event->angleDelta().y() > 0) {
        scale(scaleFactor, scaleFactor);
    } else {
        scale(1.0 / scaleFactor, 1.0 / scaleFactor);
    }
}

void View::dragEnterEvent(QDragEnterEvent* event)
{
    qDebug() << "View: Drag enter event received";
    qDebug() << "View: Available mime formats:" << event->mimeData()->formats();
    
    // Check if the drag contains node template data
    if (event->mimeData()->hasFormat("application/x-node-template")) {
        QByteArray nodeData = event->mimeData()->data("application/x-node-template");
        QString nodeString = QString::fromUtf8(nodeData);
        qDebug() << "View: Node template data detected:" << nodeString;
        
        event->acceptProposedAction();
        qDebug() << "✓ View: Drag enter accepted - node template detected";
    } else {
        event->ignore();
        qDebug() << "✗ View: Drag enter ignored - no node template data";
    }
}

void View::dragMoveEvent(QDragMoveEvent* event)
{
    // Allow drag movement if it contains node template data
    if (event->mimeData()->hasFormat("application/x-node-template")) {
        event->acceptProposedAction();
        // Only log every 10th move event to avoid spam
        static int moveCount = 0;
        if (++moveCount % 10 == 0) {
            QPointF scenePos = mapToScene(event->pos());
            qDebug() << "View: Drag move accepted at scene position:" << scenePos;
        }
    } else {
        event->ignore();
        qDebug() << "View: Drag move ignored - no node template data";
    }  
}

void View::dropEvent(QDropEvent* event)
{
    qDebug() << "View: Drop event received";

    // Handle node template drop
    if (event->mimeData()->hasFormat("application/x-node-template")) {
        QByteArray nodeData = event->mimeData()->data("application/x-node-template");
        QString nodeString = QString::fromUtf8(nodeData);
        qDebug() << "View: Decoding drop data:" << nodeString;

        QStringList parts = nodeString.split("|");
        qDebug() << "View: Split into" << parts.size() << "parts:" << parts;

        if (parts.size() >= 5) {
            QString nodeType = parts[0];
            QString name = parts[1];
            QString description = parts[2];
            int inputSockets = parts[3].toInt();
            int outputSockets = parts[4].toInt();

            // Convert drop position to scene coordinates
            QPointF scenePos = mapToScene(event->pos());

            qDebug() << "View: Parsed node data:";
            qDebug() << "  - Type:" << nodeType;
            qDebug() << "  - Name:" << name;
            qDebug() << "  - Description:" << description;
            qDebug() << "  - Input sockets:" << inputSockets;
            qDebug() << "  - Output sockets:" << outputSockets;
            qDebug() << "  - Scene position:" << scenePos;

            qDebug() << "View: Emitting nodeDropped signal to Window";

            // Emit signal to notify the window
            emit nodeDropped(scenePos, nodeType, name, inputSockets, outputSockets);

            event->acceptProposedAction();
            qDebug() << "✓ View: Drop event accepted and processed";
        } else {
            qWarning() << "✗ View: Invalid node template data format - expected 5 parts, got" << parts.size();
            event->ignore();
        }
    } else {
        qDebug() << "✗ View: Drop event ignored - no node template data";
        event->ignore();
    }
}

void View::drawBackground(QPainter* painter, const QRectF& rect)
{
    // Draw the base background
    QGraphicsView::drawBackground(painter, rect);

    // Only draw grid if scene supports it
    if (!m_scene) return;

    const int gridSize = m_scene->gridSize();
    if (gridSize <= 1) return;

    // Configure grid appearance
    QPen gridPen(QColor(200, 200, 200, 100)); // Light gray, semi-transparent
    gridPen.setWidth(1);
    painter->setPen(gridPen);

    // Calculate grid bounds based on visible rect
    const int left = static_cast<int>(std::floor(rect.left() / gridSize)) * gridSize;
    const int right = static_cast<int>(std::ceil(rect.right() / gridSize)) * gridSize;
    const int top = static_cast<int>(std::floor(rect.top() / gridSize)) * gridSize;
    const int bottom = static_cast<int>(std::ceil(rect.bottom() / gridSize)) * gridSize;

    // Draw vertical lines
    for (int x = left; x <= right; x += gridSize) {
        painter->drawLine(x, static_cast<int>(rect.top()), x, static_cast<int>(rect.bottom()));
    }

    // Draw horizontal lines
    for (int y = top; y <= bottom; y += gridSize) {
        painter->drawLine(static_cast<int>(rect.left()), y, static_cast<int>(rect.right()), y);
    }

    // Draw origin indicator (darker lines at 0,0) with adaptive sizing
    if (rect.contains(QPointF(0, 0))) {
        QPen originPen(QColor(150, 150, 150, 150));
        originPen.setWidth(2);
        painter->setPen(originPen);

        // Adaptive origin cross size based on zoom level
        qreal zoomFactor = transform().m11();  // Get horizontal scale factor
        qreal armLength = LayoutMetrics::originIndicatorBaseSize * zoomFactor;
        armLength = qBound(LayoutMetrics::originIndicatorMinSize,
                          armLength,
                          LayoutMetrics::originIndicatorMaxSize);

        // Draw origin cross with adaptive size
        painter->drawLine(-armLength, 0, armLength, 0);   // Horizontal origin line
        painter->drawLine(0, -armLength, 0, armLength);   // Vertical origin line
    }
}


/// ===== FILE: scene.h =====
#pragma once

#include <QGraphicsScene>
#include <QHash>
#include <QUuid>
#include "graph_observer.h"

class Node;
class Edge;
class Socket;
class GhostEdge;

/**
 * Scene - QElectroTech-style typed scene management
 * 
 * Uses QHash collections for O(1) UUID lookups
 * Never use generic items() - always use typed collections
 * Follows QElectroTech/Fritzing patterns for professional node editors
 */
class Scene : public QGraphicsScene, public GraphSubject
{
    Q_OBJECT

signals:
    void sceneChanged();

public:
    explicit Scene(QObject* parent = nullptr);
    
    // Typed item management - QElectroTech style
    void addNode(Node* node);
    void addEdge(Edge* edge);
    void addSocket(Socket* socket);  // Deprecated - sockets managed by nodes
    
    void removeNode(const QUuid& nodeId);

    // Fast UUID-based lookups O(1) - no searching, no casting
    Node* getNode(const QUuid& nodeId) const;
    Edge* getEdge(const QUuid& edgeId) const;
    
    // Type-safe iteration - never need qgraphicsitem_cast
    const QHash<QUuid, Node*>& getNodes() const { return m_nodes; }
    const QHash<QUuid, Edge*>& getEdges() const { return m_edges; }
    // Clean design: sockets accessed via nodes, not scene
    
    // Internal deletion methods (called by QGraph, not directly)
    void removeNodeInternal(const QUuid& nodeId);
    void removeEdgeInternal(const QUuid& edgeId);
    void removeSelectedInternal();  // Delete all selected items
    void clearGraphInternal();
    
    // PHASE 1.2: Safe shutdown preparation
    void prepareForShutdown();
    bool isShutdownInProgress() const { return m_shutdownInProgress; }
    
    // Public observer notifications (for Node movement)
    using GraphSubject::notifyNodeMoved;
    
    // Ghost edge for visual connection feedback (right-click and drag)
    void startGhostEdge(Socket* fromSocket, const QPointF& startPos);
    void updateGhostEdge(const QPointF& currentPos);
    void finishGhostEdge(Socket* toSocket = nullptr);
    void cancelGhostEdge();
    bool ghostEdgeActive() const { return m_ghostEdgeActive; }

    // Magnetic connection helpers
    Socket* findNearestValidSocket(const QPointF& scenePos, Socket* fromSocket, QPointF& snappedPos);
    qreal getMagneticRadius() const { return 40.0; } // Magnetic attraction radius

    // Grid and snap-to-grid
    QPointF snapPoint(const QPointF& scenePos) const;
    void setSnapToGrid(bool on) { m_snapToGrid = on; }
    bool isSnapToGrid() const { return m_snapToGrid; }
    int gridSize() const { return 40; }  // TODO: make configurable

    // Critical destruction safety flag
    static bool isClearing() { return s_clearingGraph; }

protected:
    // Mouse event handling for ghost edge interactions
    void mouseMoveEvent(QGraphicsSceneMouseEvent* event) override;
    void mouseReleaseEvent(QGraphicsSceneMouseEvent* event) override;

private:
    // QElectroTech-style typed collections with UUID keys
    QHash<QUuid, Node*> m_nodes;
    QHash<QUuid, Edge*> m_edges;
    QHash<QUuid, Socket*> m_sockets;  // Deprecated - kept for compatibility
    
    // Ghost edge for visual feedback during right-click connection creation
    GhostEdge* m_ghostEdge;
    Socket* m_ghostFromSocket;
    bool m_ghostEdgeActive;
    
    // Helper method for ghost edge styling
    QPen ghostPen() const;
    void resetAllSocketStates();

    // Static flag to prevent socket cleanup during clearGraph
    static bool s_clearingGraph;

    // Grid and snap state
    bool m_snapToGrid = false;

    // Shutdown coordination flag
    bool m_shutdownInProgress;
};


/// ===== FILE: scene.cpp =====
#include "scene.h"
#include "node.h"
#include "edge.h"
#include "socket.h"
#include "ghost_edge.h"
#include "graphics_item_keys.h"
#include <QDebug>
#include <QTimer>
#include <QGraphicsPathItem>

Scene::Scene(QObject* parent)
    : QGraphicsScene(parent)
    , m_ghostEdge(nullptr)
    , m_ghostFromSocket(nullptr)
    , m_ghostEdgeActive(false)
    , m_shutdownInProgress(false)
{
    setSceneRect(-1000, -1000, 2000, 2000);
}

// QElectroTech-style QHash implementation with SIMPLE_FIX logging
void Scene::addNode(Node* node)
{
    if (!node) return;
    
    QUuid nodeId = node->getId();
    m_nodes.insert(nodeId, node);
    addItem(node);
    
    qDebug() << "+" << nodeId.toString(QUuid::WithoutBraces).left(8);
    
    // Notify observers of node addition
    notifyNodeAdded(*node);
    
    // Emit signal for UI updates
    emit sceneChanged();
}

void Scene::addEdge(Edge* edge)
{
    if (!edge) return;
    
    QUuid edgeId = edge->getId();
    m_edges.insert(edgeId, edge);
    addItem(edge);
    
    qDebug() << "+" << edgeId.toString(QUuid::WithoutBraces).left(8);
    
    // Notify observers of edge addition
    notifyEdgeAdded(*edge);
    
    // Emit signal for UI updates
    emit sceneChanged();
    
    // Clean design: edges manage their own socket connections via resolveConnections()
}

void Scene::addSocket(Socket* socket)
{
    if (!socket) return;
    
    // Clean design: sockets are managed by their parent nodes, not scene
    // Socket is automatically added to scene as child of parent node
}

void Scene::removeNode(const QUuid& nodeId)
{
    Node* node = m_nodes.value(nodeId, nullptr);
    if (!node) return;
    
    // Clean design: sockets are children of nodes - no separate tracking needed
    
    // Remove connected edges that reference this node
    QList<QUuid> edgesToRemove;
    QString nodeIdStr = nodeId.toString();
    for (Edge* edge : m_edges.values()) {
        if (edge->isConnectedToNode(nodeIdStr)) {
            edgesToRemove.append(edge->getId());
        }
    }
    
    // Clean up edges first (they may reference sockets)
    for (const QUuid& edgeId : edgesToRemove) {
        removeEdgeInternal(edgeId);
    }
    
    // Clean design: sockets cleaned up automatically as node children
    
    // Finally remove the node
    removeItem(node);
    m_nodes.remove(nodeId);
    delete node;
}

// Clean design: socket management methods removed - sockets handled by parent nodes

// O(1) UUID lookups
Node* Scene::getNode(const QUuid& nodeId) const
{
    return m_nodes.value(nodeId, nullptr);
}

Edge* Scene::getEdge(const QUuid& edgeId) const
{
    return m_edges.value(edgeId, nullptr);
}

void Scene::removeNodeInternal(const QUuid& nodeId)
{
    Node* node = getNode(nodeId);
    if (!node) {
        qWarning() << "Scene::deleteNode - node not found:" << nodeId.toString(QUuid::WithoutBraces).left(8);
        return;
    }
    
    qDebug() << "Deleting node:" << nodeId.toString(QUuid::WithoutBraces).left(8);
    
    // First, find and delete all edges connected to this node
    QList<QUuid> edgesToDelete;
    for (auto it = m_edges.begin(); it != m_edges.end(); ++it) {
        Edge* edge = it.value();
        if (edge->isConnectedToNode(nodeId)) {
            edgesToDelete.append(it.key());
        }
    }
    
    // Delete connected edges
    for (const QUuid& edgeId : edgesToDelete) {
        removeEdgeInternal(edgeId);
    }
    
    // Remove node from collections and scene
    m_nodes.remove(nodeId);
    removeItem(node);
    
    // Notify observers BEFORE deleting the node
    notifyNodeRemoved(nodeId);
    
    delete node;
    
    // Emit signal for UI updates
    emit sceneChanged();
    
    qDebug() << "Node deleted with" << edgesToDelete.size() << "connected edges - Observer notified";
}

void Scene::removeEdgeInternal(const QUuid& edgeId)
{
    Edge* edge = getEdge(edgeId);
    if (!edge) {
        qWarning() << "Scene::deleteEdge - edge not found:" << edgeId.toString(QUuid::WithoutBraces).left(8);
        return;
    }

    qDebug() << "Deleting edge:" << edgeId.toString(QUuid::WithoutBraces).left(8);

    // ✅ SOCKET RESET: Clear socket references before deleting edge
    Socket* fromSocket = edge->getFromSocket();
    Socket* toSocket = edge->getToSocket();
    if (fromSocket && fromSocket->getConnectedEdge() == edge) {
        fromSocket->setConnectedEdge(nullptr);
    }
    if (toSocket && toSocket->getConnectedEdge() == edge) {
        toSocket->setConnectedEdge(nullptr);
    }

    // Remove from collection and scene
    m_edges.remove(edgeId);
    removeItem(edge);

    // Notify observers BEFORE deleting the edge
    notifyEdgeRemoved(edgeId);

    delete edge;

    // Emit signal for UI updates
    emit sceneChanged();

    qDebug() << "Edge deleted - Observer notified";
}

void Scene::removeSelectedInternal()
{
    // ✅ CAST-FREE IMPLEMENTATION using metadata keys
    const auto items = selectedItems();
    if (items.isEmpty()) {
        qDebug() << "No items selected for deletion";
        return;
    }

    qDebug() << "DELETE KEY: Deleting" << items.size() << "selected items";

    // Collect UUIDs by kind without any casting
    QList<QUuid> edges, nodes;
    for (QGraphicsItem* it : items) {
        const auto k = it->data(Gik::KindKey);
        const auto u = it->data(Gik::UuidKey);
        if (!k.isValid() || !u.isValid()) continue;

        QUuid id = QUuid::fromString(u.toString());
        if (id.isNull()) continue;

        if (k.toInt() == Gik::Kind_Edge) edges.append(id);
        if (k.toInt() == Gik::Kind_Node) nodes.append(id);
    }

    // Delete edges first, then nodes (proper deletion order)
    for (const QUuid& e : edges) removeEdgeInternal(e);
    for (const QUuid& n : nodes) removeNodeInternal(n);

    clearSelection();

    // Emit signal for UI updates
    emit sceneChanged();

    qDebug() << "DELETE COMPLETE: Deleted" << edges.size() << "edges and" << nodes.size() << "nodes - Observers notified";
}

void Scene::clearGraphInternal()
{
    qDebug() << "SIMPLE_FIX: Clearing graph - removing" << m_nodes.size() << "nodes and" << m_edges.size() << "edges";
    
    // SIMPLE FIX: Clear registries FIRST to prevent dangling pointers
    // This prevents hash lookups during Qt's destruction sequence
    qDebug() << "SIMPLE_FIX: Clearing hash registries first";
    m_nodes.clear();
    m_edges.clear();
    m_sockets.clear();  // Clear deprecated socket registry too
    
    // Then clear Qt graphics scene (safe now - no hash references)
    qDebug() << "SIMPLE_FIX: Clearing Qt scene items";
    QGraphicsScene::clear();
    
    // Notify observers of graph clearing
    notifyGraphCleared();
    
    // Emit signal for UI updates
    emit sceneChanged();
    
    qDebug() << "SIMPLE_FIX: ✓ Graph cleared safely - hash cleared before Qt cleanup";
}

// ============================================================================
// PHASE 1.2: Safe Shutdown Preparation
// ============================================================================

void Scene::prepareForShutdown()
{
    if (m_shutdownInProgress) {
        qDebug() << "SHUTDOWN: Already in progress, skipping";
        return;
    }
    
    qDebug() << "PHASE1: Shutdown preparation -" << m_edges.size() << "edges," << m_nodes.size() << "nodes";
    m_shutdownInProgress = true;
    
    // Step 1: Clean edge-socket connections BEFORE any destruction
    for (Edge* edge : m_edges.values()) {
        // Note: Socket connection cleanup disabled - methods not available in current implementation
    }
    
    qDebug() << "PHASE1: ✓ Socket connections cleared safely";
}

// ============================================================================
// Ghost Edge Implementation for Right-Click Socket Connections
// ============================================================================

// IUnknown UUID for ghost edge identification
static const QUuid GHOST_EDGE_UUID = QUuid("{00000000-0000-0000-C000-000000000046}");

void Scene::startGhostEdge(Socket* fromSocket, const QPointF& startPos)
{
    if (m_ghostEdge) {
        removeItem(m_ghostEdge);
        delete m_ghostEdge;
    }
    
    m_ghostFromSocket = fromSocket;
    
    m_ghostEdge = new GhostEdge();
    m_ghostEdge->setData(0, GHOST_EDGE_UUID); // IUnknown UUID marker
    
    addItem(m_ghostEdge);
    m_ghostEdgeActive = true;
    
    // Set source socket to connecting state
    fromSocket->setConnectionState(Socket::Connecting);
    
    updateGhostEdge(startPos);
    
    qDebug() << "GHOST: Started from socket" << fromSocket->getIndex() 
             << "(" << (fromSocket->getRole() == Socket::Input ? "Input" : "Output") << ")";
}

void Scene::updateGhostEdge(const QPointF& currentPos)
{
    if (!m_ghostEdge || !m_ghostFromSocket) return;
    
    QPointF start = m_ghostFromSocket->scenePos();
    QPainterPath path;
    path.moveTo(start);
    
    // Create curved ghost edge similar to real edges
    qreal dx = currentPos.x() - start.x();
    qreal controlOffset = qMin(qAbs(dx) * 0.5, 100.0);
    
    QPointF control1 = start + QPointF(controlOffset, 0);
    QPointF control2 = currentPos - QPointF(controlOffset, 0);
    path.cubicTo(control1, control2, currentPos);
    
    // Update ghost edge visual based on target validity
    QPen ghostPenCurrent = ghostPen();
    QGraphicsItem* itemUnderCursor = itemAt(currentPos, QTransform());

    // Cast-free: Check metadata instead of qgraphicsitem_cast
    Socket* targetSocket = nullptr;
    if (itemUnderCursor && itemUnderCursor->data(Gik::KindKey).toInt() == Gik::Kind_Socket) {
        targetSocket = static_cast<Socket*>(itemUnderCursor);
    }
    
    // Reset all socket visual states to normal first
    resetAllSocketStates();
    
    if (targetSocket) {
        // Check if this is a valid connection target
        bool isValidTarget = (targetSocket->getRole() == Socket::Input && 
                            targetSocket != m_ghostFromSocket &&
                            targetSocket->getParentNode() != m_ghostFromSocket->getParentNode());
        
        if (isValidTarget) {
            targetSocket->setConnectionState(Socket::Highlighted);
            ghostPenCurrent.setColor(QColor(0, 255, 0, 180)); // Green ghost edge
        } else {
            ghostPenCurrent.setColor(QColor(255, 0, 0, 180)); // Red ghost edge
        }
    } else {
        // No socket under cursor - default ghost edge color
        ghostPenCurrent.setColor(QColor(0, 255, 0, 150)); // Default green
    }
    
    m_ghostEdge->setPath(path);
}

void Scene::resetAllSocketStates()
{
    // Reset all sockets to normal state when not being targeted
    for (Node* node : m_nodes.values()) {
        for (QGraphicsItem* child : node->childItems()) {
            if (Socket* socket = qgraphicsitem_cast<Socket*>(child)) {
                if (socket != m_ghostFromSocket) {
                    socket->updateConnectionState(); // Reset to connected/disconnected
                }
            }
        }
    }
}

void Scene::finishGhostEdge(Socket* toSocket)
{
    if (m_ghostFromSocket && toSocket) {
        // Validate connection roles
        if (m_ghostFromSocket->getRole() == Socket::Output && 
            toSocket->getRole() == Socket::Input) {
            
            // Create real edge using existing system
            Edge* newEdge = new Edge(QUuid::createUuid(), QUuid(), QUuid());
            
            Node* fromNode = m_ghostFromSocket->getParentNode();
            Node* toNode = toSocket->getParentNode();
            
            if (fromNode && toNode) {
                newEdge->setConnectionData(
                    fromNode->getId().toString(QUuid::WithoutBraces),
                    toNode->getId().toString(QUuid::WithoutBraces),
                    m_ghostFromSocket->getIndex(),
                    toSocket->getIndex()
                );
                
                addEdge(newEdge);
                newEdge->resolveConnections(this);
                
                // Brief success feedback - flash the connected sockets green (disabled)
                // m_ghostFromSocket->setVisualState(Socket::ValidTarget);
                // toSocket->setVisualState(Socket::ValidTarget);
                // QTimer::singleShot(300, [this, toSocket]() {
                //     // Reset to normal appearance after brief success flash
                //     if (m_ghostFromSocket) m_ghostFromSocket->setVisualState(Socket::Normal);
                //     toSocket->setVisualState(Socket::Normal);
                // });
                
                qDebug() << "GHOST: ✓ Created edge" << m_ghostFromSocket->getIndex() << "→" << toSocket->getIndex();
            }
        } else {
            qDebug() << "GHOST: ✗ Invalid connection - wrong socket roles";
        }
    }
    
    // Reset all socket states before canceling
    resetAllSocketStates();
    cancelGhostEdge();
}

void Scene::cancelGhostEdge()
{
    // Reset all socket visual states
    resetAllSocketStates();
    
    if (m_ghostEdge) {
        removeItem(m_ghostEdge);
        delete m_ghostEdge;
        m_ghostEdge = nullptr;
    }
    m_ghostFromSocket = nullptr;
    m_ghostEdgeActive = false;
    
    qDebug() << "GHOST: Cancelled";
}

Socket* Scene::findNearestValidSocket(const QPointF& scenePos, Socket* fromSocket, QPointF& snappedPos)
{
    if (!fromSocket) {
        snappedPos = scenePos;
        return nullptr;
    }

    Socket* nearestSocket = nullptr;
    qreal minDistance = getMagneticRadius();
    snappedPos = scenePos;

    // Check all sockets in the scene for magnetic attraction (cast-free with metadata)
    for (Node* node : m_nodes.values()) {
        for (QGraphicsItem* child : node->childItems()) {
            // Cast-free socket identification using metadata key
            if (child->data(Gik::KindKey).toInt() != Gik::Kind_Socket) {
                continue;
            }

            Socket* socket = static_cast<Socket*>(child);

            // Skip if not a valid target
            if (socket->getRole() != Socket::Input ||
                socket == fromSocket ||
                socket->getParentNode() == fromSocket->getParentNode() ||
                socket->isConnected() ||
                fromSocket->isConnected()) {
                continue;
            }

            // Calculate distance to socket center
            QPointF socketPos = socket->scenePos();
            qreal distance = QLineF(scenePos, socketPos).length();

            // If within magnetic radius and closer than previous best
            if (distance < minDistance) {
                minDistance = distance;
                nearestSocket = socket;
                snappedPos = socketPos; // Snap to socket center
            }
        }
    }

    return nearestSocket;
}

QPointF Scene::snapPoint(const QPointF& scenePos) const
{
    int grid = gridSize();
    if (grid <= 1) {
        return scenePos;
    }

    qreal x = qRound(scenePos.x() / grid) * grid;
    qreal y = qRound(scenePos.y() / grid) * grid;
    return QPointF(x, y);
}

QPen Scene::ghostPen() const
{
    QPen pen(QColor(0, 255, 0, 150)); // Semi-transparent green
    pen.setWidth(3);
    pen.setStyle(Qt::DashLine);
    pen.setDashPattern({8, 4});
    pen.setCapStyle(Qt::RoundCap);
    pen.setJoinStyle(Qt::RoundJoin);
    return pen;
}

void Scene::mouseMoveEvent(QGraphicsSceneMouseEvent* event)
{
    if (m_ghostEdgeActive) {
        updateGhostEdge(event->scenePos());
        event->accept();
        return;
    }
    QGraphicsScene::mouseMoveEvent(event);
}

void Scene::mouseReleaseEvent(QGraphicsSceneMouseEvent* event)
{
    if (m_ghostEdgeActive && event->button() == Qt::RightButton) {
        // Find socket under mouse (cast-free with metadata)
        QGraphicsItem* item = itemAt(event->scenePos(), QTransform());
        Socket* targetSocket = nullptr;
        if (item && item->data(Gik::KindKey).toInt() == Gik::Kind_Socket) {
            targetSocket = static_cast<Socket*>(item);
        }
        finishGhostEdge(targetSocket);
        event->accept();
        return;
    }
    QGraphicsScene::mouseReleaseEvent(event);
}




/// ===== FILE: node_palette_widget.h =====
#pragma once

#include <QWidget>
#include <QScrollArea>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGridLayout>
#include <QLineEdit>
#include <QLabel>
#include <QPushButton>
#include <QToolButton>
#include <QFrame>

/**
 * PaletteButton - Consistent button for palette operations
 * 
 * Features:
 * - Uniform 24x24 icon size
 * - Consistent styling and hover states
 * - Tooltip support
 * - Icon resource alias support
 */
class PaletteButton : public QToolButton {
    Q_OBJECT
public:
    explicit PaletteButton(const QString& iconAlias, 
                          const QString& tooltip, 
                          QWidget* parent = nullptr);
    
    // Set checkable state for toggle tools
    void setCheckable(bool checkable);
    
    // Apply consistent styling
    void applyDefaultStyle();
};

/**
 * NodePaletteWidget - Icon-based node palette with grid layout
 * 
 * Features:
 * - Search filtering
 * - Double-click node creation
 * - Icon-based grid layout
 * - Professional visual node type recognition
 * - Integration with self-serializing nodes
 */
class NodePaletteWidget : public QWidget
{
    Q_OBJECT

public:
    explicit NodePaletteWidget(QWidget* parent = nullptr);
    
    // Node template structure
    struct NodeTemplate {
        QString type;       // Node type (IN, OUT, PROCESSOR)
        QString name;       // Display name
        QString description; // Tooltip description
        QString iconPath;   // Icon file path
        int inputSockets;   // Number of input sockets
        int outputSockets;  // Number of output sockets
        
        // Default constructor for QVariant
        NodeTemplate() : inputSockets(0), outputSockets(0) {}
        
        // Copy constructor
        NodeTemplate(const NodeTemplate& other) = default;
        NodeTemplate& operator=(const NodeTemplate& other) = default;
    };

signals:
    // Emitted when user wants to create a node
    void nodeCreationRequested(const NodeTemplate& nodeTemplate);

private slots:
    void filterChanged(const QString& text);
    void onNodeButtonClicked();

private:
    void setupUI();
    void populateNodeTemplates();
    void addNodeTemplate(const NodeTemplate& nodeTemplate);
    void updateVisibility();
    
    // Custom node button class with drag and drop support
    class NodeButton : public QToolButton {
    public:
        NodeButton(const NodeTemplate& nodeTemplate, QWidget* parent = nullptr);
        NodeTemplate getNodeTemplate() const { return m_nodeTemplate; }
        bool matchesFilter(const QString& filter) const;
        
    protected:
        // Drag and drop support
        void mousePressEvent(QMouseEvent* event) override;
        void mouseMoveEvent(QMouseEvent* event) override;
        
    private:
        NodeTemplate m_nodeTemplate;
        QPoint m_dragStartPosition;
        static QIcon createNodeIcon(const NodeTemplate& nodeTemplate);
    };
    
    // UI components
    QVBoxLayout* m_mainLayout;
    QLineEdit* m_searchEdit;
    QScrollArea* m_scrollArea;
    QWidget* m_scrollContent;
    QGridLayout* m_gridLayout;
    QLabel* m_titleLabel;
    
    // Node templates and buttons
    QList<NodeTemplate> m_nodeTemplates;
    QList<NodeButton*> m_nodeButtons;
    QString m_currentFilter;
};

// Declare NodeTemplate as a Qt metatype for QVariant storage
Q_DECLARE_METATYPE(NodePaletteWidget::NodeTemplate)


/// ===== FILE: node_palette_widget.cpp =====
#include "node_palette_widget.h"
#include <QFont>
#include <QIcon>
#include <QDebug>
#include <QScrollArea>
#include <QGridLayout>
#include <QPainter>
#include <QMouseEvent>
#include <QToolButton>
#include <QSize>
#include <QDrag>
#include <QMimeData>
#include <QApplication>

// ============================================================================
// PaletteButton Implementation
// ============================================================================

PaletteButton::PaletteButton(const QString& iconAlias, 
                            const QString& tooltip, 
                            QWidget* parent)
    : QToolButton(parent)
{
    // Load icon from resource using alias
    QIcon icon(QStringLiteral(":/icons/%1").arg(iconAlias));
    setIcon(icon);
    setIconSize(QSize(24, 24));
    setToolTip(tooltip);
    
    // Apply consistent styling
    applyDefaultStyle();
}

void PaletteButton::setCheckable(bool checkable)
{
    QToolButton::setCheckable(checkable);
    if (checkable) {
        // Add checked state styling
        setStyleSheet(styleSheet() + 
                     "QToolButton:checked { "
                     "  background: #007acc; "
                     "  color: white; "
                     "}");
    }
}

void PaletteButton::applyDefaultStyle()
{
    setAutoRaise(true);
    setCursor(Qt::PointingHandCursor);
    setFixedSize(32, 32);
    
    // Apply CSS styling for hover states
    setStyleSheet(
        "QToolButton {"
        "  border: none;"
        "  border-radius: 4px;"
        "  padding: 4px;"
        "  background: transparent;"
        "}"
        "QToolButton:hover {"
        "  background: rgba(0, 0, 0, 0.08);"
        "}"
        "QToolButton:pressed {"
        "  background: rgba(0, 0, 0, 0.16);"
        "}"
    );
}

// ============================================================================
// NodePaletteWidget Implementation
// ============================================================================

NodePaletteWidget::NodePaletteWidget(QWidget* parent)
    : QWidget(parent)
    , m_mainLayout(nullptr)
    , m_searchEdit(nullptr)
    , m_scrollArea(nullptr)
    , m_scrollContent(nullptr)
    , m_gridLayout(nullptr)
    , m_titleLabel(nullptr)
{
    setupUI();
    populateNodeTemplates();
}

void NodePaletteWidget::setupUI()
{
    m_mainLayout = new QVBoxLayout(this);
    m_mainLayout->setContentsMargins(8, 8, 8, 8);
    m_mainLayout->setSpacing(6);
    
    // Title
    m_titleLabel = new QLabel("Node Palette", this);
    QFont titleFont = m_titleLabel->font();
    titleFont.setBold(true);
    titleFont.setPointSize(titleFont.pointSize() + 1);
    m_titleLabel->setFont(titleFont);
    m_titleLabel->setStyleSheet("QLabel { color: #2c3e50; margin-bottom: 4px; }");
    
    // Search box
    m_searchEdit = new QLineEdit(this);
    m_searchEdit->setPlaceholderText("Search nodes...");
    m_searchEdit->setStyleSheet(
        "QLineEdit {"
        "  border: 1px solid #bdc3c7;"
        "  border-radius: 4px;"
        "  padding: 6px 10px;"
        "  background: white;"
        "  font-size: 12px;"
        "}"
        "QLineEdit:focus {"
        "  border-color: #3498db;"
        "  outline: none;"
        "}"
    );
    
    // Scroll area for node grid
    m_scrollArea = new QScrollArea(this);
    m_scrollArea->setWidgetResizable(true);
    m_scrollArea->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_scrollArea->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
    m_scrollArea->setFrameShape(QFrame::NoFrame);
    
    // Content widget for the grid
    m_scrollContent = new QWidget();
    m_gridLayout = new QGridLayout(m_scrollContent);
    m_gridLayout->setContentsMargins(8, 8, 8, 8);
    m_gridLayout->setSpacing(10); // Increased spacing between buttons
    m_gridLayout->setAlignment(Qt::AlignTop | Qt::AlignHCenter); // Center buttons and align to top
    
    m_scrollArea->setWidget(m_scrollContent);
    
    // Layout
    m_mainLayout->addWidget(m_titleLabel);
    m_mainLayout->addWidget(m_searchEdit);
    m_mainLayout->addWidget(m_scrollArea, 1);
    
    // Connections
    connect(m_searchEdit, &QLineEdit::textChanged, this, &NodePaletteWidget::filterChanged);
}

void NodePaletteWidget::populateNodeTemplates()
{
    qDebug() << "NodePalette: Starting population of 5 node templates";
    
    // 1. One Source (0 inputs, 1 output)
    NodeTemplate sourceNode;
    sourceNode.type = "SOURCE";
    sourceNode.name = "Source";
    sourceNode.description = "Source node with one output";
    sourceNode.iconPath = "";
    sourceNode.inputSockets = 0;
    sourceNode.outputSockets = 1;
    qDebug() << "NodePalette: Adding SOURCE node template - inputs:" << sourceNode.inputSockets << "outputs:" << sourceNode.outputSockets;
    addNodeTemplate(sourceNode);
    
    // 2. One Sink (1 input, 0 outputs)
    NodeTemplate sinkNode;
    sinkNode.type = "SINK";
    sinkNode.name = "Sink";
    sinkNode.description = "Sink node with one input";
    sinkNode.iconPath = "";
    sinkNode.inputSockets = 1;
    sinkNode.outputSockets = 0;
    qDebug() << "NodePalette: Adding SINK node template - inputs:" << sinkNode.inputSockets << "outputs:" << sinkNode.outputSockets;
    addNodeTemplate(sinkNode);
    
    // 3. One Sink + One Source (1 input, 1 output)
    NodeTemplate transformNode;
    transformNode.type = "TRANSFORM";
    transformNode.name = "Transform";
    transformNode.description = "Transform node with one input and one output";
    transformNode.iconPath = "";
    transformNode.inputSockets = 1;
    transformNode.outputSockets = 1;
    qDebug() << "NodePalette: Adding TRANSFORM node template - inputs:" << transformNode.inputSockets << "outputs:" << transformNode.outputSockets;
    addNodeTemplate(transformNode);
    
    // 4. Two Sinks + One Source (2 inputs, 1 output)
    NodeTemplate mergeNode;
    mergeNode.type = "MERGE";
    mergeNode.name = "Merge";
    mergeNode.description = "Merge node with two inputs and one output";
    mergeNode.iconPath = "";
    mergeNode.inputSockets = 2;
    mergeNode.outputSockets = 1;
    qDebug() << "NodePalette: Adding MERGE node template - inputs:" << mergeNode.inputSockets << "outputs:" << mergeNode.outputSockets;
    addNodeTemplate(mergeNode);
    
    // 5. One Sink + Two Sources (1 input, 2 outputs)
    NodeTemplate splitNode;
    splitNode.type = "SPLIT";
    splitNode.name = "Split";
    splitNode.description = "Split node with one input and two outputs";
    splitNode.iconPath = "";
    splitNode.inputSockets = 1;
    splitNode.outputSockets = 2;
    qDebug() << "NodePalette: Adding SPLIT node template - inputs:" << splitNode.inputSockets << "outputs:" << splitNode.outputSockets;
    addNodeTemplate(splitNode);
    
    qDebug() << "✓ NodePalette: Populated with" << m_nodeTemplates.size() << "socket configuration templates";
}

void NodePaletteWidget::addNodeTemplate(const NodeTemplate& nodeTemplate)
{
    qDebug() << "NodePalette: Adding template to internal list -" << nodeTemplate.name << "(" << nodeTemplate.type << ")";
    m_nodeTemplates.append(nodeTemplate);
    
    // Create icon button for this node type
    qDebug() << "NodePalette: Creating NodeButton for" << nodeTemplate.name;
    NodeButton* button = new NodeButton(nodeTemplate, m_scrollContent);
    m_nodeButtons.append(button);
    
    // Connect button to our slot
    qDebug() << "NodePalette: Connecting button signals for" << nodeTemplate.name;
    connect(button, &QToolButton::clicked, this, &NodePaletteWidget::onNodeButtonClicked);
    
    // Add to grid layout (2 columns) - proper grid arrangement
    int buttonIndex = m_nodeButtons.size() - 1; // Current button index (0-based)
    int row = buttonIndex / 2; // Integer division for row
    int col = buttonIndex % 2; // Remainder for column (0 or 1)
    qDebug() << "NodePalette: Adding button" << (buttonIndex + 1) << "to grid layout at row" << row << "col" << col;
    m_gridLayout->addWidget(button, row, col);
    qDebug() << "✓ NodePalette: Successfully added" << nodeTemplate.name << "button to palette";
}

void NodePaletteWidget::filterChanged(const QString& text)
{
    m_currentFilter = text;
    updateVisibility();
}

void NodePaletteWidget::onNodeButtonClicked()
{
    NodeButton* button = static_cast<NodeButton*>(sender());
    if (!button) return;
    
    NodeTemplate nodeTemplate = button->getNodeTemplate();
    qDebug() << "Node palette: Creating node" << nodeTemplate.name << "via button click";
    emit nodeCreationRequested(nodeTemplate);
}

void NodePaletteWidget::updateVisibility()
{
    for (NodeButton* button : m_nodeButtons) {
        bool visible = m_currentFilter.isEmpty() || button->matchesFilter(m_currentFilter);
        button->setVisible(visible);
    }
}

// ============================================================================
// NodeButton Implementation
// ============================================================================

NodePaletteWidget::NodeButton::NodeButton(const NodeTemplate& nodeTemplate, QWidget* parent)
    : QToolButton(parent)
    , m_nodeTemplate(nodeTemplate)
{
    qDebug() << "NodeButton: Creating button for" << nodeTemplate.name << "type:" << nodeTemplate.type;
    qDebug() << "NodeButton: Socket configuration - inputs:" << nodeTemplate.inputSockets << "outputs:" << nodeTemplate.outputSockets;
    
    setFixedSize(80, 80);
    setToolTip(QString("%1\n%2\nInputs: %3, Outputs: %4\n\nDrag to create or double-click")
               .arg(nodeTemplate.name)
               .arg(nodeTemplate.description)
               .arg(nodeTemplate.inputSockets)
               .arg(nodeTemplate.outputSockets));
    
    // Create custom icon based on node type
    qDebug() << "NodeButton: Creating custom icon for" << nodeTemplate.name;
    QIcon icon = NodeButton::createNodeIcon(nodeTemplate);
    setIcon(icon);
    setIconSize(QSize(48, 48));
    
    // Set text below icon
    setText(nodeTemplate.name);
    setToolButtonStyle(Qt::ToolButtonTextUnderIcon); // Position text under the icon
    
    // Apply object name for external styling
    setObjectName("nodeButton");
    
    // Enable drag support
    setAcceptDrops(false); // This is a drag source, not a drop target
    qDebug() << "✓ NodeButton: Button created successfully for" << nodeTemplate.name;
}

bool NodePaletteWidget::NodeButton::matchesFilter(const QString& filter) const
{
    return m_nodeTemplate.name.contains(filter, Qt::CaseInsensitive) ||
           m_nodeTemplate.description.contains(filter, Qt::CaseInsensitive) ||
           m_nodeTemplate.type.contains(filter, Qt::CaseInsensitive);
}

QIcon NodePaletteWidget::NodeButton::createNodeIcon(const NodeTemplate& nodeTemplate)
{
    // Create a custom icon representing the node function
    QPixmap pixmap(48, 48);
    pixmap.fill(Qt::transparent);
    
    QPainter painter(&pixmap);
    painter.setRenderHint(QPainter::Antialiasing);
    
    // Define colors and symbols based on node type
    QColor nodeColor;
    QString symbol;
    
    if (nodeTemplate.type == "SOURCE") {
        nodeColor = QColor(46, 204, 113); // Green for source
        symbol = "SRC";
    } else if (nodeTemplate.type == "SINK") {
        nodeColor = QColor(231, 76, 60); // Red for sink
        symbol = "SNK";
    } else if (nodeTemplate.type == "TRANSFORM") {
        nodeColor = QColor(52, 152, 219); // Blue for transform
        symbol = "TRN";
    } else if (nodeTemplate.type == "MERGE") {
        nodeColor = QColor(155, 89, 182); // Purple for merge
        symbol = "MRG";
    } else if (nodeTemplate.type == "SPLIT") {
        nodeColor = QColor(243, 156, 18); // Orange for split
        symbol = "SPL";
    } else {
        nodeColor = QColor(149, 165, 166); // Gray for unknown
        symbol = "?";
    }
    
    // Draw main node body
    painter.setBrush(QBrush(nodeColor));
    painter.setPen(QPen(nodeColor.darker(120), 2));
    painter.drawRoundedRect(6, 6, 36, 36, 4, 4);
    
    // Draw function symbol
    painter.setPen(Qt::white);
    painter.setFont(QFont("Arial", 7, QFont::Bold));
    painter.drawText(QRect(6, 6, 36, 20), Qt::AlignCenter, symbol);
    
    // Draw socket representations with proper alignment
    painter.setBrush(QBrush(Qt::white));
    painter.setPen(QPen(Qt::darkGray, 1.5));
    
    // Constants for consistent positioning
    const qreal nodeTop = 6;
    const qreal nodeHeight = 36;
    const qreal socketSize = 4;
    const qreal socketSpacing = 8; // Consistent spacing between sockets
    
    // Input sockets (left side) - properly centered vertically
    if (nodeTemplate.inputSockets > 0) {
        qreal totalHeight = (nodeTemplate.inputSockets - 1) * socketSpacing;
        qreal startY = nodeTop + (nodeHeight - totalHeight) / 2;
        
        for (int i = 0; i < nodeTemplate.inputSockets; ++i) {
            qreal y = startY + (i * socketSpacing) - socketSize/2;
            painter.drawEllipse(QRectF(1, y, socketSize, socketSize));
        }
    }
    
    // Output sockets (right side) - properly centered vertically  
    if (nodeTemplate.outputSockets > 0) {
        qreal totalHeight = (nodeTemplate.outputSockets - 1) * socketSpacing;
        qreal startY = nodeTop + (nodeHeight - totalHeight) / 2;
        
        for (int i = 0; i < nodeTemplate.outputSockets; ++i) {
            qreal y = startY + (i * socketSpacing) - socketSize/2;
            painter.drawEllipse(QRectF(43, y, socketSize, socketSize));
        }
    }
    
    // Add visual flow indicators for function type - aligned with node center
    const qreal centerY = nodeTop + nodeHeight / 2;
    painter.setPen(QPen(Qt::white, 1.5, Qt::SolidLine));
    
    if (nodeTemplate.type == "TRANSFORM") {
        // Horizontal arrow through center
        painter.drawLine(8, centerY, 40, centerY);
        // Arrow head
        painter.drawLine(36, centerY - 3, 40, centerY);
        painter.drawLine(36, centerY + 3, 40, centerY);
    } else if (nodeTemplate.type == "MERGE") {
        // Converging lines to center
        painter.drawLine(8, centerY - 6, 24, centerY);
        painter.drawLine(8, centerY + 6, 24, centerY);
        painter.drawLine(24, centerY, 40, centerY);
        // Arrow head
        painter.drawLine(36, centerY - 2, 40, centerY);
        painter.drawLine(36, centerY + 2, 40, centerY);
    } else if (nodeTemplate.type == "SPLIT") {
        // Diverging lines from center
        painter.drawLine(8, centerY, 24, centerY);
        painter.drawLine(24, centerY, 40, centerY - 6);
        painter.drawLine(24, centerY, 40, centerY + 6);
        // Arrow heads
        painter.drawLine(36, centerY - 8, 40, centerY - 6);
        painter.drawLine(36, centerY - 4, 40, centerY - 6);
        painter.drawLine(36, centerY + 4, 40, centerY + 6);
        painter.drawLine(36, centerY + 8, 40, centerY + 6);
    }
    
    return QIcon(pixmap);
}

void NodePaletteWidget::NodeButton::mousePressEvent(QMouseEvent* event)
{
    if (event->button() == Qt::LeftButton) {
        qDebug() << "NodeButton: Mouse press detected on" << m_nodeTemplate.name << "at position:" << event->pos();
        m_dragStartPosition = event->pos();
    }
    QToolButton::mousePressEvent(event);
}

void NodePaletteWidget::NodeButton::mouseMoveEvent(QMouseEvent* event)
{
    if (!(event->buttons() & Qt::LeftButton)) {
        QToolButton::mouseMoveEvent(event);
        return;
    }
    
    qreal distance = (event->pos() - m_dragStartPosition).manhattanLength();
    if (distance < QApplication::startDragDistance()) {
        qDebug() << "NodeButton: Mouse moved but distance" << distance << "< drag threshold" << QApplication::startDragDistance();
        QToolButton::mouseMoveEvent(event);
        return;
    }
    
    qDebug() << "NodeButton: Starting drag operation for" << m_nodeTemplate.name;
    qDebug() << "NodeButton: Template data - type:" << m_nodeTemplate.type << "inputs:" << m_nodeTemplate.inputSockets << "outputs:" << m_nodeTemplate.outputSockets;
    
    // Start drag operation
    QDrag* drag = new QDrag(this);
    QMimeData* mimeData = new QMimeData;
    
    // Store node template data in mime data
    QString mimeString = QString("%1|%2|%3|%4|%5")
                        .arg(m_nodeTemplate.type)
                        .arg(m_nodeTemplate.name)
                        .arg(m_nodeTemplate.description)
                        .arg(m_nodeTemplate.inputSockets)
                        .arg(m_nodeTemplate.outputSockets);
    
    qDebug() << "NodeButton: Encoding mime data:" << mimeString;
    mimeData->setData("application/x-node-template", mimeString.toUtf8());
    
    // Create drag pixmap from the button's icon
    QPixmap dragPixmap = icon().pixmap(48, 48);
    if (dragPixmap.isNull()) {
        qDebug() << "NodeButton: Warning - icon pixmap is null, creating fallback";
        dragPixmap = QPixmap(48, 48);
        dragPixmap.fill(Qt::gray);
    }
    
    // Make it semi-transparent for visual feedback
    QPixmap transparentPixmap(dragPixmap.size());
    transparentPixmap.fill(Qt::transparent);
    QPainter painter(&transparentPixmap);
    painter.setOpacity(0.7);
    painter.drawPixmap(0, 0, dragPixmap);
    painter.end();
    
    drag->setMimeData(mimeData);
    drag->setPixmap(transparentPixmap);
    drag->setHotSpot(QPoint(24, 24)); // Center of the icon
    
    qDebug() << "NodeButton: Executing drag operation for" << m_nodeTemplate.name;
    
    // Execute the drag
    Qt::DropAction dropAction = drag->exec(Qt::CopyAction);
    
    if (dropAction == Qt::CopyAction) {
        qDebug() << "✓ NodeButton: Drag completed successfully for" << m_nodeTemplate.name;
    } else {
        qDebug() << "✗ NodeButton: Drag was cancelled or failed for" << m_nodeTemplate.name;
    }
}




/// ===== FILE: javascript_engine.h =====
#pragma once

#include <QJSEngine>
#include <QJSValue>
#include <QObject>
#include <QString>
#include <QVariant>
#include <QDebug>

class Node;
class Edge;
class Scene;
class GraphFactory;
class QGraph;

/**
 * JavaScriptEngine - Modern JavaScript integration for NodeGraph
 * 
 * Provides QJSEngine integration for:
 * - Node scripting and behavior logic
 * - Graph processing algorithms
 * - Custom node types in JavaScript
 * - Real-time graph operations
 */
class JavaScriptEngine : public QObject
{
    Q_OBJECT

public:
    explicit JavaScriptEngine(QObject* parent = nullptr);
    ~JavaScriptEngine();

    // JavaScript execution
    QJSValue evaluate(const QString& script);
    QJSValue evaluateFile(const QString& filePath);
    
    // API registration
    void registerNodeAPI(Scene* scene);
    void registerGraphAPI();
    void registerQGraph(QGraph* graph);  // Register QGraph with state tracking
    
    // Node scripting support
    QJSValue createNodeScript(const QString& nodeType, const QString& script);
    bool executeNodeScript(Node* node, const QString& script, const QVariantMap& inputs = QVariantMap());
    
    // Graph processing
    QJSValue processGraph(const QString& algorithm, const QVariantMap& parameters = QVariantMap());
    
    // Utility methods
    bool hasErrors() const;
    QString getLastError() const;
    void clearErrors();
    
    // Engine information
    QString getEngineInfo() const;
    void logEngineCapabilities() const;
    
    // Script management
    void loadScriptModule(const QString& moduleName, const QString& scriptContent);
    QJSValue getModule(const QString& moduleName);

signals:
    void scriptExecuted(const QString& script, const QJSValue& result);
    void scriptError(const QString& error);
    void nodeScriptChanged(const QString& nodeId, const QString& script);

public slots:
    // Console API callbacks
    void qt_console_log(const QString& message);
    void qt_console_error(const QString& message);

private slots:
    void handleJavaScriptException(const QJSValue& exception);

private:
    void setupGlobalAPI();
    void registerConsoleAPI();
    void registerUtilityAPI();
    void loadEnhancedAPIs();
    
    QJSValue nodeToJSValue(Node* node);
    QJSValue edgeToJSValue(Edge* edge);
    
    QJSEngine* m_engine;
    Scene* m_scene;
    QGraph* m_qgraph;  // QGraph instance with state tracking
    QString m_lastError;
    QMap<QString, QJSValue> m_scriptModules;
};


/// ===== FILE: javascript_engine.cpp =====
#include "javascript_engine.h"
#include "node.h"
#include "edge.h"
#include "scene.h"
#include "graph_factory.h"
#include "qgraph.h"
#include <QFile>
#include <QTextStream>
#include <QJsonDocument>
#include <QJsonObject>

JavaScriptEngine::JavaScriptEngine(QObject* parent)
    : QObject(parent)
    , m_engine(new QJSEngine(this))
    , m_scene(nullptr)
    , m_qgraph(nullptr)
{
    setupGlobalAPI();
    registerConsoleAPI();
    registerUtilityAPI();

    // Auto-load enhanced APIs disabled for now - will load scripts manually
    // loadEnhancedAPIs();

    qDebug() << "JavaScriptEngine: Simple JavaScript engine initialized";
}

JavaScriptEngine::~JavaScriptEngine()
{
    qDebug() << "JavaScriptEngine: Shutting down";
}

QJSValue JavaScriptEngine::evaluate(const QString& script)
{
    clearErrors();
    
    qDebug() << "JS_EXECUTION: Starting script execution";
    qDebug() << "JS_EXECUTION: Script length:" << script.length() << "characters";
    
    QJSValue result = m_engine->evaluate(script);
    
    if (result.isError()) {
        m_lastError = QString("JavaScript Error: %1").arg(result.toString());
        emit scriptError(m_lastError);
        qDebug() << "JS_ERROR: Script execution failed:" << m_lastError;
        qDebug() << "JS_ERROR: Script content:" << script.left(500); // Log first 500 chars
    } else {
        emit scriptExecuted(script, result);
        QString resultStr = result.isUndefined() ? "undefined" : result.toString();
        qDebug() << "JS_EXECUTION: Script completed successfully";
        qDebug() << "JS_EXECUTION: Result:" << resultStr;
    }
    
    return result;
}

QJSValue JavaScriptEngine::evaluateFile(const QString& filePath)
{
    qDebug() << "JS_EXECUTION: Loading script file:" << filePath;
    
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        m_lastError = QString("Cannot open script file: %1").arg(filePath);
        emit scriptError(m_lastError);
        qDebug() << "JS_ERROR: Failed to open script file:" << filePath;
        return QJSValue();
    }
    
    QTextStream in(&file);
    QString script = in.readAll();
    
    qDebug() << "JS_EXECUTION: Loaded script file:" << filePath;
    qDebug() << "JS_EXECUTION: Script size:" << script.length() << "characters";
    
    return evaluate(script);
}

void JavaScriptEngine::registerNodeAPI(Scene* scene)
{
    m_scene = scene;
    
    // Register Node API
    QJSValue nodeAPI = m_engine->newObject();
    
    // Node creation functions - Qt5 compatible
    QJSValue createFunc = m_engine->evaluate(R"(
        (function(type, x, y) {
            if (arguments.length < 3) {
                throw new Error("Node.create() requires type, x, y parameters");
            }
            console.log("JavaScript: Creating node " + type + " at " + x + "," + y);
            return {}; // Placeholder
        })
    )");
    nodeAPI.setProperty("create", createFunc);
    
    // Node query functions - Qt5 compatible
    QJSValue findByIdFunc = m_engine->evaluate(R"(
        (function(id) {
            if (arguments.length < 1) {
                throw new Error("Node.findById() requires id parameter");
            }
            console.log("JavaScript: Finding node by ID: " + id);
            return null; // Placeholder
        })
    )");
    nodeAPI.setProperty("findById", findByIdFunc);
    
    // Enhanced node manipulation functions
    QJSValue moveNodeFunc = m_engine->evaluate(R"(
        (function(nodeId, x, y) {
            if (arguments.length < 3) {
                throw new Error("Node.move() requires nodeId, x, y parameters");
            }
            console.log("JavaScript: Moving node " + nodeId + " to " + x + "," + y);
            return true; // Placeholder
        })
    )");
    nodeAPI.setProperty("move", moveNodeFunc);
    
    QJSValue getPropertiesFunc = m_engine->evaluate(R"(
        (function(nodeId) {
            if (arguments.length < 1) {
                throw new Error("Node.getProperties() requires nodeId parameter");
            }
            console.log("JavaScript: Getting properties for node " + nodeId);
            return {}; // Placeholder
        })
    )");
    nodeAPI.setProperty("getProperties", getPropertiesFunc);
    
    m_engine->globalObject().setProperty("Node", nodeAPI);
    
    // Register Graph API
    QJSValue graphAPI = m_engine->newObject();
    
    // Graph API functions - Qt5 compatible
    QJSValue getNodesFunc = m_engine->evaluate(R"(
        (function() {
            console.log("JavaScript: Getting all nodes");
            return []; // Placeholder
        })
    )");
    graphAPI.setProperty("getNodes", getNodesFunc);
    
    QJSValue getEdgesFunc = m_engine->evaluate(R"(
        (function() {
            console.log("JavaScript: Getting all edges");
            return []; // Placeholder
        })
    )");
    graphAPI.setProperty("getEdges", getEdgesFunc);
    
    // Enhanced graph operations
    QJSValue clearGraphFunc = m_engine->evaluate(R"(
        (function() {
            console.log("JavaScript: Clearing graph");
            return true; // Placeholder
        })
    )");
    graphAPI.setProperty("clear", clearGraphFunc);
    
    QJSValue connectNodesFunc = m_engine->evaluate(R"(
        (function(fromNodeId, fromSocket, toNodeId, toSocket) {
            if (arguments.length < 4) {
                throw new Error("Graph.connect() requires fromNodeId, fromSocket, toNodeId, toSocket parameters");
            }
            console.log("JavaScript: Connecting " + fromNodeId + "[" + fromSocket + "] to " + toNodeId + "[" + toSocket + "]");
            return {}; // Placeholder edge ID
        })
    )");
    graphAPI.setProperty("connect", connectNodesFunc);
    
    QJSValue getStatsFunc = m_engine->evaluate(R"(
        (function() {
            console.log("JavaScript: Getting graph statistics");
            return {nodes: 0, edges: 0}; // Placeholder
        })
    )");
    graphAPI.setProperty("getStats", getStatsFunc);
    
    QJSValue graphMoveNodeFunc = m_engine->evaluate(R"(
        (function(nodeId, x, y) {
            if (arguments.length < 3) {
                throw new Error("Graph.moveNode() requires nodeId, x, y parameters");
            }
            console.log("JavaScript: Moving node " + nodeId + " to " + x + "," + y);
            return true; // Placeholder
        })
    )");
    graphAPI.setProperty("moveNode", graphMoveNodeFunc);
    
    QJSValue saveXmlFunc = m_engine->evaluate(R"(
        (function(filename) {
            if (arguments.length < 1) {
                throw new Error("Graph.saveXml() requires filename parameter");
            }
            console.log("JavaScript: Saving graph to " + filename);
            return true; // Placeholder
        })
    )");
    graphAPI.setProperty("saveXml", saveXmlFunc);
    
    QJSValue loadXmlFunc = m_engine->evaluate(R"(
        (function(filename) {
            if (arguments.length < 1) {
                throw new Error("Graph.loadXml() requires filename parameter");
            }
            console.log("JavaScript: Loading graph from " + filename);
            return true; // Placeholder
        })
    )");
    graphAPI.setProperty("loadXml", loadXmlFunc);
    
    m_engine->globalObject().setProperty("Graph", graphAPI);
    
    qDebug() << "JavaScriptEngine: Node and Graph APIs registered";
}

void JavaScriptEngine::registerGraphAPI()
{
    QJSValue algorithms = m_engine->newObject();
    
    // Layout algorithms - Qt5 compatible
    QJSValue forceDirectedFunc = m_engine->evaluate(R"(
        (function() {
            console.log("JavaScript: Running force-directed layout");
            return {}; // Placeholder
        })
    )");
    algorithms.setProperty("forceDirected", forceDirectedFunc);
    
    QJSValue hierarchicalFunc = m_engine->evaluate(R"(
        (function() {
            console.log("JavaScript: Running hierarchical layout");
            return {}; // Placeholder
        })
    )");
    algorithms.setProperty("hierarchical", hierarchicalFunc);
    
    m_engine->globalObject().setProperty("Algorithms", algorithms);
    
    qDebug() << "JavaScriptEngine: Graph algorithms registered";
}

void JavaScriptEngine::registerQGraph(QGraph* graph)
{
    if (!graph) {
        qWarning() << "JavaScriptEngine: Cannot register null QGraph";
        return;
    }

    m_qgraph = graph;

    // Register QGraph as global Graph object (replaces GraphController)
    QJSValue graphValue = m_engine->newQObject(m_qgraph);
    m_engine->globalObject().setProperty("Graph", graphValue);

    // Connect QGraph signals for JavaScript coordination
    connect(m_qgraph, &QGraph::nodeCreated, [](const QString& id) {
        qDebug() << "JavaScript: Node created:" << id.left(8);
    });

    connect(m_qgraph, &QGraph::nodeDeleted, [](const QString& id) {
        qDebug() << "JavaScript: Node deleted:" << id.left(8);
    });

    connect(m_qgraph, &QGraph::edgeConnected, [](const QString& id) {
        qDebug() << "JavaScript: Edge connected:" << id.left(8);
    });

    connect(m_qgraph, &QGraph::edgeDeleted, [](const QString& id) {
        qDebug() << "JavaScript: Edge deleted:" << id.left(8);
    });

    // New: XML load coordination signals
    connect(m_qgraph, &QGraph::xmlLoadStarted, [](const QString& path) {
        qDebug() << "JavaScript: XML load started:" << path;
    });

    connect(m_qgraph, &QGraph::xmlLoadComplete, [](const QString& path, bool success) {
        qDebug() << "JavaScript: XML load" << (success ? "succeeded" : "FAILED") << ":" << path;
    });

    connect(m_qgraph, &QGraph::graphStabilized, []() {
        qDebug() << "JavaScript: Graph stabilized - safe for operations";
    });

    connect(m_qgraph, &QGraph::error, [](const QString& message) {
        qDebug() << "JavaScript Graph Error:" << message;
    });

    qDebug() << "JavaScriptEngine: QGraph registered as 'Graph' global object with state tracking";
}

QJSValue JavaScriptEngine::createNodeScript(const QString& nodeType, const QString& script)
{
    QString wrappedScript = QString(R"(
        (function(nodeType, inputs, outputs) {
            %1
        })
    )").arg(script);
    
    QJSValue nodeFunction = evaluate(wrappedScript);
    
    if (!nodeFunction.isError()) {
        m_scriptModules[nodeType] = nodeFunction;
        qDebug() << "JavaScriptEngine: Created node script for type:" << nodeType;
    }
    
    return nodeFunction;
}

bool JavaScriptEngine::executeNodeScript(Node* node, const QString& script, const QVariantMap& inputs)
{
    if (!node) {
        m_lastError = "Cannot execute script on null node";
        return false;
    }
    
    // Convert inputs to JavaScript object
    QJSValue jsInputs = m_engine->newObject();
    for (auto it = inputs.begin(); it != inputs.end(); ++it) {
        jsInputs.setProperty(it.key(), m_engine->toScriptValue(it.value()));
    }
    
    // Set up node context
    QJSValue nodeObj = nodeToJSValue(node);
    m_engine->globalObject().setProperty("currentNode", nodeObj);
    m_engine->globalObject().setProperty("inputs", jsInputs);
    
    QJSValue result = evaluate(script);
    
    return !result.isError();
}

QJSValue JavaScriptEngine::processGraph(const QString& algorithm, const QVariantMap& parameters)
{
    QJSValue params = m_engine->newObject();
    for (auto it = parameters.begin(); it != parameters.end(); ++it) {
        params.setProperty(it.key(), m_engine->toScriptValue(it.value()));
    }
    
    QString script = QString("Algorithms.%1(arguments[0])").arg(algorithm);
    QJSValue algorithmFunc = evaluate(script);
    
    if (algorithmFunc.isCallable()) {
        return algorithmFunc.call(QJSValueList() << params);
    }
    
    return QJSValue();
}

bool JavaScriptEngine::hasErrors() const
{
    return !m_lastError.isEmpty();
}

QString JavaScriptEngine::getLastError() const
{
    return m_lastError;
}

void JavaScriptEngine::clearErrors()
{
    m_lastError.clear();
}

QString JavaScriptEngine::getEngineInfo() const
{
    QJSValue info = m_engine->evaluate(R"(
        JSON.stringify({
            engine: 'QJSEngine',
            qtVersion: ')" + QString(QT_VERSION_STR) + R"(',
            ecmaScript: 'ES5+',
            timestamp: new Date().toISOString(),
            features: {
                objects: typeof Object !== 'undefined',
                arrays: typeof Array !== 'undefined',
                functions: typeof Function !== 'undefined',
                json: typeof JSON !== 'undefined',
                console: typeof console !== 'undefined',
                math: typeof Math !== 'undefined',
                date: typeof Date !== 'undefined'
            }
        }, null, 2)
    )");
    
    return info.isError() ? "Error getting engine info" : info.toString();
}

void JavaScriptEngine::logEngineCapabilities() const
{
    qDebug() << "=== JavaScript Engine Information ===";
    qDebug() << "Engine Type: QJSEngine (Qt JavaScript Engine)";
    qDebug() << "Qt Version:" << QT_VERSION_STR;
    qDebug() << "ECMAScript Level: ES5+ (limited ES6 support)";
    
    QString info = getEngineInfo();
    qDebug() << "Detailed Capabilities:" << info;
    
    // Test specific features
    QJSValue testModernJS = m_engine->evaluate("const test = {a: 1, b: 2}; test.a + test.b");
    qDebug() << "Modern JS (const) support:" << (testModernJS.isError() ? "NO" : "YES");
    
    QJSValue testArrowFunction = m_engine->evaluate("((x) => x * 2)(5)");
    qDebug() << "Arrow function support:" << (testArrowFunction.isError() ? "NO" : "YES");
    
    qDebug() << "======================================";
}

void JavaScriptEngine::loadScriptModule(const QString& moduleName, const QString& scriptContent)
{
    QString moduleScript = QString(R"(
        (function() {
            var module = { exports: {} };
            var exports = module.exports;
            
            %1
            
            return module.exports;
        })()
    )").arg(scriptContent);
    
    QJSValue moduleResult = evaluate(moduleScript);
    
    if (!moduleResult.isError()) {
        m_scriptModules[moduleName] = moduleResult;
        qDebug() << "JavaScriptEngine: Loaded module:" << moduleName;
    }
}

QJSValue JavaScriptEngine::getModule(const QString& moduleName)
{
    return m_scriptModules.value(moduleName, QJSValue());
}

void JavaScriptEngine::handleJavaScriptException(const QJSValue& exception)
{
    m_lastError = QString("JavaScript Exception: %1").arg(exception.toString());
    emit scriptError(m_lastError);
    qDebug() << m_lastError;
}

void JavaScriptEngine::setupGlobalAPI()
{
    // Set up global JavaScript environment
    QJSValue globalObject = m_engine->globalObject();
    
    // Add setTimeout/setInterval placeholders - Qt5 compatible
    QJSValue setTimeoutFunc = m_engine->evaluate(
        "(function(func, delay) {"
        "    console.log('JavaScript: setTimeout called (not implemented)');"
        "    return 0;"
        "})"
    );
    globalObject.setProperty("setTimeout", setTimeoutFunc);
    
    QJSValue setIntervalFunc = m_engine->evaluate(
        "(function(func, delay) {"
        "    console.log('JavaScript: setInterval called (not implemented)');"
        "    return 0;"
        "})"
    );
    globalObject.setProperty("setInterval", setIntervalFunc);
}

void JavaScriptEngine::registerConsoleAPI()
{
    QJSValue console = m_engine->newObject();
    
    // Console API - Qt5 compatible with C++ callback
    QJSValue consoleLog = m_engine->evaluate(R"(
        (function() {
            var args = Array.prototype.slice.call(arguments);
            qt_console_log(args.join(" "));
        })
    )");
    console.setProperty("log", consoleLog);
    
    QJSValue consoleError = m_engine->evaluate(R"(
        (function() {
            var args = Array.prototype.slice.call(arguments);
            qt_console_error(args.join(" "));
        })
    )");
    console.setProperty("error", consoleError);
    
    // Register the entire JavaScriptEngine object so its public slots are accessible
    QJSValue engineObject = m_engine->newQObject(this);
    m_engine->globalObject().setProperty("qt_console_log", engineObject.property("qt_console_log"));
    m_engine->globalObject().setProperty("qt_console_error", engineObject.property("qt_console_error"));
    
    m_engine->globalObject().setProperty("console", console);
}

void JavaScriptEngine::qt_console_log(const QString& message)
{
    qDebug() << "JavaScript Console:" << message;
}

void JavaScriptEngine::qt_console_error(const QString& message)
{
    qDebug() << "JavaScript Error:" << message;
}

void JavaScriptEngine::registerUtilityAPI()
{
    QJSValue utils = m_engine->newObject();
    
    // JSON utilities - Qt5 compatible using built-in JSON
    QJSValue parseJSONFunc = m_engine->evaluate(R"(
        (function(jsonString) {
            if (arguments.length < 1) {
                throw new Error("parseJSON() requires a string parameter");
            }
            try {
                return JSON.parse(jsonString);
            } catch (e) {
                throw new Error("Invalid JSON string");
            }
        })
    )");
    utils.setProperty("parseJSON", parseJSONFunc);
    
    QJSValue stringifyJSONFunc = m_engine->evaluate(R"(
        (function(obj) {
            if (arguments.length < 1) {
                throw new Error("stringifyJSON() requires an object parameter");
            }
            try {
                return JSON.stringify(obj);
            } catch (e) {
                throw new Error("Cannot stringify object");
            }
        })
    )");
    utils.setProperty("stringifyJSON", stringifyJSONFunc);
    
    m_engine->globalObject().setProperty("Utils", utils);
}

QJSValue JavaScriptEngine::nodeToJSValue(Node* node)
{
    if (!node) {
        return QJSValue();
    }
    
    QJSValue nodeObj = m_engine->newObject();
    
    // Basic node properties
    nodeObj.setProperty("id", node->getId().toString());
    nodeObj.setProperty("type", node->getNodeType());
    nodeObj.setProperty("x", node->pos().x());
    nodeObj.setProperty("y", node->pos().y());
    
    // Socket information
    QJSValue sockets = m_engine->newArray();
    // TODO: Populate with actual socket data
    nodeObj.setProperty("sockets", sockets);
    
    return nodeObj;
}

QJSValue JavaScriptEngine::edgeToJSValue(Edge* edge)
{
    if (!edge) {
        return QJSValue();
    }
    
    QJSValue edgeObj = m_engine->newObject();
    
    // Basic edge properties
    edgeObj.setProperty("id", edge->getId().toString());
    
    // TODO: Add from/to node information
    
    return edgeObj;
}

void JavaScriptEngine::loadEnhancedAPIs()
{
    // List of enhanced API scripts to auto-load
    QStringList apiScripts = {
        "scripts/enhanced_graph_api.js",
        "scripts/custom_nodes.js",
        "scripts/node_algorithms.js",
        "scripts/node_execution_engine.js",
        "scripts/demo_interactive.js"
    };
    
    for (const QString& scriptPath : apiScripts) {
        QFile file(scriptPath);
        if (file.exists() && file.open(QIODevice::ReadOnly | QIODevice::Text)) {
            QTextStream in(&file);
            QString script = in.readAll();
            
            QJSValue result = evaluate(script);
            if (!result.isError()) {
                qDebug() << "JavaScriptEngine: Loaded enhanced API:" << scriptPath;
            } else {
                qDebug() << "JavaScriptEngine: Failed to load API:" << scriptPath << "-" << result.toString();
            }
        } else {
            qDebug() << "JavaScriptEngine: API script not found:" << scriptPath;
        }
    }
}


/// ===== FILE: graph_observer.h =====
#pragma once

#include <QSet>
#include <QUuid>
#include <QPointF>

// Forward declarations
class Node;
class Edge;

/**
 * GraphObserver - Interface for observing graph changes
 * 
 * Pure virtual interface that observers implement to receive
 * notifications about graph mutations.
 */
class GraphObserver
{
public:
    virtual ~GraphObserver() = default;

    // Node lifecycle events
    virtual void onNodeAdded(const Node& node) {}
    virtual void onNodeRemoved(const QUuid& nodeId) {}
    virtual void onNodeMoved(const QUuid& nodeId, QPointF oldPos, QPointF newPos) {}
    
    // Edge lifecycle events  
    virtual void onEdgeAdded(const Edge& edge) {}
    virtual void onEdgeRemoved(const QUuid& edgeId) {}
    
    // Graph-level events
    virtual void onGraphCleared() {}
    virtual void onGraphLoaded(const QString& filename) {}
    virtual void onGraphSaved(const QString& filename) {}
};

/**
 * GraphSubject - Base class for observable graph entities
 * 
 * Manages observer registration and provides notification helpers
 * for subclasses (Scene, GraphModel, etc.)
 */
class GraphSubject
{
public:
    virtual ~GraphSubject();
    
    // Observer management
    void attach(GraphObserver* observer);
    void detach(GraphObserver* observer);
    
    // Batch mode for bulk operations (prevents observer storm)
    static void beginBatch();
    static void endBatch();
    static bool isInBatch() { return s_batchDepth > 0; }
    
protected:
    // Notification helpers for subclasses
    void notifyNodeAdded(const Node& node);
    void notifyNodeRemoved(const QUuid& nodeId);
    void notifyNodeMoved(const QUuid& nodeId, QPointF oldPos, QPointF newPos);
    void notifyEdgeAdded(const Edge& edge);
    void notifyEdgeRemoved(const QUuid& edgeId);
    void notifyGraphCleared();
    void notifyGraphLoaded(const QString& filename);
    void notifyGraphSaved(const QString& filename);
    
private:
    QSet<GraphObserver*> m_observers;
    
    // Static batch control
    static int s_batchDepth;
};


/// ===== FILE: graph_observer.cpp =====
#include "graph_observer.h"
#include "node.h"
#include "edge.h"
#include <QDebug>

// ============================================================================
// GraphSubject Implementation
// ============================================================================

// Initialize static batch depth
int GraphSubject::s_batchDepth = 0;

GraphSubject::~GraphSubject()
{
    // CRITICAL FIX: Clear observer container properly to prevent dangling pointers
    // The old code was setting local pointer to nullptr, not the container elements!
    qDebug() << "GraphSubject: Destroying subject with" << m_observers.size() << "observers";
    
    // Simply clear the container - observers manage their own lifecycle
    m_observers.clear();
    
    qDebug() << "GraphSubject: ✓ Observer container cleared safely";
}

void GraphSubject::attach(GraphObserver* observer)
{
    if (observer) {
        m_observers.insert(observer);
        qDebug() << "GraphSubject: Observer attached, total observers:" << m_observers.size();
    }
}

void GraphSubject::detach(GraphObserver* observer)
{
    if (observer && m_observers.remove(observer)) {
        qDebug() << "GraphSubject: Observer detached, remaining observers:" << m_observers.size();
    }
}

void GraphSubject::notifyNodeAdded(const Node& node)
{
    // OPTIMIZATION: Skip notifications during batch operations
    if (isInBatch()) return;
    
    qDebug() << "GraphSubject: Notifying" << m_observers.size() << "observers of node added:" 
             << node.getId().toString(QUuid::WithoutBraces).left(8);
    
    for (GraphObserver* observer : m_observers) {
        if (observer) {
            observer->onNodeAdded(node);
        }
    }
}

void GraphSubject::notifyNodeRemoved(const QUuid& nodeId)
{
    // OPTIMIZATION: Skip notifications during batch operations
    if (isInBatch()) return;
    
    qDebug() << "GraphSubject: Notifying" << m_observers.size() << "observers of node removed:" 
             << nodeId.toString(QUuid::WithoutBraces).left(8);
    
    for (GraphObserver* observer : m_observers) {
        if (observer) {
            observer->onNodeRemoved(nodeId);
        }
    }
}

void GraphSubject::notifyNodeMoved(const QUuid& nodeId, QPointF oldPos, QPointF newPos)
{
    // OPTIMIZATION: Skip notifications during batch operations
    if (isInBatch()) return;
    
    qDebug() << "GraphSubject: Notifying" << m_observers.size() << "observers of node moved:" 
             << nodeId.toString(QUuid::WithoutBraces).left(8) << "from" << oldPos << "to" << newPos;
    
    for (GraphObserver* observer : m_observers) {
        if (observer) {
            observer->onNodeMoved(nodeId, oldPos, newPos);
        }
    }
}

void GraphSubject::notifyEdgeAdded(const Edge& edge)
{
    // OPTIMIZATION: Skip notifications during batch operations
    if (isInBatch()) return;
    
    qDebug() << "GraphSubject: Notifying" << m_observers.size() << "observers of edge added:" 
             << edge.getId().toString(QUuid::WithoutBraces).left(8);
    
    for (GraphObserver* observer : m_observers) {
        if (observer) {
            observer->onEdgeAdded(edge);
        }
    }
}

void GraphSubject::notifyEdgeRemoved(const QUuid& edgeId)
{
    // OPTIMIZATION: Skip notifications during batch operations
    if (isInBatch()) return;
    
    qDebug() << "GraphSubject: Notifying" << m_observers.size() << "observers of edge removed:" 
             << edgeId.toString(QUuid::WithoutBraces).left(8);
    
    for (GraphObserver* observer : m_observers) {
        if (observer) {
            observer->onEdgeRemoved(edgeId);
        }
    }
}

void GraphSubject::notifyGraphCleared()
{
    qDebug() << "GraphSubject: Notifying" << m_observers.size() << "observers of graph cleared";
    
    for (GraphObserver* observer : m_observers) {
        if (observer) {
            observer->onGraphCleared();
        }
    }
}

void GraphSubject::notifyGraphLoaded(const QString& filename)
{
    qDebug() << "GraphSubject: Notifying" << m_observers.size() << "observers of graph loaded:" << filename;
    
    for (GraphObserver* observer : m_observers) {
        if (observer) {
            observer->onGraphLoaded(filename);
        }
    }
}

void GraphSubject::notifyGraphSaved(const QString& filename)
{
    qDebug() << "GraphSubject: Notifying" << m_observers.size() << "observers of graph saved:" << filename;
    
    for (GraphObserver* observer : m_observers) {
        if (observer) {
            observer->onGraphSaved(filename);
        }
    }
}

// ============================================================================
// Batch Mode Implementation
// ============================================================================

void GraphSubject::beginBatch()
{
    ++s_batchDepth;
    qDebug() << "GraphSubject: Begin batch mode (depth:" << s_batchDepth << ")";
}

void GraphSubject::endBatch()
{
    if (s_batchDepth > 0) {
        --s_batchDepth;
        qDebug() << "GraphSubject: End batch mode (depth:" << s_batchDepth << ")";
        
        if (s_batchDepth == 0) {
            qDebug() << "GraphSubject: Batch complete - observers can resume";
        }
    }
}


/// ===== FILE: xml_autosave_observer.h =====
#pragma once

#include "graph_observer.h"
#include <QString>
#include <QTimer>

class Scene;

/**
 * XmlAutosaveObserver - Automatically saves graph changes to XML
 * 
 * Listens to all graph mutations and maintains an up-to-date XML file.
 * Uses delayed saving to avoid excessive I/O during rapid changes.
 */
class XmlAutosaveObserver : public GraphObserver
{
public:
    explicit XmlAutosaveObserver(Scene* scene, const QString& filename = "autosave.xml");
    ~XmlAutosaveObserver();
    
    // Configure autosave behavior
    void setFilename(const QString& filename);
    void setDelay(int milliseconds);  // Delay before saving after last change
    void setEnabled(bool enabled);
    
    // Force immediate save
    void saveNow();
    
    // GraphObserver interface
    void onNodeAdded(const Node& node) override;
    void onNodeRemoved(const QUuid& nodeId) override;
    void onNodeMoved(const QUuid& nodeId, QPointF oldPos, QPointF newPos) override;
    void onEdgeAdded(const Edge& edge) override;
    void onEdgeRemoved(const QUuid& edgeId) override;
    void onGraphCleared() override;
    
private:
    Scene* m_scene;
    QString m_filename;
    QTimer* m_saveTimer;
    bool m_enabled;
    bool m_pendingChanges;
    
    void scheduleAutosave();
    void performAutosave();
    QString generateFullXml() const;
};


/// ===== FILE: xml_autosave_observer.cpp =====
#include "xml_autosave_observer.h"
#include "scene.h"
#include "node.h"
#include "edge.h"
#include "graph_observer.h"
#include <QTimer>
#include <QDebug>
#include <QElapsedTimer>
#include <QFileInfo>
#include <QFile>
#include <QTextStream>
#include <libxml/tree.h>
#include <libxml/parser.h>

XmlAutosaveObserver::XmlAutosaveObserver(Scene* scene, const QString& filename)
    : m_scene(scene)
    , m_filename(filename)
    , m_saveTimer(new QTimer())
    , m_enabled(true)
    , m_pendingChanges(false)
{
    // Configure timer for delayed saving
    m_saveTimer->setSingleShot(true);
    m_saveTimer->setInterval(2000); // 2 second delay by default
    
    // Connect timer to autosave
    QObject::connect(m_saveTimer, &QTimer::timeout, [this]() {
        performAutosave();
    });
    
}

XmlAutosaveObserver::~XmlAutosaveObserver()
{
    try {
        if (m_pendingChanges && m_enabled) {
            saveNow(); // Save any pending changes before destruction
        }
    } catch (const std::exception& e) {
        qWarning() << "XmlAutosaveObserver: Failed to save during cleanup:" << e.what();
        qWarning() << "Pending changes may be lost but application will continue safely";
    } catch (...) {
        qWarning() << "XmlAutosaveObserver: Unknown error during cleanup - data may be lost";
        qWarning() << "Application continues to prevent crash";
    }
    
    delete m_saveTimer;
}

void XmlAutosaveObserver::setFilename(const QString& filename)
{
    m_filename = filename;
    qDebug() << "XmlAutosaveObserver: Filename changed to" << m_filename;
}

void XmlAutosaveObserver::setDelay(int milliseconds)
{
    m_saveTimer->setInterval(milliseconds);
    qDebug() << "Autosave:" << milliseconds << "ms";
}

void XmlAutosaveObserver::setEnabled(bool enabled)
{
    m_enabled = enabled;
    if (!enabled) {
        m_saveTimer->stop();
    }
    qDebug() << "Autosave enabled:" << m_enabled;
}

void XmlAutosaveObserver::saveNow()
{
    m_saveTimer->stop();
    performAutosave();
}

void XmlAutosaveObserver::onNodeAdded(const Node& node)
{
    // Node added - minimal logging
    scheduleAutosave();
}

void XmlAutosaveObserver::onNodeRemoved(const QUuid& nodeId)
{
    qDebug() << "🔔 OBSERVER: Node removed" << nodeId.toString(QUuid::WithoutBraces).left(8) << "- Triggering autosave";
    scheduleAutosave();
}

void XmlAutosaveObserver::onNodeMoved(const QUuid& nodeId, QPointF oldPos, QPointF newPos)
{
    Q_UNUSED(oldPos)
    Q_UNUSED(newPos)
    qDebug().noquote() << "[AUTOSAVE] Node moved:" << nodeId.toString(QUuid::WithoutBraces).left(8);
    scheduleAutosave();
}

void XmlAutosaveObserver::onEdgeAdded(const Edge& edge)
{
    // Edge added - minimal logging
    scheduleAutosave();
}

void XmlAutosaveObserver::onEdgeRemoved(const QUuid& edgeId)
{
    qDebug() << "🔔 OBSERVER: Edge removed" << edgeId.toString(QUuid::WithoutBraces).left(8) << "- Triggering autosave";
    scheduleAutosave();
}

void XmlAutosaveObserver::onGraphCleared()
{
    qDebug() << "🔔 OBSERVER: Graph cleared - Triggering autosave";
    scheduleAutosave();
}

void XmlAutosaveObserver::scheduleAutosave()
{
    if (!m_enabled) return;
    
    // OPTIMIZATION: Skip autosave scheduling during batch operations
    if (GraphSubject::isInBatch()) {
        qDebug().noquote() << "[AUTOSAVE] Skipping during batch mode";
        return;
    }
    
    m_pendingChanges = true;
    qDebug().noquote() << "[AUTOSAVE] markDirty() called. Timer started:" 
                       << m_saveTimer->interval() << "ms";
    m_saveTimer->start(); // Restart timer - delays save until activity stops
}

void XmlAutosaveObserver::performAutosave()
{
    qDebug().noquote() << "[AUTOSAVE] flushIfDirty() called. Enabled:" << m_enabled 
                       << "Pending:" << m_pendingChanges << "Scene:" << (m_scene ? "valid" : "NULL");
    
    if (!m_enabled || !m_pendingChanges || !m_scene) {
        return;
    }
    
    qDebug() << "XmlAutosaveObserver: Performing autosave to" << m_filename;
    
    QElapsedTimer timer;
    timer.start();
    
    // Create full XML serialization of the current graph
    QString xmlContent = generateFullXml();
    
    // Write to file (simplified)
    qDebug().noquote() << "[AUTOSAVE] writeAutosave() attempting to write to:" << m_filename;
    QFile file(m_filename);
    if (file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        QTextStream out(&file);
        out << xmlContent;
        file.close();
        
        qint64 elapsed = timer.elapsed();
        QFileInfo fileInfo(m_filename);
        qint64 fileSize = fileInfo.size();
        
        qDebug().noquote() << "[AUTOSAVE] writeAutosave() SUCCESS! File written to disk.";
        qDebug() << "✅ AUTOSAVE COMPLETE:";
        qDebug() << "   📁 File:" << fileInfo.fileName();
        qDebug() << "   ⏱️  Time:" << elapsed << "ms";
        qDebug() << "   📊 Size:" << (fileSize / 1024.0) << "KB";
        qDebug() << "   🔢 XML length:" << xmlContent.length() << "characters";
        
        m_pendingChanges = false;
    } else {
        qDebug().noquote() << "[AUTOSAVE] writeAutosave() FAILED! Cannot open file for writing.";
        qWarning() << "✗ XmlAutosaveObserver: Failed to save" << m_filename;
    }
}

QString XmlAutosaveObserver::generateFullXml() const
{
    if (!m_scene) {
        return "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<graph version=\"1.0\"/>\n";
    }
    
    // Create XML document
    xmlDocPtr doc = xmlNewDoc(BAD_CAST "1.0");
    xmlNodePtr root = xmlNewNode(nullptr, BAD_CAST "graph");
    xmlDocSetRootElement(doc, root);
    xmlSetProp(root, BAD_CAST "version", BAD_CAST "1.0");
    
    // Add nodes section
    xmlNodePtr nodesNode = xmlNewChild(root, nullptr, BAD_CAST "nodes", nullptr);
    for (auto it = m_scene->getNodes().begin(); it != m_scene->getNodes().end(); ++it) {
        Node* node = it.value();
        if (node) {
            xmlNodePtr nodeXml = node->write(doc, nullptr);
            if (nodeXml) {
                xmlAddChild(nodesNode, nodeXml);
            }
        }
    }
    
    // Add edges section
    xmlNodePtr edgesNode = xmlNewChild(root, nullptr, BAD_CAST "connections", nullptr);
    for (auto it = m_scene->getEdges().begin(); it != m_scene->getEdges().end(); ++it) {
        Edge* edge = it.value();
        if (edge) {
            xmlNodePtr edgeXml = edge->write(doc, nullptr);
            if (edgeXml) {
                xmlAddChild(edgesNode, edgeXml);
            }
        }
    }
    
    // Convert to string
    xmlChar* xmlBuffer;
    int bufferSize;
    xmlDocDumpFormatMemory(doc, &xmlBuffer, &bufferSize, 1);
    
    QString result = QString::fromUtf8(reinterpret_cast<const char*>(xmlBuffer));
    
    // Clean up
    xmlFree(xmlBuffer);
    xmlFreeDoc(doc);
    
    return result;
}



/// ===== FILE: main.cpp =====
#include <QApplication>
#include "window.h"   // make sure this header exists and defines Window

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);

    // main() stays a pure bootstrapper — no XML, no factory, no I/O here.
    Window window;
    window.show();

    return app.exec();
}




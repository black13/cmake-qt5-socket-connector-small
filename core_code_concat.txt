=== Core NodeGraph Source Files ===
Generated: Wed Aug 13 13:03:01 CDT 2025

=== main.cpp ===
#include <QApplication>
#include <QCommandLineParser>
#include <QCommandLineOption>
#include <QFileInfo>
#include <QDebug>
#include <QLoggingCategory>
#include <QStandardPaths>
#include <QDir>
#include <QTextStream>
#include <QDateTime>
#include <QMutex>
#include <QTimer>
#include <QMessageBox>
#include <QJSValue>
#include <iostream>
#include "window.h"
#include "scene.h"
#include "node.h"
#include "edge.h"
#include "graph_factory.h"
#include "node_registry.h"
#include "javascript_engine.h"

void setupLogging()
{
    // Create logs directory if it doesn't exist
    QDir logsDir("logs");
    if (!logsDir.exists()) {
        logsDir.mkpath(".");
    }
    
    // Create timestamped log file
    QString timestamp = QDateTime::currentDateTime().toString("yyyy-MM-dd_hh-mm-ss");
    QString logFileName = QString("logs/NodeGraph_%1.log").arg(timestamp);
    
    // Redirect Qt debug output to file
    static QFile debugFile(logFileName);
    debugFile.open(QIODevice::WriteOnly | QIODevice::Append);
    static QTextStream stream(&debugFile);
    
    qInstallMessageHandler([](QtMsgType type, const QMessageLogContext &context, const QString &msg) {
        QString timestamp = QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss.zzz");
        QString typeStr;
        
        switch (type) {
        case QtDebugMsg:    typeStr = "DEBUG"; break;
        case QtInfoMsg:     typeStr = "INFO "; break;
        case QtWarningMsg:  typeStr = "WARN "; break;
        case QtCriticalMsg: typeStr = "ERROR"; break;
        case QtFatalMsg:    typeStr = "FATAL"; break;
        }
        
        QString logEntry = QString("[%1] %2: %3").arg(timestamp, typeStr, msg);
        
        // Write to main log
        stream << logEntry << Qt::endl;
        stream.flush();
        
        // Write JavaScript-related messages to separate JS log
        if (msg.contains("JavaScript", Qt::CaseInsensitive) || 
            msg.contains("Script", Qt::CaseInsensitive) ||
            msg.contains("QJSEngine", Qt::CaseInsensitive) ||
            msg.contains("JS_ERROR", Qt::CaseInsensitive) ||
            msg.contains("JS_EXECUTION", Qt::CaseInsensitive)) {
            
            static QFile jsLogFile(QString("logs/JavaScript_%1.log").arg(QDateTime::currentDateTime().toString("yyyy-MM-dd_hh-mm-ss")));
            if (!jsLogFile.isOpen()) {
                jsLogFile.open(QIODevice::WriteOnly | QIODevice::Append);
            }
            
            if (jsLogFile.isOpen()) {
                QTextStream jsStream(&jsLogFile);
                jsStream << logEntry << Qt::endl;
                jsStream.flush();
            }
        }
    });
    
    qDebug() << "=== NodeGraph Application Started ===";
    qDebug() << "Log file:" << logFileName;
    qDebug() << "Timestamp:" << QDateTime::currentDateTime().toString();
}

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    
    // Setup file logging
    setupLogging();
    
    
    // Set application metadata for Qt command line tools
    QCoreApplication::setApplicationName("NodeGraph");
    QCoreApplication::setApplicationVersion("1.0.0");
    QCoreApplication::setOrganizationName("NodeGraph Project");
    // setApplicationDisplayName not available in Qt 5.x on all platforms
    
    // Setup Qt5 command line parser
    QCommandLineParser parser;
    parser.setApplicationDescription("A self-serializing node graph editor with libxml2 backend");
    parser.addHelpOption();
    parser.addVersionOption();
    
    // Add file loading option
    QCommandLineOption loadFileOption(QStringList() << "l" << "load",
                                      "Load graph from XML file",
                                      "file");
    parser.addOption(loadFileOption);
    
    
    // Add positional argument for file
    parser.addPositionalArgument("file", "XML file to load (optional)");
    
    // Process command line arguments
    parser.process(app);
    
    // Command line parsing
    
    // Create main window
    qDebug() << "=== STEP 1: Creating Window (BEFORE node registration) ===";
    qDebug() << "NodeRegistry types at window creation:" << NodeRegistry::instance().getRegisteredTypes().size();
    Window window;
    qDebug() << "Window created successfully";
    
    // Initialize JavaScript engine
    qDebug() << "=== STEP 2: Initializing JavaScript Engine (BEFORE node registration) ===";
    qDebug() << "NodeRegistry types before JS engine:" << NodeRegistry::instance().getRegisteredTypes().size();
    Scene* scene = window.getScene();
    if (scene) {
        auto* jsEngine = scene->getJavaScriptEngine();
        if (!jsEngine) {
            qDebug() << "Warning: JavaScript engine initialization failed";
        } else {
            qDebug() << "JavaScript engine initialized successfully";
            qDebug() << "NodeRegistry types after JS engine init:" << NodeRegistry::instance().getRegisteredTypes().size();
        }
    }
    
    // Handle file loading
    QString filename;
    if (parser.isSet(loadFileOption)) {
        filename = parser.value(loadFileOption);
    } else {
        const QStringList positionalArgs = parser.positionalArguments();
        if (!positionalArgs.isEmpty()) {
            filename = positionalArgs.first();
        }
    }
    
    // Store information about file loading status for user notification
    bool fileLoadAttempted = !filename.isEmpty();
    QString originalFilename = filename; // Store original filename for user message
    
    // Create empty XML document for GraphFactory
    // GraphFactory will handle all file loading - single XML authority
    qDebug() << "=== Creating Empty XML Document ===";
    xmlDocPtr xmlDoc = xmlNewDoc(BAD_CAST "1.0");
    xmlNodePtr root = xmlNewNode(nullptr, BAD_CAST "graph");
    xmlDocSetRootElement(xmlDoc, root);
    
    xmlSetProp(root, BAD_CAST "version", BAD_CAST "1.0");
    xmlSetProp(root, BAD_CAST "xmlns", BAD_CAST "http://nodegraph.org/schema");
    
    qDebug() << "✓ Empty XML document created - GraphFactory will handle file loading";
    
    // Register all supported node types
    qDebug() << "=== STEP 3: Registering Node Types (AFTER window/JS engine creation) ===";
    qDebug() << "NodeRegistry types BEFORE registration:" << NodeRegistry::instance().getRegisteredTypes().size();
    qDebug() << "Starting node type registration process...";
    
    // Core node types
    NodeRegistry::instance().registerNode("IN", []() { 
        Node* node = new Node(); 
        node->setNodeType("IN"); 
        return node; 
    });
    qDebug() << "Registered: IN (count now:" << NodeRegistry::instance().getRegisteredTypes().size() << ")";
    
    NodeRegistry::instance().registerNode("OUT", []() { 
        Node* node = new Node(); 
        node->setNodeType("OUT"); 
        return node; 
    });
    qDebug() << "Registered: OUT (count now:" << NodeRegistry::instance().getRegisteredTypes().size() << ")";
    
    NodeRegistry::instance().registerNode("PROC", []() { 
        Node* node = new Node(); 
        node->setNodeType("PROC"); 
        return node; 
    });
    qDebug() << "Registered: PROC (count now:" << NodeRegistry::instance().getRegisteredTypes().size() << ")";
    
    // Palette node types - each with proper type designation
    NodeRegistry::instance().registerNode("SOURCE", []() { 
        Node* node = new Node(); 
        node->setNodeType("SOURCE"); 
        return node; 
    });
    qDebug() << "Registered: SOURCE (count now:" << NodeRegistry::instance().getRegisteredTypes().size() << ")";
    
    NodeRegistry::instance().registerNode("SINK", []() { 
        Node* node = new Node(); 
        node->setNodeType("SINK"); 
        return node; 
    });
    qDebug() << "Registered: SINK (count now:" << NodeRegistry::instance().getRegisteredTypes().size() << ")";
    
    NodeRegistry::instance().registerNode("TRANSFORM", []() { 
        Node* node = new Node(); 
        node->setNodeType("TRANSFORM"); 
        return node; 
    });
    qDebug() << "Registered: TRANSFORM (count now:" << NodeRegistry::instance().getRegisteredTypes().size() << ")";
    
    NodeRegistry::instance().registerNode("MERGE", []() { 
        Node* node = new Node(); 
        node->setNodeType("MERGE"); 
        return node; 
    });
    qDebug() << "Registered: MERGE (count now:" << NodeRegistry::instance().getRegisteredTypes().size() << ")";
    
    NodeRegistry::instance().registerNode("SPLIT", []() { 
        Node* node = new Node(); 
        node->setNodeType("SPLIT"); 
        return node; 
    });
    qDebug() << "Registered: SPLIT (count now:" << NodeRegistry::instance().getRegisteredTypes().size() << ")";
    
    // Legacy compatibility for older tests
    NodeRegistry::instance().registerNode("PROCESSOR", []() { 
        Node* node = new Node(); 
        node->setNodeType("PROCESSOR"); 
        return node; 
    });
    qDebug() << "Registered: PROCESSOR (count now:" << NodeRegistry::instance().getRegisteredTypes().size() << ")";
    
    QStringList registeredTypes = NodeRegistry::instance().getRegisteredTypes();

    // Test the NodeRegistry to verify nodes are registered
    qDebug() << "=== NodeGraph Application Starting ===";
    qDebug() << "Registered node types:" << NodeRegistry::instance().getRegisteredTypes();
    qDebug() << "Total registered types:" << registeredTypes.size();
    qDebug() << "=== Logging each registered type ===";
    for (int i = 0; i < registeredTypes.size(); ++i) {
        qDebug() << QString("  [%1] \"%2\"").arg(i + 1).arg(registeredTypes[i]);
    }
    qDebug() << "======================================";
    
    // Initialize GraphFactory with scene and XML document
    // Scene* scene = window.getScene(); // Already declared above
    if (!scene) {
        qCritical() << "✗ Failed to get scene from window";
        return -1;
    }
    
    GraphFactory factory(scene, xmlDoc);
    qDebug() << "GraphFactory initialized with empty XML document";
    
    if (!filename.isEmpty()) {
        // GraphFactory is now the single XML authority
        qDebug() << "Loading file via GraphFactory:" << filename;
        if (!factory.loadFromXmlFile(filename)) {
            qCritical() << "GraphFactory failed to load XML file:" << filename;
            if (fileLoadAttempted) {
                qDebug() << "Original filename was:" << originalFilename;
            }
            return -1;
        }
        
        qDebug() << "✓ Graph loaded successfully from file via GraphFactory:" << filename;
        
    } else {
        qDebug() << "Starting with empty graph - no file specified";
        qDebug() << "=== Starting with Empty Graph ===";
        qDebug() << "✓ No file specified - application will start with clean scene";
        qDebug() << "  Users can create nodes manually or load XML files via Ctrl+L";
    }
    
    qDebug() << "=== XML-First Architecture Test Complete ===";
    
    // Set current file if we loaded from command line
    if (!filename.isEmpty()) {
        window.setCurrentFile(filename);
        qDebug() << "📁 Command line file loaded - Ctrl+S will save to:" << filename;
    }
    
    // Cleanup XML document when done
    // Note: GraphFactory holds reference, so clean up after window closes
    
    window.show();
    
    // Show user-friendly message about file loading status
    if (fileLoadAttempted && originalFilename != filename) {
        // File was attempted but failed to load (filename was cleared)
        QTimer::singleShot(500, [&window, originalFilename]() {
            QMessageBox::information(&window, "File Not Found", 
                QString("The specified file could not be found or loaded:\n\n%1\n\nStarting with an empty graph instead.\n\nYou can create a new graph or open an existing file using File → Open.")
                .arg(originalFilename));
        });
    }
    
    int result = app.exec();
    
    // Final status before exit
    qDebug() << "=== NodeGraph Application Ending ===";
    
    // Cleanup XML document
    if (xmlDoc) {
        xmlFreeDoc(xmlDoc);
        qDebug() << "✓ XML document cleaned up";
    }
    
    return result;
}

=== window.cpp ===
#include "window.h"
#include "view.h"
#include "scene.h"
#include "node.h"
#include "edge.h"
#include "graph_factory.h"
#include "xml_autosave_observer.h"
#include "javascript_engine.h"
#include "node_palette_widget.h"
// #include "javascript_console.h"  // Disabled for now
#include <QKeyEvent>
#include <QFileDialog>
#include <QMessageBox>
#include <QDebug>
#include <QElapsedTimer>
#include <QFileInfo>
#include <QAction>
#include <QIcon>
#include <QRandomGenerator>
#include <QDockWidget>
#include <QLabel>
#include <QStatusBar>
#include <QMenuBar>
#include <QProgressBar>
#include <QApplication>
#include <QDesktopServices>
#include <QUrl>
#include <QJSValue>
#include <libxml/tree.h>
#include <libxml/xmlsave.h>

Window::Window(QWidget* parent)
    : QMainWindow(parent)
    , m_scene(new Scene(this))
    , m_view(new View(m_scene, this))
{
    setWindowTitle("NodeGraph - Self-Serializing Node Editor");
    resize(1400, 900);
    
    // Initialize UI components to nullptr
    m_nodePaletteDock = nullptr;
    m_nodePalette = nullptr;
    // m_javaScriptConsoleDock = nullptr;
    // m_javaScriptConsole = nullptr;
    m_fileInfoLabel = nullptr;
    m_graphStatsLabel = nullptr;
    m_selectionLabel = nullptr;
    m_positionLabel = nullptr;
    m_zoomLabel = nullptr;
    m_operationProgress = nullptr;
    
    // Create XML document for factory
    m_xmlDocument = xmlNewDoc(BAD_CAST "1.0");
    xmlNodePtr root = xmlNewNode(nullptr, BAD_CAST "graph");
    xmlDocSetRootElement(m_xmlDocument, root);
    xmlSetProp(root, BAD_CAST "version", BAD_CAST "1.0");
    
    // Initialize factory for interactive node creation
    m_factory = new GraphFactory(m_scene, m_xmlDocument);
    
    // Initialize autosave observer for automatic XML saving
    m_autosaveObserver = new XmlAutosaveObserver(m_scene, "autosave.xml");
    m_autosaveObserver->setDelay(750); // 750ms delay after changes
    
    // CRITICAL: Attach observer to scene to receive notifications
    m_scene->attach(m_autosaveObserver);
    
    // Setup enhanced UI
    setupUI();
    setupActions();
    setupMenus();
    setupStatusBar();
    setupDockWidgets(); // JavaScript console disabled for now
    
    // Connect scene signals for status updates
    connect(m_scene, &Scene::sceneChanged, this, &Window::onSceneChanged);
    
    // Connect view signals for drag-and-drop
    connect(m_view, &View::nodeDropped, this, &Window::createNodeFromPalette);
    
    // Initial status update
    updateStatusBar();
    
    // Enable keyboard shortcuts
    setFocusPolicy(Qt::StrongFocus);
}

Window::~Window()
{
    // Clean up autosave observer
    if (m_autosaveObserver) {
        m_scene->detach(m_autosaveObserver);
        delete m_autosaveObserver;
    }
    
    // Clean up XML document
    if (m_xmlDocument) {
        xmlFreeDoc(m_xmlDocument);
        m_xmlDocument = nullptr;
    }
}

void Window::setupActions()
{
    // Create actions for node creation
    m_addInputAction = new QAction("Add Input", this);
    m_addInputAction->setToolTip("Add Input Node (Ctrl+1)");
    m_addInputAction->setShortcut(QKeySequence("Ctrl+1"));
    connect(m_addInputAction, &QAction::triggered, this, &Window::createInputNode);
    
    m_addOutputAction = new QAction("Add Output", this);
    m_addOutputAction->setToolTip("Add Output Node (Ctrl+2)");
    m_addOutputAction->setShortcut(QKeySequence("Ctrl+2"));
    connect(m_addOutputAction, &QAction::triggered, this, &Window::createOutputNode);
    
    m_addProcessorAction = new QAction("Add Processor", this);
    m_addProcessorAction->setToolTip("Add Processor Node (Ctrl+3)");
    m_addProcessorAction->setShortcut(QKeySequence("Ctrl+3"));
    connect(m_addProcessorAction, &QAction::triggered, this, &Window::createProcessorNode);
}


void Window::keyPressEvent(QKeyEvent* event)
{
    if (event->modifiers() & Qt::ControlModifier) {
        switch (event->key()) {
            case Qt::Key_1:
                createInputNode();
                break;
            case Qt::Key_2:
                createOutputNode();
                break;
            case Qt::Key_3:
                createProcessorNode();
                break;
            case Qt::Key_S:
                if (event->modifiers() & Qt::ShiftModifier) {
                    // Ctrl+Shift+S = Save As
                    QString filename = QFileDialog::getSaveFileName(
                        this, 
                        "Save Graph As", 
                        "graph.xml", 
                        "XML Files (*.xml)");
                    if (!filename.isEmpty()) {
                        if (saveGraph(filename)) {
                            m_currentFile = filename;
                            setWindowTitle(QString("Node Editor - %1").arg(QFileInfo(filename).fileName()));
                        }
                    }
                } else {
                    // Ctrl+S = Save
                    if (m_currentFile.isEmpty()) {
                        // No current file, show Save As dialog
                        QString filename = QFileDialog::getSaveFileName(
                            this, 
                            "Save Graph", 
                            "graph.xml", 
                            "XML Files (*.xml)");
                        if (!filename.isEmpty()) {
                            if (saveGraph(filename)) {
                                m_currentFile = filename;
                                setWindowTitle(QString("Node Editor - %1").arg(QFileInfo(filename).fileName()));
                            }
                        }
                    } else {
                        // Save to current file
                        saveGraph(m_currentFile);
                    }
                }
                break;
            case Qt::Key_O:
                // Ctrl+O = Open
                {
                    QString filename = QFileDialog::getOpenFileName(
                        this, 
                        "Open Graph", 
                        "", 
                        "XML Files (*.xml)");
                    if (!filename.isEmpty()) {
                        if (loadGraph(filename)) {
                            m_currentFile = filename;
                            setWindowTitle(QString("Node Editor - %1").arg(QFileInfo(filename).fileName()));
                        }
                    }
                }
                break;
        }
    } else if (event->key() == Qt::Key_Delete || event->key() == Qt::Key_Backspace) {
        // Delete selected items
        qDebug() << "🗑️ Delete key pressed - deleting selected items";
        m_scene->deleteSelected();
    }
    QMainWindow::keyPressEvent(event);
}

void Window::setCurrentFile(const QString& filename)
{
    m_currentFile = filename;
    if (!filename.isEmpty()) {
        setWindowTitle(QString("Node Editor - %1").arg(QFileInfo(filename).fileName()));
        qDebug() << "📁 Current file set to:" << filename;
    } else {
        setWindowTitle("Node Editor");
        qDebug() << "📁 Current file cleared";
    }
}

bool Window::saveGraph(const QString& filename)
{
    qDebug() << "Saving graph to:" << filename;
    
    QElapsedTimer timer;
    timer.start();
    
    // Create XML document
    xmlDocPtr doc = xmlNewDoc(BAD_CAST "1.0");
    xmlNodePtr root = xmlNewNode(nullptr, BAD_CAST "graph");
    xmlDocSetRootElement(doc, root);
    xmlSetProp(root, BAD_CAST "version", BAD_CAST "1.0");
    
    // Step 1: Save all nodes
    for (Node* node : m_scene->getNodes().values()) {
        xmlNodePtr nodeXml = node->write(doc, root);
        Q_UNUSED(nodeXml)
    }
    
    // Step 2: Save all edges
    for (Edge* edge : m_scene->getEdges().values()) {
        xmlNodePtr edgeXml = edge->write(doc, root);
        Q_UNUSED(edgeXml)
    }
    
    // Step 3: Save to file
    int result = xmlSaveFormatFileEnc(filename.toUtf8().constData(), doc, "UTF-8", 1);
    xmlFreeDoc(doc);
    
    qint64 elapsed = timer.elapsed();
    
    if (result != -1) {
        QFileInfo fileInfo(filename);
        qint64 fileSize = fileInfo.size();
        int nodeCount = m_scene->getNodes().size();
        int edgeCount = m_scene->getEdges().size();
        
        qDebug() << "✅ MANUAL SAVE COMPLETE:";
        qDebug() << "   📁 File:" << fileInfo.fileName();
        qDebug() << "   ⏱️  Time:" << elapsed << "ms";
        qDebug() << "   📊 Size:" << (fileSize / 1024.0) << "KB";
        qDebug() << "   🔵 Nodes:" << nodeCount;
        qDebug() << "   🔗 Edges:" << edgeCount;
        
        QMessageBox::information(this, "Save Complete", 
            QString("Graph saved successfully!\n\n📁 File: %1\n🔵 Nodes: %2\n🔗 Edges: %3\n⏱️ Time: %4ms\n📊 Size: %5 KB")
            .arg(fileInfo.fileName())
            .arg(nodeCount)
            .arg(edgeCount)
            .arg(elapsed)
            .arg(fileSize / 1024.0, 0, 'f', 1));
        return true;
    } else {
        qDebug() << "✗ Failed to save graph";
        QMessageBox::critical(this, "Save Error", "Failed to save graph to file.");
        return false;
    }
}

bool Window::loadGraph(const QString& filename)
{
    qDebug() << "=== LOADING GRAPH ===" << filename;
    
    QElapsedTimer timer;
    timer.start();
    
    // Clear current scene AND registries to prevent dangling pointers
    qDebug() << "Clearing current graph...";
    m_scene->clearGraph();
    
    // Use GraphFactory to load from XML file
    qDebug() << "Starting GraphFactory XML load...";
    if (m_factory->loadFromXmlFile(filename)) {
        qint64 elapsed = timer.elapsed();
        
        // Set current file for Ctrl+S functionality
        m_currentFile = filename;
        setWindowTitle(QString("Node Editor - %1").arg(QFileInfo(filename).fileName()));
        
        qDebug() << "✓ Graph loaded successfully in" << elapsed << "ms";
        
        // DEBUGGING: Detailed count verification
        int nodeCount = m_scene->getNodes().size();
        int edgeCount = m_scene->getEdges().size();
        qDebug() << "DEBUG: Hash container sizes:";
        qDebug() << "  m_scene->getNodes().size() =" << nodeCount;
        qDebug() << "  m_scene->getEdges().size() =" << edgeCount;
        qDebug() << "  Qt scene items count:" << m_scene->items().size();
        qDebug() << "  Current file set to:" << m_currentFile;
        
        QMessageBox::information(this, "Load Complete", 
            QString("Graph loaded successfully!\n\nFile: %1\nNodes: %2\nEdges: %3\nTime: %4ms\n\nCtrl+S will now save to this file.")
            .arg(QFileInfo(filename).fileName())
            .arg(nodeCount)
            .arg(edgeCount)
            .arg(elapsed));
        return true;
    } else {
        qDebug() << "✗ Failed to load graph";
        QMessageBox::critical(this, "Load Error", 
            QString("Failed to load graph from file.\n\nFile: %1")
            .arg(QFileInfo(filename).fileName()));
        return false;
    }
}

void Window::createInputNode()
{
    // Find a nice position in the view center
    QPointF viewCenter = m_view->mapToScene(m_view->viewport()->rect().center());
    
    // Add some randomization so multiple nodes don't overlap
    qreal randomX = QRandomGenerator::global()->bounded(-50, 50);
    qreal randomY = QRandomGenerator::global()->bounded(-50, 50);
    QPointF position = viewCenter + QPointF(randomX, randomY);
    
    // Create input node using factory (XML-first approach)
    Node* node = m_factory->createNode("IN", position, 0, 2);  // 0 inputs, 2 outputs
    
    if (node) {
        qDebug() << "✓ Created input node at" << position;
    } else {
        qDebug() << "✗ Failed to create input node";
    }
}

void Window::createOutputNode()
{
    // Find a nice position in the view center
    QPointF viewCenter = m_view->mapToScene(m_view->viewport()->rect().center());
    
    // Add some randomization so multiple nodes don't overlap
    qreal randomX = QRandomGenerator::global()->bounded(-50, 50);
    qreal randomY = QRandomGenerator::global()->bounded(-50, 50);
    QPointF position = viewCenter + QPointF(randomX, randomY);
    
    // Create output node using factory (XML-first approach)
    Node* node = m_factory->createNode("OUT", position, 2, 0);  // 2 inputs, 0 outputs
    
    if (node) {
        qDebug() << "✓ Created output node at" << position;
    } else {
        qDebug() << "✗ Failed to create output node";
    }
}

void Window::createProcessorNode()
{
    // Find a nice position in the view center
    QPointF viewCenter = m_view->mapToScene(m_view->viewport()->rect().center());
    
    // Add some randomization so multiple nodes don't overlap
    qreal randomX = QRandomGenerator::global()->bounded(-50, 50);
    qreal randomY = QRandomGenerator::global()->bounded(-50, 50);
    QPointF position = viewCenter + QPointF(randomX, randomY);
    
    // Create processor node using factory (XML-first approach)
    Node* node = m_factory->createNode("PROC", position, 2, 2);  // 2 inputs, 2 outputs
    
    if (node) {
        qDebug() << "✓ Created processor node at" << position;
    } else {
        qDebug() << "✗ Failed to create processor node";
    }
}

void Window::createNodeFromPalette(const QPointF& scenePos, const QString& nodeType, 
                                  const QString& name, int inputSockets, int outputSockets)
{
    qDebug() << "========================================";
    qDebug() << "Window: RECEIVED nodeDropped signal";
    qDebug() << "Window: Creating node from palette:";
    qDebug() << "  - Name:" << name;
    qDebug() << "  - Type:" << nodeType;
    qDebug() << "  - Position:" << scenePos;
    qDebug() << "  - Input sockets:" << inputSockets;
    qDebug() << "  - Output sockets:" << outputSockets;
    qDebug() << "Window: Calling factory->createNode()";
    
    // Create node using factory with the exact specifications from the palette
    Node* node = m_factory->createNode(nodeType, scenePos, inputSockets, outputSockets);
    
    if (node) {
        qDebug() << "✓ Window: Factory successfully created" << name << "node";
        qDebug() << "Window: Node created at scene position:" << scenePos;
        qDebug() << "Window: Updating status bar";
        
        // Update status bar to reflect the new node
        updateStatusBar();
        statusBar()->showMessage(QString("Created %1 node").arg(name), 2000);
        
        qDebug() << "✓ Window: Node creation process completed successfully";
    } else {
        qDebug() << "✗ Window: Factory FAILED to create" << name << "node";
        qDebug() << "Window: This may indicate factory or scene issues";
        statusBar()->showMessage(QString("Failed to create %1 node").arg(name), 3000);
    }
    qDebug() << "========================================";
}

// ============================================================================
// Enhanced UI Implementation - Lookatme + Inkscape Status Bar Patterns
// ============================================================================

void Window::setupUI()
{
    setCentralWidget(m_view);
    
    // Set application icon and improve window appearance
    setWindowIcon(QIcon(":/icons/app-icon.png")); // Optional - if you have icons
    
    // Enable dock widget features
    setDockOptions(QMainWindow::AllowNestedDocks | 
                   QMainWindow::AllowTabbedDocks | 
                   QMainWindow::AnimatedDocks);
}

void Window::setupMenus()
{
    createFileMenu();
    createEditMenu();
    createViewMenu();
    createToolsMenu();
    createHelpMenu();
}

void Window::createFileMenu()
{
    m_fileMenu = menuBar()->addMenu("&File");
    
    // New file
    QAction* newAction = new QAction("&New", this);
    newAction->setShortcut(QKeySequence::New);
    newAction->setStatusTip("Create a new graph");
    connect(newAction, &QAction::triggered, this, &Window::newFile);
    m_fileMenu->addAction(newAction);
    
    // Open file
    QAction* openAction = new QAction("&Open...", this);
    openAction->setShortcut(QKeySequence::Open);
    openAction->setStatusTip("Open an existing graph");
    connect(openAction, &QAction::triggered, this, &Window::openFile);
    m_fileMenu->addAction(openAction);
    
    m_fileMenu->addSeparator();
    
    // Save file
    QAction* saveAction = new QAction("&Save", this);
    saveAction->setShortcut(QKeySequence::Save);
    saveAction->setStatusTip("Save the current graph");
    connect(saveAction, &QAction::triggered, this, &Window::saveFile);
    m_fileMenu->addAction(saveAction);
    
    // Save As
    QAction* saveAsAction = new QAction("Save &As...", this);
    saveAsAction->setShortcut(QKeySequence::SaveAs);
    saveAsAction->setStatusTip("Save the graph with a new name");
    connect(saveAsAction, &QAction::triggered, this, &Window::saveAsFile);
    m_fileMenu->addAction(saveAsAction);
    
    m_fileMenu->addSeparator();
    
    // Export
    QAction* exportAction = new QAction("&Export...", this);
    exportAction->setStatusTip("Export graph to various formats");
    connect(exportAction, &QAction::triggered, this, &Window::exportGraph);
    m_fileMenu->addAction(exportAction);
    
    m_fileMenu->addSeparator();
    
    // Exit
    QAction* exitAction = new QAction("E&xit", this);
    exitAction->setShortcut(QKeySequence::Quit);
    exitAction->setStatusTip("Exit the application");
    connect(exitAction, &QAction::triggered, this, &QWidget::close);
    m_fileMenu->addAction(exitAction);
}

void Window::createEditMenu()
{
    m_editMenu = menuBar()->addMenu("&Edit");
    
    // Undo/Redo placeholders for future implementation
    QAction* undoAction = new QAction("&Undo", this);
    undoAction->setShortcut(QKeySequence::Undo);
    undoAction->setEnabled(false); // TODO: Implement undo system
    m_editMenu->addAction(undoAction);
    
    QAction* redoAction = new QAction("&Redo", this);
    redoAction->setShortcut(QKeySequence::Redo);
    redoAction->setEnabled(false); // TODO: Implement redo system
    m_editMenu->addAction(redoAction);
    
    m_editMenu->addSeparator();
    
    // Selection operations
    QAction* selectAllAction = new QAction("Select &All", this);
    selectAllAction->setShortcut(QKeySequence::SelectAll);
    selectAllAction->setStatusTip("Select all nodes and edges");
    m_editMenu->addAction(selectAllAction);
    
    QAction* deselectAction = new QAction("&Deselect All", this);
    deselectAction->setShortcut(QKeySequence("Ctrl+D"));
    deselectAction->setStatusTip("Clear selection");
    m_editMenu->addAction(deselectAction);
    
    m_editMenu->addSeparator();
    
    // Delete
    QAction* deleteAction = new QAction("&Delete Selected", this);
    deleteAction->setShortcut(QKeySequence::Delete);
    deleteAction->setStatusTip("Delete selected nodes and edges");
    m_editMenu->addAction(deleteAction);
}

void Window::createViewMenu()
{
    m_viewMenu = menuBar()->addMenu("&View");
    
    // Zoom operations
    QAction* zoomInAction = new QAction("Zoom &In", this);
    zoomInAction->setShortcut(QKeySequence::ZoomIn);
    zoomInAction->setStatusTip("Zoom in to the graph");
    connect(zoomInAction, &QAction::triggered, this, &Window::zoomIn);
    m_viewMenu->addAction(zoomInAction);
    
    QAction* zoomOutAction = new QAction("Zoom &Out", this);
    zoomOutAction->setShortcut(QKeySequence::ZoomOut);
    zoomOutAction->setStatusTip("Zoom out from the graph");
    connect(zoomOutAction, &QAction::triggered, this, &Window::zoomOut);
    m_viewMenu->addAction(zoomOutAction);
    
    QAction* zoomFitAction = new QAction("Zoom to &Fit", this);
    zoomFitAction->setShortcut(QKeySequence("Ctrl+0"));
    zoomFitAction->setStatusTip("Fit entire graph in view");
    connect(zoomFitAction, &QAction::triggered, this, &Window::zoomFit);
    m_viewMenu->addAction(zoomFitAction);
    
    QAction* zoomResetAction = new QAction("&Reset Zoom", this);
    zoomResetAction->setShortcut(QKeySequence("Ctrl+1"));
    zoomResetAction->setStatusTip("Reset zoom to 100%");
    connect(zoomResetAction, &QAction::triggered, this, &Window::zoomReset);
    m_viewMenu->addAction(zoomResetAction);
    
    m_viewMenu->addSeparator();
    
    // Dock widget toggles will be added after dock widgets are created
}

void Window::createToolsMenu()
{
    m_toolsMenu = menuBar()->addMenu("&Tools");
    
    // Node creation submenu
    QMenu* createNodeMenu = m_toolsMenu->addMenu("&Create Node");
    createNodeMenu->addAction(m_addInputAction);
    createNodeMenu->addAction(m_addOutputAction);
    createNodeMenu->addAction(m_addProcessorAction);
    
    m_toolsMenu->addSeparator();
    
    QAction* validateAction = new QAction("&Validate Graph", this);
    validateAction->setStatusTip("Check graph for errors and inconsistencies");
    m_toolsMenu->addAction(validateAction);
    
    QAction* statisticsAction = new QAction("Graph &Statistics", this);
    statisticsAction->setStatusTip("Show detailed graph statistics");
    m_toolsMenu->addAction(statisticsAction);
    
    // JavaScript test runner
    m_toolsMenu->addSeparator();
    QAction* jsTestAction = new QAction("🧪 Run &JavaScript Tests", this);
    jsTestAction->setStatusTip("Run embedded JavaScript test suite");
    jsTestAction->setShortcut(QKeySequence("Ctrl+J"));
    connect(jsTestAction, &QAction::triggered, this, &Window::runJavaScriptTests);
    m_toolsMenu->addAction(jsTestAction);
    
    // Simple script execution
    QAction* jsScriptAction = new QAction("📝 Load &Script", this);
    jsScriptAction->setStatusTip("Load and execute JavaScript script");
    jsScriptAction->setShortcut(QKeySequence("Ctrl+Shift+L"));
    connect(jsScriptAction, &QAction::triggered, this, &Window::loadAndExecuteScript);
    m_toolsMenu->addAction(jsScriptAction);
    
    // Quick test script menu
    QMenu* testScriptsMenu = m_toolsMenu->addMenu("Quick Tests");
    testScriptsMenu->setStatusTip("Run predefined test scripts");
    
    QAction* paletteTestAction = new QAction("Palette System Test", this);
    paletteTestAction->setStatusTip("Test all 5 palette node types");
    connect(paletteTestAction, &QAction::triggered, [this]() { runSpecificScript("scripts/test_palette_system.js"); });
    testScriptsMenu->addAction(paletteTestAction);
    
    QAction* dragDropTestAction = new QAction("Drag-Drop Simulation", this);
    dragDropTestAction->setStatusTip("Test drag and drop from palette to scene");
    connect(dragDropTestAction, &QAction::triggered, [this]() { runSpecificScript("scripts/test_drag_drop_simulation.js"); });
    testScriptsMenu->addAction(dragDropTestAction);
    
    QAction* uiTestAction = new QAction("UI Interactions Test", this);
    uiTestAction->setStatusTip("Test UI interaction simulations");
    connect(uiTestAction, &QAction::triggered, [this]() { runSpecificScript("scripts/test_ui_interactions.js"); });
    testScriptsMenu->addAction(uiTestAction);
    
    QAction* performanceTestAction = new QAction("Performance & Stress Test", this);
    performanceTestAction->setStatusTip("Test system performance with large graphs");
    connect(performanceTestAction, &QAction::triggered, [this]() { runSpecificScript("scripts/test_performance.js"); });
    testScriptsMenu->addAction(performanceTestAction);
    
    testScriptsMenu->addSeparator();
    QAction* destructorSafetyAction = new QAction("Destructor Safety Test", this);
    destructorSafetyAction->setStatusTip("Test crash prevention during object destruction");
    connect(destructorSafetyAction, &QAction::triggered, [this]() { runSpecificScript("scripts/test_destructor_safety.js"); });
    testScriptsMenu->addAction(destructorSafetyAction);
    
    QAction* debugApiAction = new QAction("Debug Graph API", this);
    debugApiAction->setStatusTip("Debug Graph API availability and functionality");
    connect(debugApiAction, &QAction::triggered, [this]() { runSpecificScript("scripts/debug_graph_api.js"); });
    testScriptsMenu->addAction(debugApiAction);
    
    QAction* nodeTypesAction = new QAction("Test Node Types", this);
    nodeTypesAction->setStatusTip("Test all registered node types");
    connect(nodeTypesAction, &QAction::triggered, [this]() { runSpecificScript("scripts/test_node_types.js"); });
    testScriptsMenu->addAction(nodeTypesAction);
    
    QAction* simpleGraphAction = new QAction("Simple Graph Test", this);
    simpleGraphAction->setStatusTip("Create a basic three-node connected graph");
    connect(simpleGraphAction, &QAction::triggered, [this]() { runSpecificScript("scripts/simple_graph.js"); });
    testScriptsMenu->addAction(simpleGraphAction);
    
    QAction* layoutDemoAction = new QAction("Node Layout Demo", this);
    layoutDemoAction->setStatusTip("Demonstrate different node positioning strategies");
    connect(layoutDemoAction, &QAction::triggered, [this]() { runSpecificScript("scripts/demo_node_layout.js"); });
    testScriptsMenu->addAction(layoutDemoAction);
    
    testScriptsMenu->addSeparator();
    QAction* runAllTestsAction = new QAction("Run All Tests", this);
    runAllTestsAction->setStatusTip("Run all test scripts sequentially");
    connect(runAllTestsAction, &QAction::triggered, this, &Window::runAllTests);
    testScriptsMenu->addAction(runAllTestsAction);
}

void Window::createHelpMenu()
{
    m_helpMenu = menuBar()->addMenu("&Help");
    
    QAction* aboutAction = new QAction("&About", this);
    aboutAction->setStatusTip("About this application");
    connect(aboutAction, &QAction::triggered, this, &Window::showAbout);
    m_helpMenu->addAction(aboutAction);
    
    QAction* aboutQtAction = new QAction("About &Qt", this);
    aboutQtAction->setStatusTip("About Qt Framework");
    connect(aboutQtAction, &QAction::triggered, qApp, &QApplication::aboutQt);
    m_helpMenu->addAction(aboutQtAction);
}

void Window::setupStatusBar()
{
    createStatusBarWidgets();
    connectStatusBarSignals();
}

void Window::createStatusBarWidgets()
{
    QStatusBar* statusBar = this->statusBar();
    statusBar->setStyleSheet(
        "QStatusBar {"
        "  border-top: 1px solid #bdc3c7;"
        "  background: #ecf0f1;"
        "}"
        "QStatusBar::item {"
        "  border: none;"
        "}"
    );
    
    // File info (leftmost)
    m_fileInfoLabel = new QLabel("No file loaded");
    m_fileInfoLabel->setStyleSheet("QLabel { color: #2c3e50; margin-right: 15px; }");
    statusBar->addWidget(m_fileInfoLabel);
    
    // Graph statistics
    m_graphStatsLabel = new QLabel("Nodes: 0 | Edges: 0");
    m_graphStatsLabel->setStyleSheet("QLabel { color: #27ae60; font-weight: bold; margin-right: 15px; }");
    statusBar->addWidget(m_graphStatsLabel);
    
    // Selection info
    m_selectionLabel = new QLabel("No selection");
    m_selectionLabel->setStyleSheet("QLabel { color: #8e44ad; margin-right: 15px; }");
    statusBar->addWidget(m_selectionLabel);
    
    // Add stretch to push remaining widgets to the right
    statusBar->addPermanentWidget(new QWidget(), 1);
    
    // Mouse position (right side)
    m_positionLabel = new QLabel("Position: (0, 0)");
    m_positionLabel->setStyleSheet("QLabel { color: #34495e; margin-right: 10px; }");
    statusBar->addPermanentWidget(m_positionLabel);
    
    // Zoom level (rightmost)
    m_zoomLabel = new QLabel("Zoom: 100%");
    m_zoomLabel->setStyleSheet("QLabel { color: #e74c3c; font-weight: bold; }");
    statusBar->addPermanentWidget(m_zoomLabel);
    
    // Operation progress (hidden by default)
    m_operationProgress = new QProgressBar();
    m_operationProgress->setVisible(false);
    m_operationProgress->setMaximumWidth(200);
    statusBar->addPermanentWidget(m_operationProgress);
}

void Window::connectStatusBarSignals()
{
    // Update status bar when scene changes
    connect(m_scene, &Scene::sceneChanged, this, &Window::updateStatusBar);
    
    // TODO: Connect view signals for mouse position and zoom updates
    // This would require extending the View class to emit these signals
}

void Window::setupDockWidgets()
{
    // Create node palette dock widget
    m_nodePaletteDock = new QDockWidget("Node Palette", this);
    m_nodePaletteDock->setAllowedAreas(Qt::LeftDockWidgetArea | Qt::RightDockWidgetArea);
    m_nodePaletteDock->setFeatures(QDockWidget::DockWidgetMovable | QDockWidget::DockWidgetFloatable);
    
    // Create palette widget
    m_nodePalette = new NodePaletteWidget();
    m_nodePaletteDock->setWidget(m_nodePalette);
    
    // Add dock widget to left side
    addDockWidget(Qt::LeftDockWidgetArea, m_nodePaletteDock);
    
    // Connect palette signals
    connect(m_nodePalette, &NodePaletteWidget::nodeCreationRequested, 
            this, &Window::onNodeCreationRequested);
    
}

void Window::updateStatusBar()
{
    if (!m_scene) return;
    
    // Update graph statistics
    int nodeCount = m_scene->getNodes().size();
    int edgeCount = m_scene->getEdges().size();
    m_graphStatsLabel->setText(QString("Nodes: %1 | Edges: %2").arg(nodeCount).arg(edgeCount));
    
    // Update file info
    if (m_currentFile.isEmpty()) {
        m_fileInfoLabel->setText("No file loaded");
    } else {
        QFileInfo fileInfo(m_currentFile);
        m_fileInfoLabel->setText(QString("File: %1").arg(fileInfo.fileName()));
    }
    
    // Update selection info (placeholder for now)
    QList<QGraphicsItem*> selectedItems = m_scene->selectedItems();
    if (selectedItems.isEmpty()) {
        m_selectionLabel->setText("No selection");
    } else {
        m_selectionLabel->setText(QString("Selected: %1 items").arg(selectedItems.size()));
    }
}

// ============================================================================
// Slot Implementations
// ============================================================================

void Window::onSceneChanged()
{
    updateStatusBar();
}

void Window::onSelectionChanged()
{
    updateSelectionInfo();
}

void Window::updateSelectionInfo()
{
    if (!m_scene) return;
    
    QList<QGraphicsItem*> selectedItems = m_scene->selectedItems();
    if (selectedItems.isEmpty()) {
        m_selectionLabel->setText("No selection");
    } else {
        int nodeCount = 0;
        int edgeCount = 0;
        
        for (QGraphicsItem* item : selectedItems) {
            if (qgraphicsitem_cast<Node*>(item)) {
                nodeCount++;
            } else if (qgraphicsitem_cast<Edge*>(item)) {
                edgeCount++;
            }
        }
        
        QString selectionText;
        if (nodeCount > 0 && edgeCount > 0) {
            selectionText = QString("Selected: %1 nodes, %2 edges").arg(nodeCount).arg(edgeCount);
        } else if (nodeCount > 0) {
            selectionText = QString("Selected: %1 nodes").arg(nodeCount);
        } else if (edgeCount > 0) {
            selectionText = QString("Selected: %1 edges").arg(edgeCount);
        }
        
        m_selectionLabel->setText(selectionText);
    }
}

// ============================================================================
// Menu Action Implementations (Placeholders)
// ============================================================================

void Window::newFile()
{
    // TODO: Clear current scene and reset
    qDebug() << "🆕 New file requested";
}

void Window::openFile()
{
    qDebug() << "=== FILE OPEN DIALOG ===";
    QString fileName = QFileDialog::getOpenFileName(this, "Open Graph", "", "XML Files (*.xml)");
    if (!fileName.isEmpty()) {
        qDebug() << "File selected:" << fileName;
        if (loadGraph(fileName)) {
            setCurrentFile(fileName);
            updateStatusBar();
            qDebug() << "File loaded successfully";
        } else {
            qDebug() << "File load FAILED";
        }
    } else {
        qDebug() << "File dialog cancelled";
    }
}

void Window::saveFile()
{
    qDebug() << "=== CTRL+S SAVE TRIGGERED ===";
    qDebug() << "Current file:" << (m_currentFile.isEmpty() ? "NONE (will show Save As dialog)" : m_currentFile);
    
    if (m_currentFile.isEmpty()) {
        qDebug() << "No current file - opening Save As dialog...";
        saveAsFile();
    } else {
        qDebug() << "Saving to current file:" << m_currentFile;
        if (saveGraph(m_currentFile)) {
            qDebug() << "✓ Save successful";
            updateStatusBar();
        } else {
            qDebug() << "✗ Save FAILED";
        }
    }
}

void Window::saveAsFile()
{
    QString fileName = QFileDialog::getSaveFileName(this, "Save Graph", "", "XML Files (*.xml)");
    if (!fileName.isEmpty()) {
        if (saveGraph(fileName)) {
            setCurrentFile(fileName);
            updateStatusBar();
        }
    }
}

void Window::exportGraph()
{
    // TODO: Implement export functionality
    QMessageBox::information(this, "Export", "Export functionality will be implemented in a future update.");
}

void Window::showAbout()
{
    QMessageBox::about(this, "About NodeGraph",
        "<h3>NodeGraph - Self-Serializing Node Editor</h3>"
        "<p>A professional node-based graph editor with self-serializing architecture.</p>"
        "<p><b>Features:</b></p>"
        "<ul>"
        "<li>Self-serializing nodes with libxml2 backend</li>"
        "<li>Observer pattern with automatic XML persistence</li>"
        "<li>Professional UI with docking panels</li>"
        "<li>Enhanced visual selection highlighting</li>"
        "<li>Drag-and-drop node creation</li>"
        "</ul>"
        "<p>Built with Qt5 and modern C++ patterns.</p>");
}

void Window::zoomIn()
{
    m_view->scale(1.2, 1.2);
    // TODO: Update zoom label
}

void Window::zoomOut()
{
    m_view->scale(0.8, 0.8);
    // TODO: Update zoom label
}

void Window::zoomFit()
{
    m_view->fitInView(m_scene->itemsBoundingRect(), Qt::KeepAspectRatio);
    // TODO: Update zoom label
}

void Window::zoomReset()
{
    m_view->resetTransform();
    // TODO: Update zoom label
}

/*
void Window::createNodeAtPosition(const QString& nodeType, const QPointF& scenePos)
{
    // Drag-and-drop node creation disabled for now
    // Focus on JavaScript integration
}
*/

// ============================================================================
// PHASE 3: Safe Shutdown Coordination
// ============================================================================

void Window::closeEvent(QCloseEvent* event)
{
    qDebug() << "PHASE1: Window shutdown initiated";
    
    // PHASE 1.2: Prepare scene for safe shutdown
    if (m_scene) {
        m_scene->prepareForShutdown();
    }
    
    // Accept the close event (no dirty state tracking yet)
    QMainWindow::closeEvent(event);
    
    qDebug() << "PHASE1: ✓ Window shutdown complete";
}

void Window::runJavaScriptTests()
{
    qDebug() << "Window: Running JavaScript test suite";
    
    // Initialize JavaScript engine with GraphController
    auto* jsEngine = m_scene->getJavaScriptEngine();
    if (!jsEngine) {
        QMessageBox::warning(this, "JavaScript Error", "JavaScript engine not initialized");
        return;
    }
    
    // Register GraphController if not already done
    jsEngine->registerGraphController(m_scene, m_factory);
    
    // Show status message
    statusBar()->showMessage("Running JavaScript tests...", 2000);
    
    // Run the basic test suite
    QString testScript = R"(
        console.log("=== Starting JavaScript Test Suite ===");
        
        // Test 1: Basic graph creation
        try {
            console.log("Test 1: Basic graph creation");
            Graph.clear();
            let node1 = Graph.createNode("Source", 100, 100);
            let node2 = Graph.createNode("Sink", 300, 100);
            let edge = Graph.connect(node1, 0, node2, 0);
            
            let stats = Graph.getStats();
            console.log("Created graph with " + stats.nodes + " nodes and " + stats.edges + " edges");
            
            if (stats.nodes === 2 && stats.edges === 1) {
                console.log("✅ Test 1 PASSED");
            } else {
                console.log("❌ Test 1 FAILED");
            }
        } catch (e) {
            console.log("❌ Test 1 ERROR: " + e.toString());
        }
        
        // Test 2: Node deletion
        try {
            console.log("Test 2: Node deletion");
            let beforeStats = Graph.getStats();
            Graph.deleteNode(node1);
            let afterStats = Graph.getStats();
            
            if (afterStats.nodes === 1 && afterStats.edges === 0) {
                console.log("✅ Test 2 PASSED");
            } else {
                console.log("❌ Test 2 FAILED");
            }
        } catch (e) {
            console.log("❌ Test 2 ERROR: " + e.toString());
        }
        
        // Test 3: XML operations
        try {
            console.log("Test 3: XML operations");
            Graph.clear();
            let testNode = Graph.createNode("Source", 150, 150);
            
            Graph.saveXml("test_output.xml");
            let xmlString = Graph.getXmlString();
            
            if (xmlString.length > 0 && xmlString.includes('<graph')) {
                console.log("✅ Test 3 PASSED");
            } else {
                console.log("❌ Test 3 FAILED");
            }
        } catch (e) {
            console.log("❌ Test 3 ERROR: " + e.toString());
        }
        
        // Test 4: Complex graph
        try {
            console.log("Test 4: Complex graph creation");
            Graph.clear();
            
            let source = Graph.createNode("Source", 50, 100);
            let processor = Graph.createNode("1-to-2", 200, 100);
            let sink1 = Graph.createNode("Sink", 350, 50);
            let sink2 = Graph.createNode("Sink", 350, 150);
            
            Graph.connect(source, 0, processor, 0);
            Graph.connect(processor, 0, sink1, 0);
            Graph.connect(processor, 1, sink2, 0);
            
            let complexStats = Graph.getStats();
            
            if (complexStats.nodes === 4 && complexStats.edges === 3) {
                console.log("✅ Test 4 PASSED");
            } else {
                console.log("❌ Test 4 FAILED - Expected 4 nodes, 3 edges, got " + 
                           complexStats.nodes + " nodes, " + complexStats.edges + " edges");
            }
        } catch (e) {
            console.log("❌ Test 4 ERROR: " + e.toString());
        }
        
        console.log("=== JavaScript Test Suite Complete ===");
    )";
    
    // Execute the test script
    QJSValue result = jsEngine->evaluate(testScript);
    
    if (result.isError()) {
        QMessageBox::critical(this, "JavaScript Test Error", 
                             QString("Test execution failed: %1").arg(result.toString()));
    } else {
        QMessageBox::information(this, "JavaScript Tests", 
                                "Test suite completed. Check debug output for results.");
    }
    
    // Update status bar
    updateStatusBar();
}

void Window::loadAndExecuteScript()
{
    QString fileName = QFileDialog::getOpenFileName(
        this, 
        "Load JavaScript File", 
        "./scripts/", 
        "JavaScript Files (*.js);;All Files (*)"
    );
    
    if (!fileName.isEmpty()) {
        auto* jsEngine = m_scene->getJavaScriptEngine();
        
        if (!jsEngine) {
            QMessageBox::warning(this, "JavaScript Error", "JavaScript engine not initialized");
            return;
        }
        
        // Test engine functionality
        QJSValue quickTest = jsEngine->evaluate("1 + 1");
        if (quickTest.isError()) {
            QMessageBox::warning(this, "JavaScript Error", "JavaScript engine is not functional");
            return;
        }
        
        // Register GraphController if not already done
        jsEngine->registerGraphController(m_scene, m_factory);
        
        QJSValue result = jsEngine->evaluateFile(fileName);
        
        if (result.isError()) {
            QMessageBox::critical(this, "Script Error", 
                                 QString("Script execution failed: %1").arg(result.toString()));
        } else {
            QString resultText = result.isUndefined() ? "Script executed successfully" : result.toString();
            QMessageBox::information(this, "Script Executed", 
                                   QString("Script completed: %1").arg(resultText));
        }
        
        updateStatusBar();
    }
}

void Window::runSpecificScript(const QString& filePath)
{
    auto* jsEngine = m_scene->getJavaScriptEngine();
    
    if (!jsEngine) {
        QMessageBox::warning(this, "JavaScript Error", "JavaScript engine not initialized");
        return;
    }
    
    // Test engine functionality
    QJSValue quickTest = jsEngine->evaluate("1 + 1");
    if (quickTest.isError()) {
        QMessageBox::warning(this, "JavaScript Error", "JavaScript engine is not functional");
        return;
    }
    
    // Register GraphController if not already done
    qDebug() << "Registering GraphController with scene:" << m_scene << "factory:" << m_factory;
    jsEngine->registerGraphController(m_scene, m_factory);
    qDebug() << "GraphController registration completed";
    
    // Show which test is running
    QFileInfo fileInfo(filePath);
    statusBar()->showMessage(QString("Running %1...").arg(fileInfo.baseName()), 3000);
    
    // Log script execution details
    qDebug() << "=== SCRIPT EXECUTION START ===";
    qDebug() << "Script file:" << filePath;
    qDebug() << "Script name:" << fileInfo.baseName();
    qDebug() << "Executed by: Window::runSpecificScript()";
    qDebug() << "===================================";
    
    QJSValue result = jsEngine->evaluateFile(filePath);
    
    // Log script completion details
    qDebug() << "=== SCRIPT EXECUTION END ===";
    qDebug() << "Script name:" << fileInfo.baseName();
    if (result.isError()) {
        qDebug() << "Result: ERROR -" << result.toString();
        QMessageBox::critical(this, "Script Error", 
                             QString("Script execution failed: %1").arg(result.toString()));
    } else {
        QString resultText = result.isUndefined() ? "Test completed successfully" : result.toString();
        qDebug() << "Result: SUCCESS -" << resultText;
        QMessageBox::information(this, "Test Results", 
                               QString("%1: %2").arg(fileInfo.baseName(), resultText));
    }
    qDebug() << "=================================";
    
    updateStatusBar();
}

void Window::runAllTests()
{
    QStringList testScripts = {
        "scripts/test_palette_system.js",
        "scripts/test_drag_drop_simulation.js", 
        "scripts/test_ui_interactions.js",
        "scripts/test_performance.js"
    };
    
    auto* jsEngine = m_scene->getJavaScriptEngine();
    
    if (!jsEngine) {
        QMessageBox::warning(this, "JavaScript Error", "JavaScript engine not initialized");
        return;
    }
    
    // Test engine functionality
    QJSValue quickTest = jsEngine->evaluate("1 + 1");
    if (quickTest.isError()) {
        QMessageBox::warning(this, "JavaScript Error", "JavaScript engine is not functional");
        return;
    }
    
    // Register GraphController if not already done
    jsEngine->registerGraphController(m_scene, m_factory);
    
    statusBar()->showMessage("Running all test scripts...", 5000);
    
    int passedTests = 0;
    int totalTests = testScripts.size();
    QStringList results;
    
    for (int i = 0; i < testScripts.size(); i++) {
        const QString& scriptPath = testScripts[i];
        QFileInfo fileInfo(scriptPath);
        
        statusBar()->showMessage(QString("Running test %1/%2: %3...").arg(i + 1).arg(totalTests).arg(fileInfo.baseName()), 2000);
        
        QJSValue result = jsEngine->evaluateFile(scriptPath);
        
        if (result.isError()) {
            results.append(QString("❌ %1: FAILED - %2").arg(fileInfo.baseName(), result.toString()));
        } else {
            results.append(QString("✅ %1: PASSED").arg(fileInfo.baseName()));
            passedTests++;
        }
        
        // Clear graph between tests to prevent interference
        QString clearScript = "Graph.clear();";
        jsEngine->evaluate(clearScript);
    }
    
    QString summary = QString("Test Results: %1/%2 passed\n\n%3")
                     .arg(passedTests)
                     .arg(totalTests)
                     .arg(results.join("\n"));
    
    QMessageBox::information(this, "All Tests Complete", summary);
    
    statusBar()->showMessage(QString("Tests complete: %1/%2 passed").arg(passedTests).arg(totalTests), 3000);
    updateStatusBar();
}

void Window::onNodeCreationRequested()
{
    // The signal includes the nodeTemplate, but we need to handle it via sender() for now
    // due to header file forward declaration limitations
    
    // For double-click from palette, create node at center of view
    QPointF centerPoint = m_view->mapToScene(m_view->rect().center());
    
    // We'll implement drag-and-drop separately - for now just handle the signal connection
    
    // Create a default input node for testing
    createNodeFromPalette(centerPoint, "IN", "Input", 0, 2);
}



=== scene.cpp ===
#include "scene.h"
#include "node.h"
#include "edge.h"
#include "socket.h"
#include "javascript_engine.h"
#include "ghost_edge.h"
#include <QDebug>
#include <QTimer>
#include <QGraphicsPathItem>

Scene::Scene(QObject* parent)
    : QGraphicsScene(parent)
    , m_ghostEdge(nullptr)
    , m_ghostFromSocket(nullptr)
    , m_ghostEdgeActive(false)
    , m_shutdownInProgress(false)
    , m_jsEngine(new JavaScriptEngine(this))
{
    setSceneRect(-1000, -1000, 2000, 2000);
    
    // Initialize JavaScript engine with this scene
    if (m_jsEngine) {
        m_jsEngine->registerNodeAPI(this);
        m_jsEngine->registerGraphAPI();
        // GraphController will be registered when GraphFactory is available
    }
}

// QElectroTech-style QHash implementation with SIMPLE_FIX logging
void Scene::addNode(Node* node)
{
    if (!node) return;
    
    QUuid nodeId = node->getId();
    m_nodes.insert(nodeId, node);
    addItem(node);
    
    qDebug() << "+" << nodeId.toString(QUuid::WithoutBraces).left(8);
    
    // Notify observers of node addition
    notifyNodeAdded(*node);
    
    // Emit signal for UI updates
    emit sceneChanged();
}

void Scene::addEdge(Edge* edge)
{
    if (!edge) return;
    
    QUuid edgeId = edge->getId();
    m_edges.insert(edgeId, edge);
    addItem(edge);
    
    qDebug() << "+" << edgeId.toString(QUuid::WithoutBraces).left(8);
    
    // Notify observers of edge addition
    notifyEdgeAdded(*edge);
    
    // Emit signal for UI updates
    emit sceneChanged();
    
    // Clean design: edges manage their own socket connections via resolveConnections()
}

void Scene::addSocket(Socket* socket)
{
    if (!socket) return;
    
    // Clean design: sockets are managed by their parent nodes, not scene
    // Socket is automatically added to scene as child of parent node
}

void Scene::removeNode(const QUuid& nodeId)
{
    Node* node = m_nodes.value(nodeId, nullptr);
    if (!node) return;
    
    // Clean design: sockets are children of nodes - no separate tracking needed
    
    // Remove connected edges that reference this node
    QList<QUuid> edgesToRemove;
    QString nodeIdStr = nodeId.toString();
    for (Edge* edge : m_edges.values()) {
        if (edge->isConnectedToNode(nodeIdStr)) {
            edgesToRemove.append(edge->getId());
        }
    }
    
    // Clean up edges first (they may reference sockets)
    for (const QUuid& edgeId : edgesToRemove) {
        removeEdge(edgeId);
    }
    
    // Clean design: sockets cleaned up automatically as node children
    
    // Finally remove the node
    removeItem(node);
    m_nodes.remove(nodeId);
    delete node;
}

void Scene::removeEdge(const QUuid& edgeId)
{
    Edge* edge = m_edges.value(edgeId, nullptr);
    if (!edge) return;
    
    // Clean design: edges manage their own socket disconnection via direct pointers
    // Socket cleanup handled automatically when edge is destroyed
    
    // Remove from scene and registry
    removeItem(edge);
    m_edges.remove(edgeId);
    delete edge;
}

// Clean design: socket management methods removed - sockets handled by parent nodes

// O(1) UUID lookups
Node* Scene::getNode(const QUuid& nodeId) const
{
    return m_nodes.value(nodeId, nullptr);
}

Edge* Scene::getEdge(const QUuid& edgeId) const
{
    return m_edges.value(edgeId, nullptr);
}

void Scene::deleteNode(const QUuid& nodeId)
{
    Node* node = getNode(nodeId);
    if (!node) {
        qWarning() << "Scene::deleteNode - node not found:" << nodeId.toString(QUuid::WithoutBraces).left(8);
        return;
    }
    
    qDebug() << "Deleting node:" << nodeId.toString(QUuid::WithoutBraces).left(8);
    
    // First, find and delete all edges connected to this node
    QList<QUuid> edgesToDelete;
    for (auto it = m_edges.begin(); it != m_edges.end(); ++it) {
        Edge* edge = it.value();
        if (edge->isConnectedToNode(nodeId)) {
            edgesToDelete.append(it.key());
        }
    }
    
    // Delete connected edges
    for (const QUuid& edgeId : edgesToDelete) {
        deleteEdge(edgeId);
    }
    
    // Remove node from collections and scene
    m_nodes.remove(nodeId);
    removeItem(node);
    
    // Notify observers BEFORE deleting the node
    notifyNodeRemoved(nodeId);
    
    delete node;
    
    // Emit signal for UI updates
    emit sceneChanged();
    
    qDebug() << "Node deleted with" << edgesToDelete.size() << "connected edges - Observer notified";
}

void Scene::deleteEdge(const QUuid& edgeId)
{
    Edge* edge = getEdge(edgeId);
    if (!edge) {
        qWarning() << "Scene::deleteEdge - edge not found:" << edgeId.toString(QUuid::WithoutBraces).left(8);
        return;
    }
    
    qDebug() << "Deleting edge:" << edgeId.toString(QUuid::WithoutBraces).left(8);
    
    // Remove from collection and scene
    m_edges.remove(edgeId);
    removeItem(edge);
    
    // Notify observers BEFORE deleting the edge
    notifyEdgeRemoved(edgeId);
    
    delete edge;
    
    // Emit signal for UI updates
    emit sceneChanged();
    
    qDebug() << "Edge deleted - Observer notified";
}

void Scene::deleteSelected()
{
    QList<QGraphicsItem*> selectedItems = this->selectedItems();
    if (selectedItems.isEmpty()) {
        qDebug() << "No items selected for deletion";
        return;
    }
    
    qDebug() << "DELETE KEY: Deleting" << selectedItems.size() << "selected items";
    
    // Separate nodes and edges for proper deletion order
    QList<Node*> selectedNodes;
    QList<Edge*> selectedEdges;
    
    for (QGraphicsItem* item : selectedItems) {
        if (Node* node = qgraphicsitem_cast<Node*>(item)) {
            selectedNodes.append(node);
        } else if (Edge* edge = qgraphicsitem_cast<Edge*>(item)) {
            selectedEdges.append(edge);
        }
    }
    
    // Delete selected edges first
    for (Edge* edge : selectedEdges) {
        deleteEdge(edge->getId());
    }
    
    // Then delete selected nodes (which will delete their remaining edges)
    for (Node* node : selectedNodes) {
        deleteNode(node->getId());
    }
    
    // Emit signal for UI updates
    emit sceneChanged();
    
    qDebug() << "DELETE COMPLETE: Deleted" << selectedEdges.size() << "edges and" << selectedNodes.size() << "nodes - Observers notified";
}

void Scene::clearGraph()
{
    qDebug() << "SIMPLE_FIX: Clearing graph - removing" << m_nodes.size() << "nodes and" << m_edges.size() << "edges";
    
    // SIMPLE FIX: Clear registries FIRST to prevent dangling pointers
    // This prevents hash lookups during Qt's destruction sequence
    qDebug() << "SIMPLE_FIX: Clearing hash registries first";
    m_nodes.clear();
    m_edges.clear();
    m_sockets.clear();  // Clear deprecated socket registry too
    
    // Then clear Qt graphics scene (safe now - no hash references)
    qDebug() << "SIMPLE_FIX: Clearing Qt scene items";
    QGraphicsScene::clear();
    
    // Notify observers of graph clearing
    notifyGraphCleared();
    
    // Emit signal for UI updates
    emit sceneChanged();
    
    qDebug() << "SIMPLE_FIX: ✓ Graph cleared safely - hash cleared before Qt cleanup";
}

// ============================================================================
// PHASE 1.2: Safe Shutdown Preparation
// ============================================================================

void Scene::prepareForShutdown()
{
    if (m_shutdownInProgress) {
        qDebug() << "SHUTDOWN: Already in progress, skipping";
        return;
    }
    
    qDebug() << "PHASE1: Shutdown preparation -" << m_edges.size() << "edges," << m_nodes.size() << "nodes";
    m_shutdownInProgress = true;
    
    // Step 1: Clean edge-socket connections BEFORE any destruction
    for (Edge* edge : m_edges.values()) {
        // Note: Socket connection cleanup disabled - methods not available in current implementation
    }
    
    qDebug() << "PHASE1: ✓ Socket connections cleared safely";
}

// ============================================================================
// Ghost Edge Implementation for Right-Click Socket Connections
// ============================================================================

// IUnknown UUID for ghost edge identification
static const QUuid GHOST_EDGE_UUID = QUuid("{00000000-0000-0000-C000-000000000046}");

void Scene::startGhostEdge(Socket* fromSocket, const QPointF& startPos)
{
    if (m_ghostEdge) {
        removeItem(m_ghostEdge);
        delete m_ghostEdge;
    }
    
    m_ghostFromSocket = fromSocket;
    
    m_ghostEdge = new GhostEdge();
    m_ghostEdge->setData(0, GHOST_EDGE_UUID); // IUnknown UUID marker
    
    addItem(m_ghostEdge);
    m_ghostEdgeActive = true;
    
    // Set source socket to connecting state
    fromSocket->setConnectionState(Socket::Connecting);
    
    updateGhostEdge(startPos);
    
    qDebug() << "GHOST: Started from socket" << fromSocket->getIndex() 
             << "(" << (fromSocket->getRole() == Socket::Input ? "Input" : "Output") << ")";
}

void Scene::updateGhostEdge(const QPointF& currentPos)
{
    if (!m_ghostEdge || !m_ghostFromSocket) return;
    
    QPointF start = m_ghostFromSocket->scenePos();
    QPainterPath path;
    path.moveTo(start);
    
    // Create curved ghost edge similar to real edges
    qreal dx = currentPos.x() - start.x();
    qreal controlOffset = qMin(qAbs(dx) * 0.5, 100.0);
    
    QPointF control1 = start + QPointF(controlOffset, 0);
    QPointF control2 = currentPos - QPointF(controlOffset, 0);
    path.cubicTo(control1, control2, currentPos);
    
    // Update ghost edge visual based on target validity
    QPen ghostPenCurrent = ghostPen();
    QGraphicsItem* itemUnderCursor = itemAt(currentPos, QTransform());
    Socket* targetSocket = qgraphicsitem_cast<Socket*>(itemUnderCursor);
    
    // Reset all socket visual states to normal first
    resetAllSocketStates();
    
    if (targetSocket) {
        // Check if this is a valid connection target
        bool isValidTarget = (targetSocket->getRole() == Socket::Input && 
                            targetSocket != m_ghostFromSocket &&
                            targetSocket->getParentNode() != m_ghostFromSocket->getParentNode());
        
        if (isValidTarget) {
            targetSocket->setConnectionState(Socket::Highlighted);
            ghostPenCurrent.setColor(QColor(0, 255, 0, 180)); // Green ghost edge
        } else {
            ghostPenCurrent.setColor(QColor(255, 0, 0, 180)); // Red ghost edge
        }
    } else {
        // No socket under cursor - default ghost edge color
        ghostPenCurrent.setColor(QColor(0, 255, 0, 150)); // Default green
    }
    
    m_ghostEdge->setPath(path);
}

void Scene::resetAllSocketStates()
{
    // Reset all sockets to normal state when not being targeted
    for (Node* node : m_nodes.values()) {
        for (QGraphicsItem* child : node->childItems()) {
            if (Socket* socket = qgraphicsitem_cast<Socket*>(child)) {
                if (socket != m_ghostFromSocket) {
                    socket->updateConnectionState(); // Reset to connected/disconnected
                }
            }
        }
    }
}

void Scene::finishGhostEdge(Socket* toSocket)
{
    if (m_ghostFromSocket && toSocket) {
        // Validate connection roles
        if (m_ghostFromSocket->getRole() == Socket::Output && 
            toSocket->getRole() == Socket::Input) {
            
            // Create real edge using existing system
            Edge* newEdge = new Edge(QUuid::createUuid(), QUuid(), QUuid());
            
            Node* fromNode = m_ghostFromSocket->getParentNode();
            Node* toNode = toSocket->getParentNode();
            
            if (fromNode && toNode) {
                newEdge->setConnectionData(
                    fromNode->getId().toString(QUuid::WithoutBraces),
                    toNode->getId().toString(QUuid::WithoutBraces),
                    m_ghostFromSocket->getIndex(),
                    toSocket->getIndex()
                );
                
                addEdge(newEdge);
                newEdge->resolveConnections(this);
                
                // Brief success feedback - flash the connected sockets green (disabled)
                // m_ghostFromSocket->setVisualState(Socket::ValidTarget);
                // toSocket->setVisualState(Socket::ValidTarget);
                // QTimer::singleShot(300, [this, toSocket]() {
                //     // Reset to normal appearance after brief success flash
                //     if (m_ghostFromSocket) m_ghostFromSocket->setVisualState(Socket::Normal);
                //     toSocket->setVisualState(Socket::Normal);
                // });
                
                qDebug() << "GHOST: ✓ Created edge" << m_ghostFromSocket->getIndex() << "→" << toSocket->getIndex();
            }
        } else {
            qDebug() << "GHOST: ✗ Invalid connection - wrong socket roles";
        }
    }
    
    // Reset all socket states before canceling
    resetAllSocketStates();
    cancelGhostEdge();
}

void Scene::cancelGhostEdge()
{
    // Reset all socket visual states
    resetAllSocketStates();
    
    if (m_ghostEdge) {
        removeItem(m_ghostEdge);
        delete m_ghostEdge;
        m_ghostEdge = nullptr;
    }
    m_ghostFromSocket = nullptr;
    m_ghostEdgeActive = false;
    
    qDebug() << "GHOST: Cancelled";
}

QPen Scene::ghostPen() const
{
    QPen pen(QColor(0, 255, 0, 150)); // Semi-transparent green
    pen.setWidth(3);
    pen.setStyle(Qt::DashLine);
    pen.setDashPattern({8, 4});
    pen.setCapStyle(Qt::RoundCap);
    pen.setJoinStyle(Qt::RoundJoin);
    return pen;
}

void Scene::mouseMoveEvent(QGraphicsSceneMouseEvent* event)
{
    if (m_ghostEdgeActive) {
        updateGhostEdge(event->scenePos());
        event->accept();
        return;
    }
    QGraphicsScene::mouseMoveEvent(event);
}

void Scene::mouseReleaseEvent(QGraphicsSceneMouseEvent* event)
{
    if (m_ghostEdgeActive && event->button() == Qt::RightButton) {
        // Find socket under mouse
        QGraphicsItem* item = itemAt(event->scenePos(), QTransform());
        Socket* targetSocket = qgraphicsitem_cast<Socket*>(item);
        finishGhostEdge(targetSocket);
        event->accept();
        return;
    }
    QGraphicsScene::mouseReleaseEvent(event);
}

// JavaScript engine integration methods
QString Scene::executeJavaScript(const QString& script)
{
    if (!m_jsEngine) {
        qDebug() << "Scene: JavaScript engine not initialized";
        return QString();
    }
    
    QJSValue result = m_jsEngine->evaluate(script);
    
    if (result.isError()) {
        qDebug() << "Scene: JavaScript error:" << result.toString();
        return QString();
    }
    
    return result.toString();
}

void Scene::loadJavaScriptFile(const QString& filePath)
{
    if (!m_jsEngine) {
        qDebug() << "Scene: JavaScript engine not initialized";
        return;
    }
    
    QJSValue result = m_jsEngine->evaluateFile(filePath);
    
    if (result.isError()) {
        qDebug() << "Scene: Failed to load JavaScript file:" << filePath << "Error:" << result.toString();
    } else {
        qDebug() << "Scene: Successfully loaded JavaScript file:" << filePath;
    }
}


=== view.cpp ===
#include "view.h"
#include "scene.h"
#include <QMouseEvent>
#include <QWheelEvent>
#include <QDragEnterEvent>
#include <QDragMoveEvent>
#include <QDropEvent>
#include <QMimeData>
#include <QDebug>

View::View(Scene* scene, QWidget* parent)
    : QGraphicsView(scene, parent)
    , m_scene(scene)
{
    setRenderHint(QPainter::Antialiasing);
    setRenderHint(QPainter::SmoothPixmapTransform);
    setDragMode(QGraphicsView::NoDrag);  // Temporarily disable rubber band
    setViewportUpdateMode(QGraphicsView::FullViewportUpdate);
    
    // Disable any debug drawing of item bounding rectangles
    setRenderHint(QPainter::Qt4CompatiblePainting, false);
    
    // Additional optimizations to prevent bounding box artifacts
    setOptimizationFlags(QGraphicsView::DontSavePainterState | 
                        QGraphicsView::DontAdjustForAntialiasing);
    
    // Enable drag and drop
    setAcceptDrops(true);
}

void View::mousePressEvent(QMouseEvent* event)
{
    QGraphicsView::mousePressEvent(event);
}

void View::mouseMoveEvent(QMouseEvent* event)
{
    QGraphicsView::mouseMoveEvent(event);
}

void View::mouseReleaseEvent(QMouseEvent* event)
{
    QGraphicsView::mouseReleaseEvent(event);
}

void View::wheelEvent(QWheelEvent* event)
{
    // Simple zoom
    const qreal scaleFactor = 1.15;
    if (event->angleDelta().y() > 0) {
        scale(scaleFactor, scaleFactor);
    } else {
        scale(1.0 / scaleFactor, 1.0 / scaleFactor);
    }
}

void View::dragEnterEvent(QDragEnterEvent* event)
{
    qDebug() << "View: Drag enter event received";
    qDebug() << "View: Available mime formats:" << event->mimeData()->formats();
    
    // Check if the drag contains node template data
    if (event->mimeData()->hasFormat("application/x-node-template")) {
        QByteArray nodeData = event->mimeData()->data("application/x-node-template");
        QString nodeString = QString::fromUtf8(nodeData);
        qDebug() << "View: Node template data detected:" << nodeString;
        
        event->acceptProposedAction();
        qDebug() << "✓ View: Drag enter accepted - node template detected";
    } else {
        event->ignore();
        qDebug() << "✗ View: Drag enter ignored - no node template data";
    }
}

void View::dragMoveEvent(QDragMoveEvent* event)
{
    // Allow drag movement if it contains node template data
    if (event->mimeData()->hasFormat("application/x-node-template")) {
        event->acceptProposedAction();
        // Only log every 10th move event to avoid spam
        static int moveCount = 0;
        if (++moveCount % 10 == 0) {
            QPointF scenePos = mapToScene(event->pos());
            qDebug() << "View: Drag move accepted at scene position:" << scenePos;
        }
    } else {
        event->ignore();
        qDebug() << "View: Drag move ignored - no node template data";
    }  
}

void View::dropEvent(QDropEvent* event)
{
    qDebug() << "View: Drop event received";
    
    // Handle node template drop
    if (event->mimeData()->hasFormat("application/x-node-template")) {
        QByteArray nodeData = event->mimeData()->data("application/x-node-template");
        QString nodeString = QString::fromUtf8(nodeData);
        qDebug() << "View: Decoding drop data:" << nodeString;
        
        QStringList parts = nodeString.split("|");
        qDebug() << "View: Split into" << parts.size() << "parts:" << parts;
        
        if (parts.size() >= 5) {
            QString nodeType = parts[0];
            QString name = parts[1];
            QString description = parts[2];
            int inputSockets = parts[3].toInt();
            int outputSockets = parts[4].toInt();
            
            // Convert drop position to scene coordinates
            QPointF scenePos = mapToScene(event->pos());
            
            qDebug() << "View: Parsed node data:";
            qDebug() << "  - Type:" << nodeType;
            qDebug() << "  - Name:" << name;
            qDebug() << "  - Description:" << description;
            qDebug() << "  - Input sockets:" << inputSockets;
            qDebug() << "  - Output sockets:" << outputSockets;
            qDebug() << "  - Scene position:" << scenePos;
            
            qDebug() << "View: Emitting nodeDropped signal to Window";
            
            // Emit signal to notify the window
            emit nodeDropped(scenePos, nodeType, name, inputSockets, outputSockets);
            
            event->acceptProposedAction();
            qDebug() << "✓ View: Drop event accepted and processed";
        } else {
            qWarning() << "✗ View: Invalid node template data format - expected 5 parts, got" << parts.size();
            event->ignore();
        }
    } else {
        qDebug() << "✗ View: Drop event ignored - no node template data";
        event->ignore();
    }
}

=== node.cpp ===
#include "node.h"
#include "socket.h"
#include "edge.h"
#include "scene.h"
#include <QPainter>
#include <QStyleOptionGraphicsItem>
#include <QWidget>
#include <QDebug>
#include <QTimer>
#include <libxml/tree.h>

Node::Node(const QUuid& id, const QPointF& position)
    : m_id(id)
    , m_nodeType("DEFAULT")
    , m_width(80.0)
    , m_height(50.0)
    , m_changeCallback(nullptr)
    , m_observer(nullptr)
    , m_lastPos(position)
{
    setPos(position);
    setFlag(QGraphicsItem::ItemIsMovable, true);
    setFlag(QGraphicsItem::ItemIsSelectable, true);
    setFlag(QGraphicsItem::ItemSendsGeometryChanges, true);
    
    // Node creation logging removed - working correctly
}

Node::~Node()
{
    // SAFETY: Invalidate all connected edges before destruction
    // Copy the set to avoid modification during iteration
    QSet<Edge*> edgesCopy = m_incidentEdges;
    for (Edge* edge : edgesCopy) {
        edge->invalidateNode(this);
    }
    
    // Node destruction logging removed - working correctly
}

QRectF Node::boundingRect() const
{
    return QRectF(0, 0, m_width, m_height);
}

void Node::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
    Q_UNUSED(option)
    Q_UNUSED(widget)
    
    QRectF rect = boundingRect();
    
    // Draw node body with rounded corners and gradient
    painter->setRenderHint(QPainter::Antialiasing);
    
    // Enhanced selection highlight using Qt's selection system
    if (isSelected()) {
        // Draw selection glow effect
        painter->setPen(QPen(QColor(255, 69, 0), 6)); // Thick orange border
        painter->setBrush(QColor(255, 245, 205)); // Light orange background
        
        // Add outer glow
        QRectF glowRect = rect.adjusted(-3, -3, 3, 3);
        painter->setPen(QPen(QColor(255, 69, 0, 100), 8));
        painter->drawRoundedRect(glowRect, 10.0, 10.0);
        
        // Restore main border
        painter->setPen(QPen(QColor(255, 69, 0), 4));
    } else {
        painter->setPen(QPen(Qt::darkGray, 2));
        painter->setBrush(QColor(240, 240, 240)); // Light gray background
    }
    
    painter->drawRoundedRect(rect, 8.0, 8.0);
    
    // Draw node type with improved typography
    painter->setPen(Qt::black);
    
    // Performance optimization: static font (created once, not every frame)
    static const QFont nodeFont("Arial", 8, QFont::Bold);
    painter->setFont(nodeFont);
    
    // Draw node type instead of UUID
    QString displayText = m_nodeType;
    painter->drawText(rect, Qt::AlignCenter, displayText);
    
    // Draw subtle node ID below type (smaller)
    if (rect.height() > 35) {
        // Performance optimization: cache display string (created once, not every frame)
        if (m_cachedDisplayId.isEmpty()) {
            m_cachedDisplayId = m_id.toString(QUuid::WithoutBraces).left(6);
        }
        
        static const QFont idFont("Arial", 6);
        painter->setFont(idFont);
        painter->setPen(QColor(120, 120, 120));
        
        QRectF idRect = rect.adjusted(0, rect.height() * 0.6, 0, 0);
        painter->drawText(idRect, Qt::AlignCenter, m_cachedDisplayId);
    }
}

QVariant Node::itemChange(GraphicsItemChange change, const QVariant &value)
{
    if (change == ItemSelectedHasChanged) {
        // Selection tracking logging - what has been selected
        bool isNowSelected = value.toBool();
        qDebug() << "Node" << m_id.toString(QUuid::WithoutBraces).left(8) 
                 << (isNowSelected ? "SELECT" : "DESELECT") << m_nodeType;
        
        // Trigger visual update when selection changes
        update();
    } else if (change == ItemPositionHasChanged) {
        // Only update edges when position actually changes significantly
        QPointF currentPos = value.toPointF();
        if ((currentPos - m_lastPos).manhattanLength() > 5.0) {
            QPointF oldPos = m_lastPos;
            m_lastPos = currentPos;
            
            // Re-enabled with safer edge updates
            updateConnectedEdges();
            
            // Notify observers of node movement via scene
            if (Scene* typedScene = static_cast<Scene*>(scene())) {
                typedScene->notifyNodeMoved(m_id, oldPos, currentPos);
            }
        }
        
        if (m_changeCallback) {
            m_changeCallback(this);
        }
    }
    return QGraphicsItem::itemChange(change, value);
}

void Node::setNodeSize(qreal width, qreal height)
{
    prepareGeometryChange();
    m_width = width;
    m_height = height;
    update();
}

// Removed manual setSelected - using Qt's selection system

void Node::setNodeType(const QString& type)
{
    m_nodeType = type;
    createStaticSockets();
    update();
    
    qDebug() << "Node" << m_id.toString(QUuid::WithoutBraces).left(8) << "type:" << type;
}

void Node::createStaticSockets()
{
    // CRITICAL: Delete edges connected to this node BEFORE deleting sockets
    Scene* typedScene = static_cast<Scene*>(scene());
    if (typedScene) {
        QList<QUuid> edgesToDelete;
        for (auto it = typedScene->getEdges().begin(); it != typedScene->getEdges().end(); ++it) {
            Edge* edge = it.value();
            if (edge->isConnectedToNode(m_id)) {
                edgesToDelete.append(it.key());
            }
        }
        // Delete edges that reference old sockets
        for (const QUuid& edgeId : edgesToDelete) {
            typedScene->deleteEdge(edgeId);
        }
        qDebug() << "Node::createStaticSockets - removed" << edgesToDelete.size() 
                 << "edges before socket recreation for node" << m_id.toString(QUuid::WithoutBraces).left(8);
    }
    
    // Remove existing sockets (Qt will auto-delete child items)
    for (QGraphicsItem* child : childItems()) {
        if (qgraphicsitem_cast<Socket*>(child)) {
            delete child;  // Qt removes from parent automatically
        }
    }
    m_sockets.clear();  // Clear cache to prevent dangling pointers
    
    // This method now does nothing - sockets are created during XML read()
    // based on XML attributes like inputs="2" outputs="3"
}

void Node::createSocketsFromXml(int inputCount, int outputCount)
{
    // CRITICAL: Delete edges connected to this node BEFORE deleting sockets
    // Otherwise edges keep stale Socket* pointers and crash on updatePath()
    Scene* typedScene = static_cast<Scene*>(scene());
    if (typedScene) {
        QList<QUuid> edgesToDelete;
        for (auto it = typedScene->getEdges().begin(); it != typedScene->getEdges().end(); ++it) {
            Edge* edge = it.value();
            if (edge->isConnectedToNode(m_id)) {
                edgesToDelete.append(it.key());
            }
        }
        // Delete edges that reference old sockets
        for (const QUuid& edgeId : edgesToDelete) {
            typedScene->deleteEdge(edgeId);
        }
        qDebug() << "Node::createSocketsFromXml - removed" << edgesToDelete.size() 
                 << "edges before socket recreation for node" << m_id.toString(QUuid::WithoutBraces).left(8);
    }
    
    // Clear existing sockets - both graphics items AND cache
    for (QGraphicsItem* child : childItems()) {
        if (qgraphicsitem_cast<Socket*>(child)) {
            delete child;  // Qt removes from parent automatically
        }
    }
    m_sockets.clear();  // Clear cache to prevent dangling pointers
    
    // Calculate dynamic node size based on socket count
    calculateNodeSize(inputCount, outputCount);
    
    // Phase 1: Create all socket objects (no positioning yet)
    int socketIndex = 0;
    
    // Create input sockets (indexes 0, 1, 2, ...)
    for (int i = 0; i < inputCount; ++i) {
        Socket* inputSocket = new Socket(Socket::Input, this, socketIndex++);
        // Register socket with scene if node has observer (GraphFactory)
        if (hasObserver()) {
            Scene* scene = static_cast<Scene*>(this->scene());
            if (scene) {
                scene->addSocket(inputSocket);
            }
        }
    }
    
    // Create output sockets (continuing index sequence)
    for (int i = 0; i < outputCount; ++i) {
        Socket* outputSocket = new Socket(Socket::Output, this, socketIndex++);
        // Register socket with scene if node has observer (GraphFactory)
        if (hasObserver()) {
            Scene* scene = static_cast<Scene*>(this->scene());
            if (scene) {
                scene->addSocket(outputSocket);
            }
        }
    }
    
    // Phase 2: Position all sockets with complete information
    positionAllSockets(inputCount, outputCount);
    
    qDebug() << "Node" << m_id.toString(QUuid::WithoutBraces).left(8) << inputCount << "IN" << outputCount << "OUT";
}

void Node::positionAllSockets(int totalInputs, int totalOutputs)
{
    // Parse-then-position architecture: Position all sockets with complete information
    // Uses K/O formula: max((2*K + 1), (2*O + 1)) × socketSize with BALANCED CENTERING
    
    // ✅ Get actual socket size from existing socket - no fallbacks or magic numbers
    if (m_sockets.isEmpty()) {
        qWarning() << "Node::positionAllSockets() called with no sockets available";
        return;
    }
    
    QSizeF actualSocketSize = m_sockets[0]->getSocketSize();
    qreal socketSize = qMax(actualSocketSize.width(), actualSocketSize.height());
    
    const qreal socketOffset = 4.0; // Distance from node edge
    const qreal socketSpacing = 32.0; // Match calculateNodeSize spacing
    
    QRectF nodeRect = boundingRect();
    int inputIndex = 0;
    int outputIndex = 0;
    
    // VIRTUAL BOUNDING BOX APPROACH: Create centered virtual boxes for socket placement
    qreal nodeHeight = nodeRect.height();
    qreal nodeCenterY = nodeHeight * 0.6; // Visual center, moved down from geometric center
    
    // Create virtual bounding boxes for each socket group using (2*n + 1) * socketSize formula
    qreal inputBoxHeight = (totalInputs > 0) ? (2 * totalInputs + 1) * socketSize : 0;
    qreal outputBoxHeight = (totalOutputs > 0) ? (2 * totalOutputs + 1) * socketSize : 0;
    
    // Align the horizontal center lines: socket box center = node center
    qreal inputBoxCenterY = nodeCenterY;
    qreal outputBoxCenterY = nodeCenterY;
    qreal inputBoxStartY = inputBoxCenterY - (inputBoxHeight / 2.0);
    qreal outputBoxStartY = outputBoxCenterY - (outputBoxHeight / 2.0);
    
    // Calculate socket positions using balanced centering
    for (Socket* socket : m_sockets) {
        if (!socket) continue;
        
        if (socket->getRole() == Socket::Input) {
            // Place socket within the centered virtual input bounding box
            qreal x = -socketOffset;  // Left side of node
            qreal y = inputBoxStartY + socketSize * (2 * inputIndex + 1); // Position at center of each slot
            
            socket->setDirectPosition(x, y);
            inputIndex++;
            
            qDebug() << "VIRTUAL BOX INPUT socket" << inputIndex-1 << "positioned at" << QPointF(x, y);
        } else {
            // Place socket within the centered virtual output bounding box  
            qreal x = nodeRect.width() + socketOffset;  // Right side of node
            qreal y = outputBoxStartY + socketSize * (2 * outputIndex + 1); // Position at center of each slot
            
            socket->setDirectPosition(x, y);
            outputIndex++;
            
            qDebug() << "VIRTUAL BOX OUTPUT socket" << outputIndex-1 << "positioned at" << QPointF(x, y);
        }
    }
    
    // Verify balanced positioning
    qreal requiredInputHeight = (totalInputs > 0) ? (2 * totalInputs + 1) * socketSize : 0;
    qreal requiredOutputHeight = (totalOutputs > 0) ? (2 * totalOutputs + 1) * socketSize : 0;
    qreal requiredHeight = qMax(requiredInputHeight, requiredOutputHeight);
    
    qDebug() << "VIRTUAL BOX POSITIONING: K=" << totalInputs << "inputs (box start:" << inputBoxStartY 
             << "), O=" << totalOutputs << "outputs (box start:" << outputBoxStartY << ")"
             << "| Node height:" << nodeHeight << "| Required:" << requiredHeight
             << "for node" << m_id.toString(QUuid::WithoutBraces).left(8);
}

Socket* Node::getSocketByIndex(int index) const
{
    // O(1) socket lookup using cache - with safety validation
    if (index >= 0 && index < m_sockets.size()) {
        Socket* socket = m_sockets[index];
        if (!socket) {
            qCritical() << "Node::getSocketByIndex() - null socket at index" << index 
                       << "in node" << m_id.toString(QUuid::WithoutBraces).left(8);
            return nullptr;
        }
        // Belt-and-suspenders: check if socket has been deleted
        if (socket->scene() == nullptr) {
            qWarning() << "Node::getSocketByIndex() - socket at index" << index 
                      << "has been deleted (not in scene) in node" << m_id.toString(QUuid::WithoutBraces).left(8);
            return nullptr;
        }
        return socket;
    }
    qWarning() << "Node::getSocketByIndex() - index" << index << "out of bounds [0," 
               << m_sockets.size() << ") in node" << m_id.toString(QUuid::WithoutBraces).left(8);
    return nullptr;
}

int Node::getSocketCount() const
{
    // O(1) socket count using cache
    return m_sockets.size();
}

void Node::registerSocket(Socket* socket, int index)
{
    if (!socket) {
        qCritical() << "Node::registerSocket() - null socket passed for index" << index;
        return;
    }
    
    // Enforce contiguous indices - prevent sparse arrays with nullptr gaps
    if (index != m_sockets.size()) {
        qCritical() << "Node::registerSocket() - index" << index 
                   << "is not contiguous. Expected index" << m_sockets.size() 
                   << "for node" << m_id.toString(QUuid::WithoutBraces).left(8);
        Q_ASSERT(index == m_sockets.size());
        return;
    }
    
    // Append socket to maintain contiguous array
    m_sockets.append(socket);
    
    qDebug() << "Node" << m_id.toString(QUuid::WithoutBraces).left(8) << "socket" << index 
             << (socket->getRole() == Socket::Input ? "IN" : "OUT");
}

void Node::setChangeCallback(void (*callback)(Node*))
{
    m_changeCallback = callback;
}

// ============================================================================
// Edge Management - O(degree) Performance Optimization
// ============================================================================

void Node::registerEdge(Edge* edge)
{
    if (!edge) {
        qWarning() << "Node::registerEdge() - null edge pointer for node" << m_id.toString(QUuid::WithoutBraces).left(8);
        return;
    }
    
    // Debug assertion in development builds
    #ifdef QT_DEBUG
    if (m_incidentEdges.contains(edge)) {
        qWarning() << "Node::registerEdge() - edge already registered with node" << m_id.toString(QUuid::WithoutBraces).left(8);
        return;
    }
    #endif
    
    m_incidentEdges.insert(edge);
    // Edge registration logging removed - working correctly
}

void Node::unregisterEdge(Edge* edge)
{
    if (!edge) {
        qWarning() << "Node::unregisterEdge() - null edge pointer for node" << m_id.toString(QUuid::WithoutBraces).left(8);
        return;
    }
    
    // Debug assertion in development builds
    #ifdef QT_DEBUG
    if (!m_incidentEdges.contains(edge)) {
        qWarning() << "Node::unregisterEdge() - edge not found in node" << m_id.toString(QUuid::WithoutBraces).left(8);
        return;
    }
    #endif
    
    m_incidentEdges.remove(edge);
    // Edge unregistration logging removed - working correctly
}

void Node::updateConnectedEdges()
{
    // NEW: O(degree) performance - only update edges actually connected to this node
    for (Edge* edge : m_incidentEdges) {
        edge->updatePath();
    }
    
    // Edge update logging removed - working correctly
}


// Sockets now paint themselves as QGraphicsItems - no need for this method

xmlNodePtr Node::write(xmlDocPtr doc, xmlNodePtr repr) const
{
    xmlNodePtr node = xmlNewNode(nullptr, BAD_CAST "node");
    
    // Core attributes
    xmlSetProp(node, BAD_CAST "id", BAD_CAST m_id.toString(QUuid::WithoutBraces).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "x", BAD_CAST QString::number(pos().x()).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "y", BAD_CAST QString::number(pos().y()).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "type", BAD_CAST m_nodeType.toUtf8().constData());
    
    // Count sockets by role
    int inputCount = 0, outputCount = 0;
    for (QGraphicsItem* child : childItems()) {
        if (Socket* socket = qgraphicsitem_cast<Socket*>(child)) {
            if (socket->getRole() == Socket::Input) inputCount++;
            else if (socket->getRole() == Socket::Output) outputCount++;
        }
    }
    
    // Save socket configuration as XML attributes
    xmlSetProp(node, BAD_CAST "inputs", BAD_CAST QString::number(inputCount).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "outputs", BAD_CAST QString::number(outputCount).toUtf8().constData());
    
    if (repr) {
        xmlAddChild(repr, node);
    } else {
        xmlDocSetRootElement(doc, node);
    }
    
    return node;
}

void Node::read(xmlNodePtr node)
{
    if (!node) return;
    
    // Read UUID
    xmlChar* idStr = xmlGetProp(node, BAD_CAST "id");
    if (idStr) {
        m_id = QUuid(QString::fromUtf8((char*)idStr));
        xmlFree(idStr);
    }
    
    // Read node type 
    xmlChar* typeStr = xmlGetProp(node, BAD_CAST "type");
    if (typeStr) {
        m_nodeType = QString::fromUtf8((char*)typeStr);
        xmlFree(typeStr);
    }
    
    // Read socket configuration from XML attributes
    int inputCount = 1;  // Default
    int outputCount = 1; // Default
    
    xmlChar* inputsStr = xmlGetProp(node, BAD_CAST "inputs");
    if (inputsStr) {
        inputCount = QString::fromUtf8((char*)inputsStr).toInt();
        xmlFree(inputsStr);
    }
    
    xmlChar* outputsStr = xmlGetProp(node, BAD_CAST "outputs");
    if (outputsStr) {
        outputCount = QString::fromUtf8((char*)outputsStr).toInt();
        xmlFree(outputsStr);
    }
    
    // Create sockets based on XML configuration
    createSocketsFromXml(inputCount, outputCount);
    
    // Read position
    xmlChar* xStr = xmlGetProp(node, BAD_CAST "x");
    xmlChar* yStr = xmlGetProp(node, BAD_CAST "y");
    if (xStr && yStr) {
        qreal x = QString::fromUtf8((char*)xStr).toDouble();
        qreal y = QString::fromUtf8((char*)yStr).toDouble();
        setPos(x, y);
        xmlFree(xStr);
        xmlFree(yStr);
    }
    
    update();
}

void Node::calculateNodeSize(int inputCount, int outputCount)
{
    // Calculate required height based on socket count
    int maxSockets = qMax(inputCount, outputCount);
    
    // Constants matching socket configuration
    const qreal socketSpacing = 32.0;  // Must match socket.cpp
    const qreal minNodeHeight = 50.0;  // Minimum height for node text
    const qreal topPadding = 14.0;     // Top padding (socket width)
    const qreal bottomPadding = 14.0;  // Bottom padding (socket width)
    const qreal minNodeWidth = 100.0;  // Minimum width for node text
    
    // Calculate height based on socket count
    if (maxSockets > 0) {
        // Height = top padding + (sockets * spacing) + bottom padding
        qreal requiredHeight = topPadding + (maxSockets - 1) * socketSpacing + 14.0 + bottomPadding;
        m_height = qMax(minNodeHeight, requiredHeight);
    } else {
        m_height = minNodeHeight;
    }
    
    // Calculate width based on node type and content
    QString displayText = m_nodeType + " " + m_id.toString(QUuid::WithoutBraces).left(8);
    QFont font("Arial", 10);
    QFontMetrics metrics(font);
    qreal textWidth = metrics.horizontalAdvance(displayText) + 20; // Add padding
    
    m_width = qMax(minNodeWidth, textWidth);
    
    // Ensure node is wide enough to accommodate sockets with proper spacing
    const qreal socketOffset = 8.0; // Space for socket offset from edges
    m_width = qMax(m_width, socketOffset * 2 + 20); // Minimum width for sockets
    
    // Notify Qt graphics system of geometry change
    prepareGeometryChange();
    
    qDebug() << "Node" << m_id.toString(QUuid::WithoutBraces).left(8) 
             << "resized to" << m_width << "x" << m_height 
             << "for" << inputCount << "inputs," << outputCount << "outputs";
}

=== socket.cpp ===
#include "socket.h"
#include "node.h"
#include "edge.h"
#include "scene.h"
#include <QPainter>
#include <QGraphicsSceneMouseEvent>
#include <QDebug>
#include <QDateTime>
#include <QtMath>

Socket::Socket(Role role, Node* parentNode, int index)
    : QGraphicsItem(parentNode)
    , m_role(role)
    , m_index(index)
    , m_connectedEdge(nullptr)
    , m_connectionState(Disconnected)
    , m_radius(8.0)
    , m_hovered(false)
    , m_hoverOpacity(0.0)
    , m_pressed(false)
{
    setAcceptHoverEvents(true);
    setFlag(QGraphicsItem::ItemIsSelectable, true);
    
    // ✅ Set socket z-order: above nodes (0) but below edges (2)
    setZValue(1);
    
    // ✅ NO positioning in constructor - will be positioned later with complete information
    
    // Register with parent node for O(1) lookups
    if (parentNode) {
        parentNode->registerSocket(this, m_index);
    }
    
    qDebug() << "+Socket" << m_index << (m_role == Input ? "IN" : "OUT");
}

Node* Socket::getParentNode() const
{
    return qgraphicsitem_cast<Node*>(parentItem());
}

QRectF Socket::boundingRect() const
{
    // Smaller rounded square sockets with better proportions
    return QRectF(-7, -7, 14, 14);
}

void Socket::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
    Q_UNUSED(option)
    Q_UNUSED(widget)
    
    painter->setRenderHint(QPainter::Antialiasing);
    
    // Color-coded sockets like upper level system
    QColor socketColor;
    QColor borderColor;
    
    if (m_role == Input) {
        socketColor = QColor(100, 149, 237); // Cornflower blue
        borderColor = QColor(70, 130, 180);  // Steel blue
    } else {
        socketColor = QColor(220, 20, 60);    // Crimson red
        borderColor = QColor(178, 34, 34);    // Fire brick
    }
    
    // Add smooth hover effect with opacity
    if (m_hovered || m_hoverOpacity > 0.0) {
        qreal hoverAmount = m_hovered ? 1.0 : m_hoverOpacity;
        socketColor = QColor::fromRgb(
            socketColor.red() + (50 * hoverAmount),
            socketColor.green() + (50 * hoverAmount),
            socketColor.blue() + (50 * hoverAmount)
        );
        borderColor = QColor::fromRgb(
            borderColor.red() + (30 * hoverAmount),
            borderColor.green() + (30 * hoverAmount),
            borderColor.blue() + (30 * hoverAmount)
        );
    }
    
    // Draw socket as circular with enhanced styling
    QRectF rect = boundingRect();
    
    // Apply pressed state effect
    if (m_pressed) {
        socketColor = socketColor.darker(120);
        borderColor = borderColor.darker(120);
        rect = rect.adjusted(1, 1, -1, -1); // Slight inset when pressed
    }
    
    // Add connection state visual feedback
    switch (m_connectionState) {
        case Connected:
            {
                // ✅ ENHANCED: Clear visual feedback for connected sockets
                
                // Draw socket body (slightly dimmed to show "occupied" state)
                painter->setBrush(socketColor.darker(110));
                painter->setPen(QPen(borderColor, 2));
                painter->drawRoundedRect(rect, 3.0, 3.0);
                
                // ✅ Draw prominent BLACK connection dot in center
                QRectF dotRect = rect.adjusted(3, 3, -3, -3); // Larger dot for visibility
                painter->setBrush(QBrush(Qt::black));
                painter->setPen(QPen(Qt::black, 1));
                painter->drawEllipse(dotRect); // Black circular dot
                
                // Optional: Add subtle glow around socket
                if (m_hovered) {
                    painter->setBrush(Qt::NoBrush);
                    painter->setPen(QPen(borderColor.lighter(150), 1));
                    painter->drawRoundedRect(rect.adjusted(-1, -1, 1, 1), 4.0, 4.0);
                }
            }
            break;
            
        case Highlighted:
            {
                // Draw pulsing highlight for valid connection targets
                // Use time-based pulsing effect
                qreal pulse = 0.5 + 0.5 * qSin(QDateTime::currentMSecsSinceEpoch() * 0.01);
                QColor highlightColor = QColor(0, 255, 0, 80 + 40 * pulse);
                painter->setBrush(QBrush(highlightColor));
                painter->setPen(QPen(QColor(0, 255, 0, 150 + 50 * pulse), 2));
                painter->drawRoundedRect(rect.adjusted(-2, -2, 2, 2), 4.0, 4.0);
                
                painter->setBrush(socketColor.lighter(130));
                painter->setPen(QPen(borderColor, 2));
                painter->drawRoundedRect(rect, 3.0, 3.0);
            }
            break;
            
        case Connecting:
            // Draw connecting state (for source socket during drag)
            painter->setBrush(QBrush(socketColor.lighter(110)));
            painter->setPen(QPen(borderColor.darker(120), 3));
            painter->drawRoundedRect(rect, 3.0, 3.0);
            break;
            
        case Disconnected:
        default:
            // Normal socket appearance - rounded square
            painter->setBrush(socketColor);
            painter->setPen(QPen(borderColor, 2));
            painter->drawRoundedRect(rect, 3.0, 3.0);
            break;
    }
    
    // Draw socket index number with better contrast
    if (rect.width() > 8) { // Only draw index if socket is large enough
        painter->setPen(Qt::white);
        
        // Performance optimization: static font (created once, not every frame)
        static const QFont socketFont("Arial", 7, QFont::Bold);
        painter->setFont(socketFont);
        
        // Performance optimization: cache index string (created once, not every frame)
        if (m_cachedIndexString.isEmpty()) {
            m_cachedIndexString = QString::number(m_index);
        }
        painter->drawText(rect, Qt::AlignCenter, m_cachedIndexString);
    }
}

void Socket::mousePressEvent(QGraphicsSceneMouseEvent *event)
{
    m_pressed = true;
    update(); // Show pressed state immediately
    
    // ✅ DISABLE dragging from connected sockets
    if (isConnected()) {
        qDebug() << "Socket" << m_index << "is connected - dragging disabled";
        event->ignore(); // Don't start drag operations on connected sockets
        return;
    }
    
    if (event->button() == Qt::LeftButton) {
        qDebug() << "Socket clicked: index:" << m_index << "role:" << (m_role == Input ? "Input" : "Output");
        // TODO: Start edge creation drag
        event->accept();
    } else if (event->button() == Qt::RightButton && m_role == Output) {
        qDebug() << "Socket right-clicked: index:" << m_index << "role:" << (m_role == Input ? "Input" : "Output");
        // Start ghost edge from output socket
        Scene* scene = qobject_cast<Scene*>(this->scene());
        if (scene) {
            scene->startGhostEdge(this, event->scenePos());
        }
        event->accept();
    }
    QGraphicsItem::mousePressEvent(event);
}

void Socket::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)
{
    m_pressed = false;
    update(); // Remove pressed state
    
    if (event->button() == Qt::LeftButton) {
        qDebug() << "Socket released: index:" << m_index;
        // TODO: Complete edge connection
        event->accept();
    }
    QGraphicsItem::mouseReleaseEvent(event);
}

void Socket::hoverEnterEvent(QGraphicsSceneHoverEvent *event)
{
    Q_UNUSED(event)
    m_hovered = true;
    m_hoverOpacity = 1.0; // Animate to full opacity
    update();
}

void Socket::hoverLeaveEvent(QGraphicsSceneHoverEvent *event)
{
    Q_UNUSED(event)
    m_hovered = false;
    m_hoverOpacity = 0.0; // Animate to no opacity
    update();
}


xmlNodePtr Socket::write(xmlDocPtr doc, xmlNodePtr repr) const
{
    Q_UNUSED(doc)
    Q_UNUSED(repr)
    // Sockets are written as part of their parent node
    return nullptr;
}

void Socket::read(xmlNodePtr node)
{
    Q_UNUSED(node)
    // Socket properties read from parent node's socket definitions
    // Position is set by parent node's positionAllSockets() method
}




=== edge.cpp ===
#include "edge.h"
#include "socket.h"
#include "node.h"
#include "scene.h"
#include <QPainter>
#include <QStyleOptionGraphicsItem>
#include <QWidget>
#include <QDebug>
#include <libxml/tree.h>
#include <cmath>

Edge::Edge(const QUuid& id, const QUuid& fromSocketId, const QUuid& toSocketId)
    : m_id(id)
    , m_fromNodeId()
    , m_toNodeId()
    , m_fromNodeUuid()
    , m_toNodeUuid()
    , m_fromSocketIndex(-1)
    , m_toSocketIndex(-1)
    , m_fromSocket(nullptr)
    , m_toSocket(nullptr)
    , m_fromNode(nullptr)
    , m_toNode(nullptr)
    , m_hovered(false)
    #ifdef QT_DEBUG
    , m_shapeCallCount(0)
    #endif
{
    Q_UNUSED(fromSocketId)  // Legacy parameter, not used in clean design
    Q_UNUSED(toSocketId)    // Legacy parameter, not used in clean design
    setFlag(QGraphicsItem::ItemIsSelectable, true);
    setFlag(QGraphicsItem::ItemHasNoContents, false); // Ensure we control our own drawing
    setAcceptHoverEvents(true);  // Enable hover events for better interaction
    
    // ✅ Z-order hierarchy: Nodes(0) < Sockets(1) < Edges(2)
    // Edges appear on top of sockets for "plugged-in" visual effect
    setZValue(2);
    
    qDebug() << "+Edge" << m_id.toString(QUuid::WithoutBraces).left(8);
    // Don't call updatePath() here - sockets not resolved yet
}

Edge::~Edge()
{
    // SAFETY: Only touch nodes that are still valid (not nulled by invalidateNode)
    if (m_fromNode) {
        m_fromNode->unregisterEdge(this);
    }
    if (m_toNode) {
        m_toNode->unregisterEdge(this);
    }
    
    qDebug() << "~Edge" << m_id.toString(QUuid::WithoutBraces).left(8);
}

void Edge::invalidateNode(const Node* node)
{
    // Manual weak pointer nulling - called by Node::~Node()
    if (node == m_fromNode) {
        m_fromNode = nullptr;
    }
    if (node == m_toNode) {
        m_toNode = nullptr;
    }
}

QRectF Edge::boundingRect() const
{
    return m_boundingRect;
}

void Edge::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
    Q_UNUSED(widget)
    Q_UNUSED(option) // Don't use Qt's default drawing options
    
    painter->setRenderHint(QPainter::Antialiasing);
    
    // Save painter state to ensure no side effects
    painter->save();
    
    // Make sure no brush is set (no fill)
    painter->setBrush(Qt::NoBrush);
    
    // IMPROVED: Multi-layer cable-like rendering with depth
    if (isSelected()) {
        // Selection: bright orange with glow effect
        QPen glowPen(QColor(255, 69, 0, 100), 12);
        glowPen.setCapStyle(Qt::RoundCap);
        painter->setPen(glowPen);
        painter->drawPath(m_path);
        
        QPen selectionPen(QColor(255, 69, 0), 6);
        selectionPen.setCapStyle(Qt::RoundCap);
        painter->setPen(selectionPen);
        painter->drawPath(m_path);
    } else if (m_hovered) {
        // Hover: blue with subtle glow
        QPen hoverGlowPen(QColor(100, 150, 255, 80), 8);
        hoverGlowPen.setCapStyle(Qt::RoundCap);
        painter->setPen(hoverGlowPen);
        painter->drawPath(m_path);
        
        QPen hoverPen(QColor(100, 150, 255), 4);
        hoverPen.setCapStyle(Qt::RoundCap);
        painter->setPen(hoverPen);
        painter->drawPath(m_path);
    } else {
        // Normal: layered cable appearance with depth
        // Layer 1: Shadow for depth
        QPen shadowPen(QColor(0, 0, 0, 60), 5);
        shadowPen.setCapStyle(Qt::RoundCap);
        painter->setPen(shadowPen);
        QPainterPath shadowPath = m_path;
        shadowPath.translate(1.5, 1.5);
        painter->drawPath(shadowPath);
        
        // Layer 2: Dark outline for definition
        QPen outlinePen(QColor(40, 40, 40), 4);
        outlinePen.setCapStyle(Qt::RoundCap);
        painter->setPen(outlinePen);
        painter->drawPath(m_path);
        
        // Layer 3: Main cable body with subtle gradient effect
        QPen mainPen(QColor(85, 85, 85), 3);
        mainPen.setCapStyle(Qt::RoundCap);
        painter->setPen(mainPen);
        painter->drawPath(m_path);
        
        // Layer 4: Highlight for 3D cable effect
        QPen highlightPen(QColor(120, 120, 120), 1);
        highlightPen.setCapStyle(Qt::RoundCap);
        painter->setPen(highlightPen);
        painter->drawPath(m_path);
    }
    
    // Restore painter state
    painter->restore();
}

QPainterPath Edge::shape() const
{
    // Create a much wider path for easier selection - very generous selection area
    QPainterPathStroker stroker;
    stroker.setWidth(20);  // Very wide selection area for easy clicking
    stroker.setCapStyle(Qt::RoundCap);
    stroker.setJoinStyle(Qt::RoundJoin);
    QPainterPath selectionPath = stroker.createStroke(m_path);
    
    #ifdef QT_DEBUG
    // Debug: Log when shape is queried (indicates potential interaction)
    // Per-edge counter avoids thread safety issues with global static
    ++m_shapeCallCount;
    if (m_shapeCallCount % 100 == 0) {  // Throttled logging to avoid spam
        qDebug() << "Edge" << m_id.toString(QUuid::WithoutBraces).left(8) 
                 << "shape() called" << m_shapeCallCount << "times";
    }
    #endif
    
    return selectionPath;
}

// Removed manual setSelected - using Qt's selection system

QVariant Edge::itemChange(GraphicsItemChange change, const QVariant &value)
{
    if (change == ItemSelectedHasChanged) {
        // Selection tracking logging - what has been selected
        bool isNowSelected = value.toBool();
        qDebug() << "Edge" << m_id.toString(QUuid::WithoutBraces).left(8) 
                 << (isNowSelected ? "SELECT" : "DESELECT");
        
        // Trigger visual update when selection changes
        update();
    }
    return QGraphicsItem::itemChange(change, value);
}

void Edge::mousePressEvent(QGraphicsSceneMouseEvent *event)
{
    qDebug() << "Edge" << m_id.toString(QUuid::WithoutBraces).left(8) << "mousePressEvent at" << event->pos();
    QGraphicsItem::mousePressEvent(event);
}

void Edge::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)
{
    qDebug() << "Edge" << m_id.toString(QUuid::WithoutBraces).left(8) << "mouseReleaseEvent at" << event->pos();
    QGraphicsItem::mouseReleaseEvent(event);
}

void Edge::hoverEnterEvent(QGraphicsSceneHoverEvent *event)
{
    Q_UNUSED(event)
    m_hovered = true;
    qDebug() << "Edge" << m_id.toString(QUuid::WithoutBraces).left(8) << "HOVER ENTER";
    update();  // Redraw to show hover effect
    QGraphicsItem::hoverEnterEvent(event);
}

void Edge::hoverLeaveEvent(QGraphicsSceneHoverEvent *event)
{
    Q_UNUSED(event)
    m_hovered = false;
    qDebug() << "Edge" << m_id.toString(QUuid::WithoutBraces).left(8) << "HOVER LEAVE";
    update();  // Redraw to remove hover effect
    QGraphicsItem::hoverLeaveEvent(event);
}

void Edge::updatePath()
{
    // Simple and clean: use direct socket pointers
    if (!m_fromSocket || !m_toSocket) {
        // Edge not resolved yet - notify BSP cache before clearing
        prepareGeometryChange();
        m_path = QPainterPath();
        m_boundingRect = QRectF();
        return;
    }
    
    // ✅ FIXED: Connect to exact socket centers in scene coordinates
    // Use mapToScene to get the socket's center point in scene coordinates
    QRectF fromRect = m_fromSocket->boundingRect();
    QRectF toRect = m_toSocket->boundingRect();
    
    // Get the center of each socket in its local coordinates, then map to scene
    QPointF start = m_fromSocket->mapToScene(fromRect.center());
    QPointF end = m_toSocket->mapToScene(toRect.center());
    
    buildPath(start, end);
}



void Edge::buildPath(const QPointF& start, const QPointF& end)
{
    // Validate input points
    if (start.isNull() || end.isNull() || !qIsFinite(start.x()) || !qIsFinite(start.y()) || 
        !qIsFinite(end.x()) || !qIsFinite(end.y())) {
        // Notify BSP cache before clearing
        prepareGeometryChange();
        m_path = QPainterPath();
        m_boundingRect = QRectF();
        return;
    }
    
    // Clear and rebuild path safely
    m_path.clear();
    
    // ✅ ENHANCED: Connect directly to socket centers (no adjustment needed)
    // Since updatePath() now provides socket centers, use them directly
    QPointF adjustedStart = start;
    QPointF adjustedEnd = end;
    
    m_path.moveTo(adjustedStart);
    
    // IMPROVED: Dynamic curve calculation based on distance and orientation
    qreal dx = adjustedEnd.x() - adjustedStart.x();
    qreal dy = adjustedEnd.y() - adjustedStart.y();
    qreal distance = std::sqrt(dx * dx + dy * dy);
    
    // Adaptive control point calculation for better curves
    qreal horizontalFactor = qAbs(dx) / qMax(distance, 1.0);
    qreal verticalFactor = qAbs(dy) / qMax(distance, 1.0);
    
    // Dynamic control offset based on distance and direction
    qreal controlOffset;
    if (horizontalFactor > 0.8) {
        // Mostly horizontal: use classic Bezier with distance-based offset
        controlOffset = qMax(qAbs(dx) * 0.4, qMin(distance * 0.3, 150.0));
    } else {
        // More vertical: tighter curves for better routing
        controlOffset = qMax(40.0, qMin(distance * 0.2, 80.0));
    }
    
    // Enhanced control point positioning for natural cable-like curves
    QPointF control1, control2;
    
    if (dx >= 0) {
        // Left-to-right: standard horizontal Bezier
        control1 = adjustedStart + QPointF(controlOffset, 0);
        control2 = adjustedEnd - QPointF(controlOffset, 0);
    } else {
        // Right-to-left: S-curve for better visual routing
        qreal verticalOffset = qAbs(dy) * 0.3;
        control1 = adjustedStart + QPointF(controlOffset * 0.6, dy > 0 ? verticalOffset : -verticalOffset);
        control2 = adjustedEnd - QPointF(controlOffset * 0.6, dy > 0 ? verticalOffset : -verticalOffset);
    }
    
    // Create smooth cubic Bezier curve
    m_path.cubicTo(control1, control2, adjustedEnd);
    
    // Notify Qt's BSP cache before changing bounding rectangle
    prepareGeometryChange();
    
    // Update bounding rectangle with validation
    QRectF pathBounds = m_path.boundingRect();
    if (pathBounds.isValid()) {
        // Inflate by strokeWidth/2 = 10 to match stroker.setWidth(20)
        m_boundingRect = pathBounds.adjusted(-10, -10, 10, 10);
    } else {
        // Inflate by strokeWidth/2 = 10 to match stroker.setWidth(20)
        m_boundingRect = QRectF(start, end).normalized().adjusted(-10, -10, 10, 10);
    }
}


xmlNodePtr Edge::write(xmlDocPtr doc, xmlNodePtr repr) const
{
    xmlNodePtr node = xmlNewNode(nullptr, BAD_CAST "edge");
    
    // Core attributes - clean design uses node+index format
    xmlSetProp(node, BAD_CAST "id", BAD_CAST m_id.toString(QUuid::WithoutBraces).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "fromNode", BAD_CAST m_fromNodeId.toUtf8().constData());
    xmlSetProp(node, BAD_CAST "toNode", BAD_CAST m_toNodeId.toUtf8().constData());
    xmlSetProp(node, BAD_CAST "fromSocketIndex", BAD_CAST QString::number(m_fromSocketIndex).toUtf8().constData());
    xmlSetProp(node, BAD_CAST "toSocketIndex", BAD_CAST QString::number(m_toSocketIndex).toUtf8().constData());
    
    if (repr) {
        xmlAddChild(repr, node);
    } else {
        xmlDocSetRootElement(doc, node);
    }
    
    return node;
}

void Edge::read(xmlNodePtr node)
{
    if (!node) return;
    
    // Read UUID
    xmlChar* idStr = xmlGetProp(node, BAD_CAST "id");
    if (idStr) {
        m_id = QUuid(QString::fromUtf8((char*)idStr));
        xmlFree(idStr);
    }
    
    // Read node+index references - store for later resolution
    // Support both formats: new (fromNode/toNode) and legacy (from/to)
    xmlChar* fromNodeStr = xmlGetProp(node, BAD_CAST "fromNode");
    if (!fromNodeStr) fromNodeStr = xmlGetProp(node, BAD_CAST "from");
    
    xmlChar* toNodeStr = xmlGetProp(node, BAD_CAST "toNode");
    if (!toNodeStr) toNodeStr = xmlGetProp(node, BAD_CAST "to");
    
    xmlChar* fromIndexStr = xmlGetProp(node, BAD_CAST "fromSocketIndex");
    if (!fromIndexStr) fromIndexStr = xmlGetProp(node, BAD_CAST "from-socket");
    
    xmlChar* toIndexStr = xmlGetProp(node, BAD_CAST "toSocketIndex");
    if (!toIndexStr) toIndexStr = xmlGetProp(node, BAD_CAST "to-socket");
    
    if (!fromNodeStr || !toNodeStr || !fromIndexStr || !toIndexStr) {
        qCritical() << "Edge::read() - Missing required node+index attributes";
        if (fromNodeStr) xmlFree(fromNodeStr);
        if (toNodeStr) xmlFree(toNodeStr);
        if (fromIndexStr) xmlFree(fromIndexStr);
        if (toIndexStr) xmlFree(toIndexStr);
        return;
    }
    
    // Store data for later resolution - don't try to resolve now
    m_fromNodeId = QString::fromUtf8((char*)fromNodeStr);
    m_toNodeId = QString::fromUtf8((char*)toNodeStr);
    m_fromSocketIndex = QString::fromUtf8((char*)fromIndexStr).toInt();
    m_toSocketIndex = QString::fromUtf8((char*)toIndexStr).toInt();
    
    // Performance optimization: cache UUIDs for fast comparison
    m_fromNodeUuid = QUuid(m_fromNodeId);
    m_toNodeUuid = QUuid(m_toNodeId);
    
    qDebug() << "Edge: Stored connection data fromNode" << m_fromNodeId.left(8) 
             << "socket" << m_fromSocketIndex << "-> toNode" << m_toNodeId.left(8) 
             << "socket" << m_toSocketIndex;
    
    xmlFree(fromNodeStr);
    xmlFree(toNodeStr);
    xmlFree(fromIndexStr);
    xmlFree(toIndexStr);
    
    // DON'T call updatePath() here - scene may not be ready
    // Socket resolution will happen later via resolveConnections()
}

bool Edge::isConnectedToNode(const QString& nodeId) const
{
    return (m_fromNodeId == nodeId || m_toNodeId == nodeId);
}

bool Edge::isConnectedToNode(const QUuid& nodeId) const
{
    // Optimized: Fast UUID comparison (no string conversion)
    return (m_fromNodeUuid == nodeId || m_toNodeUuid == nodeId);
}

bool Edge::resolveConnections(Scene* scene)
{
    if (!scene) {
        qCritical() << "Edge::resolveConnections - null scene";
        return false;
    }
    
    if (m_fromNodeId.isEmpty() || m_toNodeId.isEmpty()) {
        qCritical() << "Edge::resolveConnections - empty node IDs";
        return false;
    }
    
    // Find nodes by UUID
    Node* fromNode = scene->getNode(QUuid(m_fromNodeId));
    Node* toNode = scene->getNode(QUuid(m_toNodeId));
    
    if (!fromNode) {
        qCritical() << "Edge::resolveConnections - fromNode not found:" << m_fromNodeId.left(8);
        return false;
    }
    if (!toNode) {
        qCritical() << "Edge::resolveConnections - toNode not found:" << m_toNodeId.left(8);
        return false;
    }
    
    // Find sockets by index
    Socket* fromSocket = fromNode->getSocketByIndex(m_fromSocketIndex);
    Socket* toSocket = toNode->getSocketByIndex(m_toSocketIndex);
    
    qDebug() << "Edge resolve: fromNode" << m_fromNodeId.left(8) << "type:" << fromNode->getNodeType()
             << "socket" << m_fromSocketIndex << "role:" << (fromSocket ? Socket::roleToString(fromSocket->getRole()) : "NULL");
    qDebug() << "Edge resolve: toNode" << m_toNodeId.left(8) << "type:" << toNode->getNodeType()
             << "socket" << m_toSocketIndex << "role:" << (toSocket ? Socket::roleToString(toSocket->getRole()) : "NULL");
    
    if (!fromSocket) {
        qCritical() << "Edge::resolveConnections - fromSocket index" << m_fromSocketIndex 
                   << "not found in node" << m_fromNodeId.left(8) 
                   << "with" << fromNode->getSocketCount() << "sockets";
        return false;
    }
    if (!toSocket) {
        qCritical() << "Edge::resolveConnections - toSocket index" << m_toSocketIndex 
                   << "not found in node" << m_toNodeId.left(8) 
                   << "with" << toNode->getSocketCount() << "sockets";
        return false;
    }
    
    // Validate connection rules
    if (fromSocket->getRole() != Socket::Output) {
        qCritical() << "ERROR: Edge::resolveConnections - fromSocket must be Output role"
                   << "- fromNode:" << m_fromNodeId.left(8) << "socket" << m_fromSocketIndex 
                   << "has role:" << Socket::roleToString(fromSocket->getRole());
        return false;
    }
    if (toSocket->getRole() != Socket::Input) {
        qCritical() << "ERROR: Edge::resolveConnections - toSocket must be Input role"
                   << "- toNode:" << m_toNodeId.left(8) << "socket" << m_toSocketIndex 
                   << "has role:" << Socket::roleToString(toSocket->getRole());
        return false;
    }
    
    // Store socket references directly - NO UUIDs
    m_fromSocket = fromSocket;
    m_toSocket = toSocket;
    
    // Cache node pointers for safe destruction
    m_fromNode = fromNode;
    m_toNode = toNode;
    
    // PERFORMANCE OPTIMIZATION: Register this edge with both connected nodes
    // This enables O(degree) edge updates instead of O(totalEdges)
    fromNode->registerEdge(this);
    toNode->registerEdge(this);
    
    qDebug() << "Edge" << m_id.toString(QUuid::WithoutBraces).left(8) << "resolved" 
             << m_fromSocketIndex << "->" << m_toSocketIndex;
    
    updatePath();
    return true;
}

void Edge::setConnectionData(const QString& fromNodeId, const QString& toNodeId, 
                            int fromSocketIndex, int toSocketIndex)
{
    m_fromNodeId = fromNodeId;
    m_toNodeId = toNodeId;
    m_fromSocketIndex = fromSocketIndex;
    m_toSocketIndex = toSocketIndex;
    
    // Performance optimization: cache UUIDs for fast comparison
    m_fromNodeUuid = QUuid(fromNodeId);
    m_toNodeUuid = QUuid(toNodeId);
    
    qDebug() << "Edge: Set connection data" << fromNodeId.left(8) 
             << "socket" << fromSocketIndex << "-> " << toNodeId.left(8) 
             << "socket" << toSocketIndex;
}

void Edge::setResolvedSockets(Socket* fromSocket, Socket* toSocket)
{
    if (!fromSocket || !toSocket) {
        qCritical() << "Edge::setResolvedSockets - null socket(s) provided";
        return;
    }
    
    // Validate socket roles
    if (fromSocket->getRole() != Socket::Output) {
        qCritical() << "Edge::setResolvedSockets - fromSocket must be Output role";
        return;
    }
    if (toSocket->getRole() != Socket::Input) {
        qCritical() << "Edge::setResolvedSockets - toSocket must be Input role";
        return;
    }
    
    m_fromSocket = fromSocket;
    m_toSocket = toSocket;
    
    // Cache node pointers for safe destruction
    Node* fromNode = fromSocket->getParentNode();
    Node* toNode = toSocket->getParentNode();
    m_fromNode = fromNode;
    m_toNode = toNode;
    
    // PERFORMANCE OPTIMIZATION: Register this edge with both connected nodes
    // This enables O(degree) edge updates instead of O(totalEdges)
    if (fromNode) fromNode->registerEdge(this);
    if (toNode) toNode->registerEdge(this);
    
    qDebug() << "✓ Edge: Set resolved sockets directly (optimization)";
    updatePath();
}

=== graph_factory.cpp ===
#include "graph_factory.h"
#include "node.h"
#include "socket.h"
#include "edge.h"
#include "scene.h"
#include "node_registry.h"
#include "graph_observer.h"
#include <QDateTime>
#include <QDebug>

GraphFactory::GraphFactory(QGraphicsScene* scene, xmlDocPtr xmlDoc)
    : m_scene(scene)
    , m_xmlDocument(xmlDoc)
{
    qDebug() << "GraphFactory initialized with scene and XML document";
}

Node* GraphFactory::createNodeFromXml(xmlNodePtr xmlNode)
{
    if (!xmlNode) {
        qWarning() << "GraphFactory::createNodeFromXml - null XML node";
        return nullptr;
    }
    
    // Get node type from XML
    QString nodeType = getXmlProperty(xmlNode, "type");
    if (nodeType.isEmpty()) {
        qWarning() << "GraphFactory::createNodeFromXml - missing type attribute";
        return nullptr;
    }
    
    // Create node using registry
    Node* node = NodeRegistry::instance().createNode(nodeType);
    if (!node) {
        qCritical() << "GraphFactory::createNodeFromXml - failed to create node of type:" << nodeType;
        return nullptr;
    }
    
    // Attach observer before reading XML - contract requirement
    node->setObserver(this);
    
    // Let the node read its XML and configure itself
    node->read(xmlNode);
    
    // Verify observer is still attached
    if (!node->hasObserver()) {
        qCritical() << "GraphFactory::createNodeFromXml - observer detached during read";
        delete node;
        return nullptr;
    }
    
    // Add to typed scene collection
    if (Scene* typedScene = static_cast<Scene*>(m_scene)) {
        typedScene->addNode(node);
    } else {
        m_scene->addItem(node);
    }
    
    qDebug() << "GraphFactory: Created node from XML, type:" << nodeType 
             << "id:" << node->getId().toString(QUuid::WithoutBraces).left(8);
    
    return node;
}

Edge* GraphFactory::createEdgeFromXml(xmlNodePtr xmlEdge)
{
    if (!xmlEdge) {
        qWarning() << "GraphFactory::createEdgeFromXml - null XML edge";
        return nullptr;
    }
    
    // Get edge properties from XML (new node+index format)
    QString edgeId = getXmlProperty(xmlEdge, "id");
    QString fromNode = getXmlProperty(xmlEdge, "fromNode");
    QString toNode = getXmlProperty(xmlEdge, "toNode");
    QString fromIndex = getXmlProperty(xmlEdge, "fromSocketIndex");
    QString toIndex = getXmlProperty(xmlEdge, "toSocketIndex");
    
    if (edgeId.isEmpty() || fromNode.isEmpty() || toNode.isEmpty() || 
        fromIndex.isEmpty() || toIndex.isEmpty()) {
        qWarning() << "GraphFactory::createEdgeFromXml - missing required node+index attributes";
        qWarning() << "Required: id, fromNode, toNode, fromSocketIndex, toSocketIndex";
        return nullptr;
    }
    
    // Create edge object with temporary UUIDs (will be resolved in read())
    Edge* edge = new Edge(QUuid::fromString(edgeId), QUuid(), QUuid());
    
    // Let the edge read its XML and configure itself
    edge->read(xmlEdge);
    
    // Add to typed scene collection
    if (Scene* typedScene = static_cast<Scene*>(m_scene)) {
        typedScene->addEdge(edge);
    } else {
        m_scene->addItem(edge);
    }
    
    qDebug() << "GraphFactory: Created edge from XML, id:" << edgeId.left(8)
             << "from node:" << fromNode.left(8) << "socket" << fromIndex
             << "to node:" << toNode.left(8) << "socket" << toIndex;
    
    return edge;
}

Node* GraphFactory::createNode(const QString& nodeType, const QPointF& position, int inputs, int outputs)
{
    if (!m_xmlDocument) {
        qCritical() << "GraphFactory::createNode - no XML document";
        return nullptr;
    }
    
    // Create XML node first with socket configuration
    xmlNodePtr xmlNode = createXmlNode(nodeType, position, inputs, outputs);
    if (!xmlNode) {
        qCritical() << "GraphFactory::createNode - failed to create XML node";
        return nullptr;
    }
    
    // Create object from XML
    return createNodeFromXml(xmlNode);
}

Edge* GraphFactory::createEdge(Node* fromNode, int fromSocketIndex, Node* toNode, int toSocketIndex)
{
    if (!m_xmlDocument) {
        qCritical() << "GraphFactory::createEdge - no XML document";
        return nullptr;
    }
    
    if (!fromNode || !toNode) {
        qCritical() << "GraphFactory::createEdge - null node(s)";
        return nullptr;
    }
    
    // Get actual socket UUIDs by finding sockets by index
    Socket* fromSocket = fromNode->getSocketByIndex(fromSocketIndex);
    Socket* toSocket = toNode->getSocketByIndex(toSocketIndex);
    
    if (!fromSocket || !toSocket) {
        qCritical() << "GraphFactory::createEdge - invalid socket index(es)";
        return nullptr;
    }
    
    // Create XML edge using clean node+index format
    xmlNodePtr xmlEdge = createXmlEdgeNodeIndex(fromNode->getId(), fromSocketIndex, toNode->getId(), toSocketIndex);
    if (!xmlEdge) {
        qCritical() << "GraphFactory::createEdge - failed to create XML edge";
        return nullptr;
    }
    
    qDebug() << "GraphFactory: Created XML edge from node" << fromNode->getId().toString(QUuid::WithoutBraces).left(8) 
             << "socket" << fromSocketIndex << "to node" << toNode->getId().toString(QUuid::WithoutBraces).left(8)
             << "socket" << toSocketIndex;
    
    // Create object from XML
    return createEdgeFromXml(xmlEdge);
}

Edge* GraphFactory::connectSockets(Socket* fromSocket, Socket* toSocket)
{
    if (!fromSocket || !toSocket) {
        qCritical() << "GraphFactory::connectSockets - null socket(s)";
        return nullptr;
    }
    
    if (!m_xmlDocument) {
        qCritical() << "GraphFactory::connectSockets - no XML document";
        return nullptr;
    }
    
    // Get parent nodes for clean node+index approach
    Node* fromNode = fromSocket->getParentNode();
    Node* toNode = toSocket->getParentNode();
    
    if (!fromNode || !toNode) {
        qCritical() << "GraphFactory::connectSockets - sockets have no parent nodes";
        return nullptr;
    }
    
    // Optimized: Create edge directly in memory, serialize later
    QUuid edgeId = QUuid::createUuid();
    Edge* edge = new Edge(edgeId, QUuid(), QUuid());
    
    // Set connection data directly without XML round-trip
    edge->setConnectionData(fromNode->getId().toString(QUuid::WithoutBraces), toNode->getId().toString(QUuid::WithoutBraces),
                           fromSocket->getIndex(), toSocket->getIndex());
    
    // Resolve connections immediately since we have the sockets
    edge->setResolvedSockets(fromSocket, toSocket);
    
    // Add to scene
    if (Scene* typedScene = static_cast<Scene*>(m_scene)) {
        typedScene->addEdge(edge);
    } else {
        m_scene->addItem(edge);
    }
    
    // Create XML for persistence (lazy serialization)
    xmlNodePtr xmlEdge = createXmlEdgeNodeIndex(fromNode->getId(), fromSocket->getIndex(), 
                                                toNode->getId(), toSocket->getIndex());
    if (!xmlEdge) {
        qWarning() << "GraphFactory::connectSockets - XML serialization failed (edge still created)";
    }
    
    // Connect sockets atomically
    fromSocket->setConnectedEdge(edge);
    toSocket->setConnectedEdge(edge);
    
    qDebug() << "GraphFactory: Atomically connected sockets" 
             << "index" << fromSocket->getIndex()
             << "to index" << toSocket->getIndex();
    
    return edge;
}

bool GraphFactory::loadFromXmlFile(const QString& filePath)
{
    qDebug() << "=== GraphFactory: Loading from XML File ===" << filePath;
    
    // OPTIMIZATION: Enable batch mode to prevent observer storm during bulk loading
    GraphSubject::beginBatch();
    
    // Parse XML file
    xmlDocPtr doc = xmlParseFile(filePath.toUtf8().constData());
    if (!doc) {
        qCritical() << "GraphFactory::loadFromXmlFile - failed to parse XML file:" << filePath;
        GraphSubject::endBatch();  // Clean up batch mode on error
        return false;
    }
    
    xmlNodePtr root = xmlDocGetRootElement(doc);
    if (!root) {
        qCritical() << "GraphFactory::loadFromXmlFile - no root element";
        xmlFreeDoc(doc);
        GraphSubject::endBatch();  // Clean up batch mode on error
        return false;
    }
    
    if (xmlStrcmp(root->name, (const xmlChar*)"graph") != 0) {
        qCritical() << "Invalid XML file: root element should be 'graph'";
        xmlFreeDoc(doc);
        GraphSubject::endBatch();  // Clean up batch mode on error
        return false;
    }
    
    qDebug() << "✓ XML file parsed successfully";
    
    // PHASE 1: Load ALL nodes first - handle both direct and nested formats
    QVector<Node*> allNodes;
    
    // Check if nodes are direct children or nested under <nodes>
    xmlNodePtr nodesContainer = nullptr;
    for (xmlNodePtr child = root->children; child; child = child->next) {
        if (child->type == XML_ELEMENT_NODE && xmlStrcmp(child->name, (const xmlChar*)"nodes") == 0) {
            nodesContainer = child;
            break;
        }
    }
    
    // Load nodes from appropriate location
    xmlNodePtr nodeParent = nodesContainer ? nodesContainer : root;
    qDebug() << "=== Loading Nodes" << (nodesContainer ? "from <nodes> wrapper" : "directly from root") << "===";
    
    for (xmlNodePtr xmlNode = nodeParent->children; xmlNode; xmlNode = xmlNode->next) {
        if (xmlNode->type == XML_ELEMENT_NODE && xmlStrcmp(xmlNode->name, (const xmlChar*)"node") == 0) {
            
            // Check if this node has the format we support (inputs/outputs attributes)
            xmlChar* inputsAttr = xmlGetProp(xmlNode, BAD_CAST "inputs");
            xmlChar* outputsAttr = xmlGetProp(xmlNode, BAD_CAST "outputs");
            
            if (inputsAttr && outputsAttr) {
                // Our format: <node inputs="1" outputs="1" />
                Node* node = createNodeFromXml(xmlNode);
                if (node) {
                    allNodes.append(node);
                    qDebug() << "✓ Loaded node:" << node->getNodeType() 
                             << "ID:" << node->getId().toString(QUuid::WithoutBraces).left(8);
                }
                xmlFree(inputsAttr);
                xmlFree(outputsAttr);
            } else {
                // Nested socket format: <node><socket /></node> - skip
                qDebug() << "Skipping node with nested socket format (not supported)";
                if (inputsAttr) xmlFree(inputsAttr);
                if (outputsAttr) xmlFree(outputsAttr);
            }
        }
    }
    
    // PHASE 2: Load edges (but don't resolve connections yet)
    QVector<Edge*> allEdges;
    qDebug() << "=== Loading Edges directly from root ===";
    for (xmlNodePtr xmlNode = root->children; xmlNode; xmlNode = xmlNode->next) {
        if (xmlNode->type == XML_ELEMENT_NODE && xmlStrcmp(xmlNode->name, (const xmlChar*)"edge") == 0) {
            Edge* edge = createEdgeFromXml(xmlNode);
            if (edge) {
                allEdges.append(edge);
                qDebug() << "✓ Loaded edge:" << edge->getId().toString(QUuid::WithoutBraces).left(8);
            }
        }
    }
    
    qDebug() << "=== XML Loading Complete ===";
    qDebug() << "✓ Loaded" << allNodes.size() << "nodes and" << allEdges.size() << "edges";
    
    xmlFreeDoc(doc);
    
    // PHASE 3: Resolve all edge connections now that all nodes exist
    qDebug() << "=== Resolving Edge Connections ===";
    int successfulConnections = 0;
    if (Scene* typedScene = static_cast<Scene*>(m_scene)) {
        for (Edge* edge : allEdges) {
            qDebug() << "Resolving edge:" << edge->getId().toString(QUuid::WithoutBraces).left(8);
            if (edge->resolveConnections(typedScene)) {
                successfulConnections++;
            } else {
                qWarning() << "FAILED to resolve edge connections:" << edge->getId().toString(QUuid::WithoutBraces).left(8);
            }
        }
    }
    
    qDebug() << "✓ Graph loaded:" << allNodes.size() << "nodes," << successfulConnections << "/" << allEdges.size() << "edges connected";
    
    // OPTIMIZATION: End batch mode to resume normal observer notifications
    GraphSubject::endBatch();
    
    // Validate graph integrity in debug builds
    #ifdef QT_DEBUG
    if (!validateGraphIntegrity()) {
        qWarning() << "Graph integrity validation failed after loading";
    }
    #endif
    
    return true;
}

QString GraphFactory::getXmlProperty(xmlNodePtr node, const QString& name)
{
    if (!node) return QString();
    
    xmlChar* prop = xmlGetProp(node, BAD_CAST name.toUtf8().constData());
    if (!prop) return QString();
    
    QString result = QString::fromUtf8((char*)prop);
    xmlFree(prop);
    return result;
}

xmlNodePtr GraphFactory::createXmlNode(const QString& nodeType, const QPointF& position, int inputs, int outputs)
{
    xmlNodePtr nodesElement = getNodesElement();
    if (!nodesElement) {
        qCritical() << "GraphFactory::createXmlNode - no nodes element in XML";
        return nullptr;
    }
    
    // Create new node element
    xmlNodePtr nodeElement = xmlNewChild(nodesElement, nullptr, BAD_CAST "node", nullptr);
    
    // Set attributes including socket configuration
    QUuid nodeId = QUuid::createUuid();
    xmlSetProp(nodeElement, BAD_CAST "id", BAD_CAST nodeId.toString(QUuid::WithoutBraces).toUtf8().constData());
    xmlSetProp(nodeElement, BAD_CAST "type", BAD_CAST nodeType.toUtf8().constData());
    xmlSetProp(nodeElement, BAD_CAST "x", BAD_CAST QString::number(position.x()).toUtf8().constData());
    xmlSetProp(nodeElement, BAD_CAST "y", BAD_CAST QString::number(position.y()).toUtf8().constData());
    xmlSetProp(nodeElement, BAD_CAST "inputs", BAD_CAST QString::number(inputs).toUtf8().constData());
    xmlSetProp(nodeElement, BAD_CAST "outputs", BAD_CAST QString::number(outputs).toUtf8().constData());
    
    qDebug() << "GraphFactory: Created XML node, type:" << nodeType << "id:" << nodeId.toString(QUuid::WithoutBraces).left(8)
             << "inputs:" << inputs << "outputs:" << outputs;
    
    return nodeElement;
}

xmlNodePtr GraphFactory::createXmlEdgeNodeIndex(const QUuid& fromNodeId, int fromSocketIndex, const QUuid& toNodeId, int toSocketIndex)
{
    xmlNodePtr edgesElement = getEdgesElement();
    if (!edgesElement) {
        qCritical() << "GraphFactory::createXmlEdgeNodeIndex - no edges element in XML";
        return nullptr;
    }
    
    // Create new edge element
    xmlNodePtr edgeElement = xmlNewChild(edgesElement, nullptr, BAD_CAST "edge", nullptr);
    
    // Set attributes using clean node+index format
    QUuid edgeId = QUuid::createUuid();
    xmlSetProp(edgeElement, BAD_CAST "id", BAD_CAST edgeId.toString(QUuid::WithoutBraces).toUtf8().constData());
    xmlSetProp(edgeElement, BAD_CAST "fromNode", BAD_CAST fromNodeId.toString(QUuid::WithoutBraces).toUtf8().constData());
    xmlSetProp(edgeElement, BAD_CAST "toNode", BAD_CAST toNodeId.toString(QUuid::WithoutBraces).toUtf8().constData());
    xmlSetProp(edgeElement, BAD_CAST "fromSocketIndex", BAD_CAST QString::number(fromSocketIndex).toUtf8().constData());
    xmlSetProp(edgeElement, BAD_CAST "toSocketIndex", BAD_CAST QString::number(toSocketIndex).toUtf8().constData());
    
    qDebug() << "GraphFactory: Created XML edge, id:" << edgeId.toString(QUuid::WithoutBraces).left(8)
             << "from node:" << fromNodeId.toString(QUuid::WithoutBraces).left(8) << "socket" << fromSocketIndex
             << "to node:" << toNodeId.toString(QUuid::WithoutBraces).left(8) << "socket" << toSocketIndex;
    
    return edgeElement;
}

xmlNodePtr GraphFactory::getNodesElement()
{
    if (!m_xmlDocument) return nullptr;
    
    xmlNodePtr root = xmlDocGetRootElement(m_xmlDocument);
    if (!root) return nullptr;
    
    // Find or create <nodes> element
    for (xmlNodePtr child = root->children; child; child = child->next) {
        if (xmlStrcmp(child->name, BAD_CAST "nodes") == 0) {
            return child;
        }
    }
    
    // Create nodes element if it doesn't exist
    xmlNodePtr nodesElement = xmlNewChild(root, nullptr, BAD_CAST "nodes", nullptr);
    return nodesElement;
}

xmlNodePtr GraphFactory::getEdgesElement()
{
    if (!m_xmlDocument) return nullptr;
    
    xmlNodePtr root = xmlDocGetRootElement(m_xmlDocument);
    if (!root) return nullptr;
    
    // Find or create <edges> or <connections> element
    for (xmlNodePtr child = root->children; child; child = child->next) {
        if (xmlStrcmp(child->name, BAD_CAST "edges") == 0 ||
            xmlStrcmp(child->name, BAD_CAST "connections") == 0) {
            return child;
        }
    }
    
    // Create connections element if it doesn't exist
    xmlNodePtr connectionsElement = xmlNewChild(root, nullptr, BAD_CAST "connections", nullptr);
    return connectionsElement;
}

// Clean design: socket resolution handled by edges internally - method removed

// No socket resolver needed in clean design - edges use direct socket pointers

bool GraphFactory::validateGraphIntegrity() const
{
    if (!m_scene) {
        qCritical() << "GraphFactory::validateGraphIntegrity - no scene";
        return false;
    }
    
    Scene* typedScene = static_cast<Scene*>(m_scene);
    if (!typedScene) {
        qCritical() << "GraphFactory::validateGraphIntegrity - scene not typed";
        return false;
    }
    
    bool valid = true;
    
    // Validate all nodes have UUIDs and observers
    for (Node* node : typedScene->getNodes().values()) {
        if (!node) {
            qCritical() << "Validation: null node in scene";
            valid = false;
            continue;
        }
        
        if (node->getId().isNull()) {
            qCritical() << "Validation: node without UUID";
            valid = false;
        }
        
        // Check sockets belong to parent node
        for (QGraphicsItem* child : node->childItems()) {
            if (Socket* socket = qgraphicsitem_cast<Socket*>(child)) {
                if (socket->getParentNode() != node) {
                    qCritical() << "Validation: socket parent mismatch";
                    valid = false;
                }
            }
        }
    }
    
    // Validate all edges have valid socket connections
    for (Edge* edge : typedScene->getEdges().values()) {
        if (!edge) {
            qCritical() << "Validation: null edge in scene";
            valid = false;
            continue;
        }
        
        if (edge->getId().isNull()) {
            qCritical() << "Validation: edge without UUID";
            valid = false;
        }
        
        // Clean design: edges should have been resolved during loading
        // Skip validation - edges were validated during resolveConnections() call
    }
    
    // Validate scene count matches typed collections
    int sceneItems = m_scene->items().size();
    int typedItems = typedScene->getNodes().size() + typedScene->getEdges().size();
    
    // Account for sockets as children
    int socketCount = 0;
    for (Node* node : typedScene->getNodes().values()) {
        socketCount += node->getSocketCount();
    }
    typedItems += socketCount;
    
    if (sceneItems != typedItems) {
        qWarning() << "Validation: scene item count mismatch - scene:" << sceneItems 
                   << "typed:" << typedItems;
        // This is a warning, not an error - some items might be temporary
    }
    
    if (valid) {
        qDebug() << "✓ Graph integrity validation passed";
    }
    
    return valid;
}

Socket* GraphFactory::createSocket(Socket::Role role, Node* parentNode, int index)
{
    if (!parentNode) {
        qCritical() << "GraphFactory::createSocket - null parent node";
        return nullptr;
    }
    
    // Create socket with factory access
    Socket* socket = new Socket(role, parentNode, index);
    if (!socket) {
        qCritical() << "GraphFactory::createSocket - failed to create socket";
        return nullptr;
    }
    
    // Add to typed scene collection if available
    if (Scene* typedScene = static_cast<Scene*>(m_scene)) {
        typedScene->addSocket(socket);
    }
    
    qDebug() << "GraphFactory: Created socket" << (role == Socket::Input ? "Input" : "Output") 
             << "index" << index << "for node" << parentNode->getId().toString(QUuid::WithoutBraces).left(8);
    
    return socket;
}

=== node_registry.cpp ===
#include "node_registry.h"
#include "node.h"
#include <QDebug>

NodeRegistry& NodeRegistry::instance()
{
    static NodeRegistry registry;
    return registry;
}

void NodeRegistry::registerNode(const QString& typeName, NodeFactoryFunction factory)
{
    if (m_factories.contains(typeName)) {
        qWarning() << "NodeRegistry: Overwriting existing registration for type:" << typeName;
    }
    
    m_factories[typeName] = factory;
    qDebug() << "NodeRegistry: Registered node type:" << typeName;
}

Node* NodeRegistry::createNode(const QString& typeName) const
{
    auto it = m_factories.find(typeName);
    if (it != m_factories.end()) {
        Node* node = it.value()();
        if (node) {
            qDebug() << "NodeRegistry: Created node of type:" << typeName;
            return node;
        } else {
            qCritical() << "NodeRegistry: Factory function returned null for type:" << typeName;
        }
    } else {
        qWarning() << "NodeRegistry: Unknown node type requested:" << typeName;
        qDebug() << "Available types:" << getRegisteredTypes();
    }
    return nullptr;
}

bool NodeRegistry::isRegistered(const QString& typeName) const
{
    return m_factories.contains(typeName);
}

QStringList NodeRegistry::getRegisteredTypes() const
{
    return m_factories.keys();
}

void NodeRegistry::clear()
{
    qDebug() << "NodeRegistry: Clearing all registrations";
    m_factories.clear();
}

=== javascript_engine.cpp ===
#include "javascript_engine.h"
#include "node.h"
#include "edge.h"
#include "scene.h"
#include "graph_controller.h"
#include "graph_factory.h"
#include <QFile>
#include <QTextStream>
#include <QJsonDocument>
#include <QJsonObject>

JavaScriptEngine::JavaScriptEngine(QObject* parent)
    : QObject(parent)
    , m_engine(new QJSEngine(this))
    , m_scene(nullptr)
    , m_graphController(nullptr)
{
    setupGlobalAPI();
    registerConsoleAPI();
    registerUtilityAPI();
    
    // Auto-load enhanced APIs disabled for now - will load scripts manually
    // loadEnhancedAPIs();
    
    qDebug() << "JavaScriptEngine: Simple JavaScript engine initialized";
}

JavaScriptEngine::~JavaScriptEngine()
{
    qDebug() << "JavaScriptEngine: Shutting down";
}

QJSValue JavaScriptEngine::evaluate(const QString& script)
{
    clearErrors();
    
    qDebug() << "JS_EXECUTION: Starting script execution";
    qDebug() << "JS_EXECUTION: Script length:" << script.length() << "characters";
    
    QJSValue result = m_engine->evaluate(script);
    
    if (result.isError()) {
        m_lastError = QString("JavaScript Error: %1").arg(result.toString());
        emit scriptError(m_lastError);
        qDebug() << "JS_ERROR: Script execution failed:" << m_lastError;
        qDebug() << "JS_ERROR: Script content:" << script.left(500); // Log first 500 chars
    } else {
        emit scriptExecuted(script, result);
        QString resultStr = result.isUndefined() ? "undefined" : result.toString();
        qDebug() << "JS_EXECUTION: Script completed successfully";
        qDebug() << "JS_EXECUTION: Result:" << resultStr;
    }
    
    return result;
}

QJSValue JavaScriptEngine::evaluateFile(const QString& filePath)
{
    qDebug() << "JS_EXECUTION: Loading script file:" << filePath;
    
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        m_lastError = QString("Cannot open script file: %1").arg(filePath);
        emit scriptError(m_lastError);
        qDebug() << "JS_ERROR: Failed to open script file:" << filePath;
        return QJSValue();
    }
    
    QTextStream in(&file);
    QString script = in.readAll();
    
    qDebug() << "JS_EXECUTION: Loaded script file:" << filePath;
    qDebug() << "JS_EXECUTION: Script size:" << script.length() << "characters";
    
    return evaluate(script);
}

void JavaScriptEngine::registerNodeAPI(Scene* scene)
{
    m_scene = scene;
    
    // Register Node API
    QJSValue nodeAPI = m_engine->newObject();
    
    // Node creation functions - Qt5 compatible
    QJSValue createFunc = m_engine->evaluate(R"(
        (function(type, x, y) {
            if (arguments.length < 3) {
                throw new Error("Node.create() requires type, x, y parameters");
            }
            console.log("JavaScript: Creating node " + type + " at " + x + "," + y);
            return {}; // Placeholder
        })
    )");
    nodeAPI.setProperty("create", createFunc);
    
    // Node query functions - Qt5 compatible
    QJSValue findByIdFunc = m_engine->evaluate(R"(
        (function(id) {
            if (arguments.length < 1) {
                throw new Error("Node.findById() requires id parameter");
            }
            console.log("JavaScript: Finding node by ID: " + id);
            return null; // Placeholder
        })
    )");
    nodeAPI.setProperty("findById", findByIdFunc);
    
    // Enhanced node manipulation functions
    QJSValue moveNodeFunc = m_engine->evaluate(R"(
        (function(nodeId, x, y) {
            if (arguments.length < 3) {
                throw new Error("Node.move() requires nodeId, x, y parameters");
            }
            console.log("JavaScript: Moving node " + nodeId + " to " + x + "," + y);
            return true; // Placeholder
        })
    )");
    nodeAPI.setProperty("move", moveNodeFunc);
    
    QJSValue getPropertiesFunc = m_engine->evaluate(R"(
        (function(nodeId) {
            if (arguments.length < 1) {
                throw new Error("Node.getProperties() requires nodeId parameter");
            }
            console.log("JavaScript: Getting properties for node " + nodeId);
            return {}; // Placeholder
        })
    )");
    nodeAPI.setProperty("getProperties", getPropertiesFunc);
    
    m_engine->globalObject().setProperty("Node", nodeAPI);
    
    // Register Graph API
    QJSValue graphAPI = m_engine->newObject();
    
    // Graph API functions - Qt5 compatible
    QJSValue getNodesFunc = m_engine->evaluate(R"(
        (function() {
            console.log("JavaScript: Getting all nodes");
            return []; // Placeholder
        })
    )");
    graphAPI.setProperty("getNodes", getNodesFunc);
    
    QJSValue getEdgesFunc = m_engine->evaluate(R"(
        (function() {
            console.log("JavaScript: Getting all edges");
            return []; // Placeholder
        })
    )");
    graphAPI.setProperty("getEdges", getEdgesFunc);
    
    // Enhanced graph operations
    QJSValue clearGraphFunc = m_engine->evaluate(R"(
        (function() {
            console.log("JavaScript: Clearing graph");
            return true; // Placeholder
        })
    )");
    graphAPI.setProperty("clear", clearGraphFunc);
    
    QJSValue connectNodesFunc = m_engine->evaluate(R"(
        (function(fromNodeId, fromSocket, toNodeId, toSocket) {
            if (arguments.length < 4) {
                throw new Error("Graph.connect() requires fromNodeId, fromSocket, toNodeId, toSocket parameters");
            }
            console.log("JavaScript: Connecting " + fromNodeId + "[" + fromSocket + "] to " + toNodeId + "[" + toSocket + "]");
            return {}; // Placeholder edge ID
        })
    )");
    graphAPI.setProperty("connect", connectNodesFunc);
    
    QJSValue getStatsFunc = m_engine->evaluate(R"(
        (function() {
            console.log("JavaScript: Getting graph statistics");
            return {nodes: 0, edges: 0}; // Placeholder
        })
    )");
    graphAPI.setProperty("getStats", getStatsFunc);
    
    QJSValue graphMoveNodeFunc = m_engine->evaluate(R"(
        (function(nodeId, x, y) {
            if (arguments.length < 3) {
                throw new Error("Graph.moveNode() requires nodeId, x, y parameters");
            }
            console.log("JavaScript: Moving node " + nodeId + " to " + x + "," + y);
            return true; // Placeholder
        })
    )");
    graphAPI.setProperty("moveNode", graphMoveNodeFunc);
    
    QJSValue saveXmlFunc = m_engine->evaluate(R"(
        (function(filename) {
            if (arguments.length < 1) {
                throw new Error("Graph.saveXml() requires filename parameter");
            }
            console.log("JavaScript: Saving graph to " + filename);
            return true; // Placeholder
        })
    )");
    graphAPI.setProperty("saveXml", saveXmlFunc);
    
    QJSValue loadXmlFunc = m_engine->evaluate(R"(
        (function(filename) {
            if (arguments.length < 1) {
                throw new Error("Graph.loadXml() requires filename parameter");
            }
            console.log("JavaScript: Loading graph from " + filename);
            return true; // Placeholder
        })
    )");
    graphAPI.setProperty("loadXml", loadXmlFunc);
    
    m_engine->globalObject().setProperty("Graph", graphAPI);
    
    qDebug() << "JavaScriptEngine: Node and Graph APIs registered";
}

void JavaScriptEngine::registerGraphAPI()
{
    QJSValue algorithms = m_engine->newObject();
    
    // Layout algorithms - Qt5 compatible
    QJSValue forceDirectedFunc = m_engine->evaluate(R"(
        (function() {
            console.log("JavaScript: Running force-directed layout");
            return {}; // Placeholder
        })
    )");
    algorithms.setProperty("forceDirected", forceDirectedFunc);
    
    QJSValue hierarchicalFunc = m_engine->evaluate(R"(
        (function() {
            console.log("JavaScript: Running hierarchical layout");
            return {}; // Placeholder
        })
    )");
    algorithms.setProperty("hierarchical", hierarchicalFunc);
    
    m_engine->globalObject().setProperty("Algorithms", algorithms);
    
    qDebug() << "JavaScriptEngine: Graph algorithms registered";
}

void JavaScriptEngine::registerGraphController(Scene* scene, GraphFactory* factory)
{
    m_scene = scene;
    
    // Create GraphController instance
    m_graphController = new GraphController(scene, factory, this);
    
    // Register as global Graph object
    QJSValue controllerValue = m_engine->newQObject(m_graphController);
    m_engine->globalObject().setProperty("Graph", controllerValue);
    
    // Connect signals for debugging
    connect(m_graphController, &GraphController::nodeCreated, [](const QString& uuid) {
        qDebug() << "JavaScript: Node created:" << uuid;
    });
    
    connect(m_graphController, &GraphController::nodeDeleted, [](const QString& uuid) {
        qDebug() << "JavaScript: Node deleted:" << uuid;
    });
    
    connect(m_graphController, &GraphController::edgeCreated, [](const QString& uuid) {
        qDebug() << "JavaScript: Edge created:" << uuid;
    });
    
    connect(m_graphController, &GraphController::edgeDeleted, [](const QString& uuid) {
        qDebug() << "JavaScript: Edge deleted:" << uuid;
    });
    
    connect(m_graphController, &GraphController::error, [](const QString& message) {
        qDebug() << "JavaScript Graph Error:" << message;
    });
    
    qDebug() << "JavaScriptEngine: GraphController registered as 'Graph' global object";
}

QJSValue JavaScriptEngine::createNodeScript(const QString& nodeType, const QString& script)
{
    QString wrappedScript = QString(R"(
        (function(nodeType, inputs, outputs) {
            %1
        })
    )").arg(script);
    
    QJSValue nodeFunction = evaluate(wrappedScript);
    
    if (!nodeFunction.isError()) {
        m_scriptModules[nodeType] = nodeFunction;
        qDebug() << "JavaScriptEngine: Created node script for type:" << nodeType;
    }
    
    return nodeFunction;
}

bool JavaScriptEngine::executeNodeScript(Node* node, const QString& script, const QVariantMap& inputs)
{
    if (!node) {
        m_lastError = "Cannot execute script on null node";
        return false;
    }
    
    // Convert inputs to JavaScript object
    QJSValue jsInputs = m_engine->newObject();
    for (auto it = inputs.begin(); it != inputs.end(); ++it) {
        jsInputs.setProperty(it.key(), m_engine->toScriptValue(it.value()));
    }
    
    // Set up node context
    QJSValue nodeObj = nodeToJSValue(node);
    m_engine->globalObject().setProperty("currentNode", nodeObj);
    m_engine->globalObject().setProperty("inputs", jsInputs);
    
    QJSValue result = evaluate(script);
    
    return !result.isError();
}

QJSValue JavaScriptEngine::processGraph(const QString& algorithm, const QVariantMap& parameters)
{
    QJSValue params = m_engine->newObject();
    for (auto it = parameters.begin(); it != parameters.end(); ++it) {
        params.setProperty(it.key(), m_engine->toScriptValue(it.value()));
    }
    
    QString script = QString("Algorithms.%1(arguments[0])").arg(algorithm);
    QJSValue algorithmFunc = evaluate(script);
    
    if (algorithmFunc.isCallable()) {
        return algorithmFunc.call(QJSValueList() << params);
    }
    
    return QJSValue();
}

bool JavaScriptEngine::hasErrors() const
{
    return !m_lastError.isEmpty();
}

QString JavaScriptEngine::getLastError() const
{
    return m_lastError;
}

void JavaScriptEngine::clearErrors()
{
    m_lastError.clear();
}

QString JavaScriptEngine::getEngineInfo() const
{
    QJSValue info = m_engine->evaluate(R"(
        JSON.stringify({
            engine: 'QJSEngine',
            qtVersion: ')" + QString(QT_VERSION_STR) + R"(',
            ecmaScript: 'ES5+',
            timestamp: new Date().toISOString(),
            features: {
                objects: typeof Object !== 'undefined',
                arrays: typeof Array !== 'undefined',
                functions: typeof Function !== 'undefined',
                json: typeof JSON !== 'undefined',
                console: typeof console !== 'undefined',
                math: typeof Math !== 'undefined',
                date: typeof Date !== 'undefined'
            }
        }, null, 2)
    )");
    
    return info.isError() ? "Error getting engine info" : info.toString();
}

void JavaScriptEngine::logEngineCapabilities() const
{
    qDebug() << "=== JavaScript Engine Information ===";
    qDebug() << "Engine Type: QJSEngine (Qt JavaScript Engine)";
    qDebug() << "Qt Version:" << QT_VERSION_STR;
    qDebug() << "ECMAScript Level: ES5+ (limited ES6 support)";
    
    QString info = getEngineInfo();
    qDebug() << "Detailed Capabilities:" << info;
    
    // Test specific features
    QJSValue testModernJS = m_engine->evaluate("const test = {a: 1, b: 2}; test.a + test.b");
    qDebug() << "Modern JS (const) support:" << (testModernJS.isError() ? "NO" : "YES");
    
    QJSValue testArrowFunction = m_engine->evaluate("((x) => x * 2)(5)");
    qDebug() << "Arrow function support:" << (testArrowFunction.isError() ? "NO" : "YES");
    
    qDebug() << "======================================";
}

void JavaScriptEngine::loadScriptModule(const QString& moduleName, const QString& scriptContent)
{
    QString moduleScript = QString(R"(
        (function() {
            var module = { exports: {} };
            var exports = module.exports;
            
            %1
            
            return module.exports;
        })()
    )").arg(scriptContent);
    
    QJSValue moduleResult = evaluate(moduleScript);
    
    if (!moduleResult.isError()) {
        m_scriptModules[moduleName] = moduleResult;
        qDebug() << "JavaScriptEngine: Loaded module:" << moduleName;
    }
}

QJSValue JavaScriptEngine::getModule(const QString& moduleName)
{
    return m_scriptModules.value(moduleName, QJSValue());
}

void JavaScriptEngine::handleJavaScriptException(const QJSValue& exception)
{
    m_lastError = QString("JavaScript Exception: %1").arg(exception.toString());
    emit scriptError(m_lastError);
    qDebug() << m_lastError;
}

void JavaScriptEngine::setupGlobalAPI()
{
    // Set up global JavaScript environment
    QJSValue globalObject = m_engine->globalObject();
    
    // Add setTimeout/setInterval placeholders - Qt5 compatible
    QJSValue setTimeoutFunc = m_engine->evaluate(
        "(function(func, delay) {"
        "    console.log('JavaScript: setTimeout called (not implemented)');"
        "    return 0;"
        "})"
    );
    globalObject.setProperty("setTimeout", setTimeoutFunc);
    
    QJSValue setIntervalFunc = m_engine->evaluate(
        "(function(func, delay) {"
        "    console.log('JavaScript: setInterval called (not implemented)');"
        "    return 0;"
        "})"
    );
    globalObject.setProperty("setInterval", setIntervalFunc);
}

void JavaScriptEngine::registerConsoleAPI()
{
    QJSValue console = m_engine->newObject();
    
    // Console API - Qt5 compatible with C++ callback
    QJSValue consoleLog = m_engine->evaluate(R"(
        (function() {
            var args = Array.prototype.slice.call(arguments);
            qt_console_log(args.join(" "));
        })
    )");
    console.setProperty("log", consoleLog);
    
    QJSValue consoleError = m_engine->evaluate(R"(
        (function() {
            var args = Array.prototype.slice.call(arguments);
            qt_console_error(args.join(" "));
        })
    )");
    console.setProperty("error", consoleError);
    
    // Register the entire JavaScriptEngine object so its public slots are accessible
    QJSValue engineObject = m_engine->newQObject(this);
    m_engine->globalObject().setProperty("qt_console_log", engineObject.property("qt_console_log"));
    m_engine->globalObject().setProperty("qt_console_error", engineObject.property("qt_console_error"));
    
    m_engine->globalObject().setProperty("console", console);
}

void JavaScriptEngine::qt_console_log(const QString& message)
{
    qDebug() << "JavaScript Console:" << message;
}

void JavaScriptEngine::qt_console_error(const QString& message)
{
    qDebug() << "JavaScript Error:" << message;
}

void JavaScriptEngine::registerUtilityAPI()
{
    QJSValue utils = m_engine->newObject();
    
    // JSON utilities - Qt5 compatible using built-in JSON
    QJSValue parseJSONFunc = m_engine->evaluate(R"(
        (function(jsonString) {
            if (arguments.length < 1) {
                throw new Error("parseJSON() requires a string parameter");
            }
            try {
                return JSON.parse(jsonString);
            } catch (e) {
                throw new Error("Invalid JSON string");
            }
        })
    )");
    utils.setProperty("parseJSON", parseJSONFunc);
    
    QJSValue stringifyJSONFunc = m_engine->evaluate(R"(
        (function(obj) {
            if (arguments.length < 1) {
                throw new Error("stringifyJSON() requires an object parameter");
            }
            try {
                return JSON.stringify(obj);
            } catch (e) {
                throw new Error("Cannot stringify object");
            }
        })
    )");
    utils.setProperty("stringifyJSON", stringifyJSONFunc);
    
    m_engine->globalObject().setProperty("Utils", utils);
}

QJSValue JavaScriptEngine::nodeToJSValue(Node* node)
{
    if (!node) {
        return QJSValue();
    }
    
    QJSValue nodeObj = m_engine->newObject();
    
    // Basic node properties
    nodeObj.setProperty("id", node->getId().toString());
    nodeObj.setProperty("type", node->getNodeType());
    nodeObj.setProperty("x", node->pos().x());
    nodeObj.setProperty("y", node->pos().y());
    
    // Socket information
    QJSValue sockets = m_engine->newArray();
    // TODO: Populate with actual socket data
    nodeObj.setProperty("sockets", sockets);
    
    return nodeObj;
}

QJSValue JavaScriptEngine::edgeToJSValue(Edge* edge)
{
    if (!edge) {
        return QJSValue();
    }
    
    QJSValue edgeObj = m_engine->newObject();
    
    // Basic edge properties
    edgeObj.setProperty("id", edge->getId().toString());
    
    // TODO: Add from/to node information
    
    return edgeObj;
}

void JavaScriptEngine::loadEnhancedAPIs()
{
    // List of enhanced API scripts to auto-load
    QStringList apiScripts = {
        "scripts/enhanced_graph_api.js",
        "scripts/custom_nodes.js",
        "scripts/node_algorithms.js",
        "scripts/node_execution_engine.js",
        "scripts/demo_interactive.js"
    };
    
    for (const QString& scriptPath : apiScripts) {
        QFile file(scriptPath);
        if (file.exists() && file.open(QIODevice::ReadOnly | QIODevice::Text)) {
            QTextStream in(&file);
            QString script = in.readAll();
            
            QJSValue result = evaluate(script);
            if (!result.isError()) {
                qDebug() << "JavaScriptEngine: Loaded enhanced API:" << scriptPath;
            } else {
                qDebug() << "JavaScriptEngine: Failed to load API:" << scriptPath << "-" << result.toString();
            }
        } else {
            qDebug() << "JavaScriptEngine: API script not found:" << scriptPath;
        }
    }
}

=== graph_controller.cpp ===
#include "graph_controller.h"
#include "scene.h"
#include "graph_factory.h"
#include "node.h"
#include "edge.h"
#include "socket.h"
#include "node_registry.h"
#include <QDebug>
#include <QFile>
#include <QTextStream>
#include <libxml/tree.h>
#include <libxml/parser.h>

GraphController::GraphController(Scene* scene, GraphFactory* factory, QObject* parent)
    : QObject(parent)
    , m_scene(scene)
    , m_factory(factory)
{
    qDebug() << "GraphController: JavaScript interface initialized";
}

QString GraphController::createNode(const QString& type, qreal x, qreal y)
{
    if (!m_scene || !m_factory) {
        emit error("GraphController: Scene or factory not initialized");
        return QString();
    }
    
    // Log node type validation
    QStringList validTypes = getValidNodeTypes();
    qDebug() << "GraphController: Validating node type" << type;
    qDebug() << "GraphController: Available types:" << validTypes;
    
    if (!isValidNodeType(type)) {
        qDebug() << "GraphController: ❌ INVALID node type:" << type;
        emit error(QString("GraphController: Invalid node type: %1").arg(type));
        return QString();
    } else {
        qDebug() << "GraphController: ✅ VALID node type:" << type;
    }
    
    qDebug() << "GraphController: Creating node" << type << "at" << x << "," << y;
    
    try {
        Node* node = m_factory->createNode(type, QPointF(x, y));
        if (node) {
            QString uuid = node->getId().toString();
            qDebug() << "GraphController: ✅ Node created successfully!";
            qDebug() << "GraphController: Node UUID:" << uuid;
            qDebug() << "GraphController: Node type:" << node->getNodeType();
            qDebug() << "GraphController: Node position:" << node->pos();
            emit nodeCreated(uuid);
            return uuid;
        } else {
            qDebug() << "GraphController: ❌ Factory returned null node";
            emit error("GraphController: Factory failed to create node");
        }
    } catch (const std::exception& e) {
        qDebug() << "GraphController: ❌ Exception during node creation:" << e.what();
        emit error(QString("GraphController: Error creating node: %1").arg(e.what()));
    }
    
    qDebug() << "GraphController: ❌ Node creation failed - returning empty string";
    return QString();
}

bool GraphController::deleteNode(const QString& uuid)
{
    if (!m_scene) {
        emit error("GraphController: Scene not initialized");
        return false;
    }
    
    Node* node = findNode(uuid);
    if (!node) {
        emit error(QString("GraphController: Node not found: %1").arg(uuid));
        return false;
    }
    
    qDebug() << "GraphController: Deleting node" << uuid;
    
    try {
        QUuid nodeId = QUuid::fromString(uuid);
        m_scene->deleteNode(nodeId);
        emit nodeDeleted(uuid);
        return true;
    } catch (const std::exception& e) {
        emit error(QString("GraphController: Error deleting node: %1").arg(e.what()));
        return false;
    }
}

bool GraphController::moveNode(const QString& uuid, qreal dx, qreal dy)
{
    Node* node = findNode(uuid);
    if (!node) {
        emit error(QString("GraphController: Node not found: %1").arg(uuid));
        return false;
    }
    
    QPointF currentPos = node->pos();
    QPointF newPos = currentPos + QPointF(dx, dy);
    
    qDebug() << "GraphController: Moving node" << uuid << "by" << dx << "," << dy;
    
    node->setPos(newPos);
    return true;
}

QVariantMap GraphController::getNode(const QString& uuid)
{
    Node* node = findNode(uuid);
    if (!node) {
        return QVariantMap();
    }
    
    return nodeToVariant(node);
}

QVariantList GraphController::getNodes()
{
    QVariantList nodes;
    
    if (!m_scene) {
        return nodes;
    }
    
    const auto& nodeMap = m_scene->getNodes();
    for (Node* node : nodeMap.values()) {
        nodes.append(nodeToVariant(node));
    }
    
    return nodes;
}

QString GraphController::connect(const QString& fromNodeId, int fromIndex, 
                                const QString& toNodeId, int toIndex)
{
    if (!m_scene || !m_factory) {
        emit error("GraphController: Scene or factory not initialized");
        return QString();
    }
    
    Node* fromNode = findNode(fromNodeId);
    Node* toNode = findNode(toNodeId);
    
    if (!fromNode || !toNode) {
        emit error(QString("GraphController: Node not found for connection: %1 -> %2")
                  .arg(fromNodeId).arg(toNodeId));
        return QString();
    }
    
    qDebug() << "GraphController: Connecting" << fromNodeId << "[" << fromIndex << "] ->" 
             << toNodeId << "[" << toIndex << "]";
    
    try {
        // Find the appropriate sockets
        Socket* fromSocket = nullptr;
        Socket* toSocket = nullptr;
        
        // Get child sockets from nodes
        const auto& fromItems = fromNode->childItems();
        const auto& toItems = toNode->childItems();
        
        for (QGraphicsItem* item : fromItems) {
            if (Socket* socket = qgraphicsitem_cast<Socket*>(item)) {
                if (socket->getIndex() == fromIndex && socket->getRole() == Socket::Output) {
                    fromSocket = socket;
                    break;
                }
            }
        }
        
        for (QGraphicsItem* item : toItems) {
            if (Socket* socket = qgraphicsitem_cast<Socket*>(item)) {
                if (socket->getIndex() == toIndex && socket->getRole() == Socket::Input) {
                    toSocket = socket;
                    break;
                }
            }
        }
        
        if (!fromSocket || !toSocket) {
            emit error(QString("GraphController: Socket not found for connection"));
            return QString();
        }
        
        Edge* edge = m_factory->createEdge(fromNode, fromIndex, toNode, toIndex);
        if (edge) {
            QString uuid = edge->getId().toString();
            emit edgeCreated(uuid);
            qDebug() << "GraphController: Created edge" << uuid;
            return uuid;
        }
    } catch (const std::exception& e) {
        emit error(QString("GraphController: Error creating connection: %1").arg(e.what()));
    }
    
    return QString();
}

bool GraphController::deleteEdge(const QString& uuid)
{
    if (!m_scene) {
        emit error("GraphController: Scene not initialized");
        return false;
    }
    
    Edge* edge = findEdge(uuid);
    if (!edge) {
        emit error(QString("GraphController: Edge not found: %1").arg(uuid));
        return false;
    }
    
    qDebug() << "GraphController: Deleting edge" << uuid;
    
    try {
        QUuid edgeId = QUuid::fromString(uuid);
        m_scene->deleteEdge(edgeId);
        emit edgeDeleted(uuid);
        return true;
    } catch (const std::exception& e) {
        emit error(QString("GraphController: Error deleting edge: %1").arg(e.what()));
        return false;
    }
}

QVariantList GraphController::getEdges()
{
    QVariantList edges;
    
    if (!m_scene) {
        return edges;
    }
    
    const auto& edgeMap = m_scene->getEdges();
    for (Edge* edge : edgeMap.values()) {
        edges.append(edgeToVariant(edge));
    }
    
    return edges;
}

void GraphController::clear()
{
    if (!m_scene) {
        emit error("GraphController: Scene not initialized");
        return;
    }
    
    qDebug() << "GraphController: Clearing graph";
    
    m_scene->clearGraph();
    emit graphCleared();
}

void GraphController::saveXml(const QString& path)
{
    if (!m_scene) {
        emit error("GraphController: Scene not initialized");
        return;
    }
    
    qDebug() << "GraphController: Saving XML to" << path;
    
    try {
        // Create XML document
        xmlDocPtr doc = xmlNewDoc(BAD_CAST "1.0");
        xmlNodePtr root = xmlNewNode(NULL, BAD_CAST "graph");
        xmlDocSetRootElement(doc, root);
        xmlNewProp(root, BAD_CAST "version", BAD_CAST "1.0");
        
        // Add nodes
        const auto& nodes = m_scene->getNodes();
        for (Node* node : nodes.values()) {
            node->write(doc, root);
        }
        
        // Add edges
        const auto& edges = m_scene->getEdges();
        for (Edge* edge : edges.values()) {
            edge->write(doc, root);
        }
        
        // Save to file
        int result = xmlSaveFileEnc(path.toUtf8().constData(), doc, "UTF-8");
        xmlFreeDoc(doc);
        
        if (result != -1) {
            emit xmlSaved(path);
            qDebug() << "GraphController: XML saved successfully";
        } else {
            emit error(QString("GraphController: Failed to save XML to %1").arg(path));
        }
    } catch (const std::exception& e) {
        emit error(QString("GraphController: Error saving XML: %1").arg(e.what()));
    }
}

void GraphController::loadXml(const QString& path)
{
    if (!m_scene || !m_factory) {
        emit error("GraphController: Scene or factory not initialized");
        return;
    }
    
    qDebug() << "GraphController: Loading XML from" << path;
    
    try {
        // Clear existing graph
        m_scene->clearGraph();
        
        // Parse XML file
        xmlDocPtr doc = xmlParseFile(path.toUtf8().constData());
        if (!doc) {
            emit error(QString("GraphController: Failed to parse XML file: %1").arg(path));
            return;
        }
        
        xmlNodePtr root = xmlDocGetRootElement(doc);
        if (!root) {
            xmlFreeDoc(doc);
            emit error(QString("GraphController: Invalid XML structure in: %1").arg(path));
            return;
        }
        
        // Load nodes and edges through factory
        m_factory->loadFromXmlFile(path);
        
        xmlFreeDoc(doc);
        emit xmlLoaded(path);
        qDebug() << "GraphController: XML loaded successfully";
    } catch (const std::exception& e) {
        emit error(QString("GraphController: Error loading XML: %1").arg(e.what()));
    }
}

void GraphController::rebuildXml()
{
    qDebug() << "GraphController: Rebuilding XML from scene";
    
    // This would trigger XmlLiveSync to rebuild the XML from the current scene state
    // For now, we'll just log the action
    qDebug() << "GraphController: XML rebuild requested";
}

QString GraphController::getXmlString()
{
    if (!m_scene) {
        return QString();
    }
    
    try {
        // Create XML document
        xmlDocPtr doc = xmlNewDoc(BAD_CAST "1.0");
        xmlNodePtr root = xmlNewNode(NULL, BAD_CAST "graph");
        xmlDocSetRootElement(doc, root);
        xmlNewProp(root, BAD_CAST "version", BAD_CAST "1.0");
        
        // Add nodes
        const auto& nodes = m_scene->getNodes();
        for (Node* node : nodes.values()) {
            node->write(doc, root);
        }
        
        // Add edges
        const auto& edges = m_scene->getEdges();
        for (Edge* edge : edges.values()) {
            edge->write(doc, root);
        }
        
        // Convert to string
        xmlChar* xmlStr;
        int size;
        xmlDocDumpFormatMemoryEnc(doc, &xmlStr, &size, "UTF-8", 1);
        
        QString result = QString::fromUtf8(reinterpret_cast<const char*>(xmlStr));
        
        xmlFree(xmlStr);
        xmlFreeDoc(doc);
        
        return result;
    } catch (const std::exception& e) {
        emit error(QString("GraphController: Error generating XML string: %1").arg(e.what()));
        return QString();
    }
}

QVariantMap GraphController::getStats()
{
    QVariantMap stats;
    
    if (!m_scene) {
        stats["nodes"] = 0;
        stats["edges"] = 0;
        return stats;
    }
    
    const auto& nodes = m_scene->getNodes();
    const auto& edges = m_scene->getEdges();
    
    stats["nodes"] = nodes.size();
    stats["edges"] = edges.size();
    
    // Count by node type
    QVariantMap nodeTypes;
    for (Node* node : nodes.values()) {
        QString type = node->getNodeType();
        nodeTypes[type] = nodeTypes[type].toInt() + 1;
    }
    stats["nodeTypes"] = nodeTypes;
    
    return stats;
}

bool GraphController::isValidNodeType(const QString& type)
{
    QStringList registeredTypes = NodeRegistry::instance().getRegisteredTypes();
    bool isValid = registeredTypes.contains(type);
    qDebug() << "GraphController: Type validation:" << type << "→" << (isValid ? "VALID" : "INVALID");
    return isValid;
}

QStringList GraphController::getValidNodeTypes()
{
    QStringList types = NodeRegistry::instance().getRegisteredTypes();
    qDebug() << "GraphController: Available node types:" << types;
    return types;
}

Node* GraphController::findNode(const QString& uuid)
{
    if (!m_scene) {
        return nullptr;
    }
    
    QUuid nodeId = QUuid::fromString(uuid);
    return m_scene->getNode(nodeId);
}

Edge* GraphController::findEdge(const QString& uuid)
{
    if (!m_scene) {
        return nullptr;
    }
    
    QUuid edgeId = QUuid::fromString(uuid);
    return m_scene->getEdge(edgeId);
}

QVariantMap GraphController::nodeToVariant(Node* node)
{
    QVariantMap nodeData;
    
    if (!node) {
        return nodeData;
    }
    
    nodeData["id"] = node->getId().toString();
    nodeData["type"] = node->getNodeType();
    nodeData["x"] = node->pos().x();
    nodeData["y"] = node->pos().y();
    
    // Add node dimensions
    QRectF bounds = node->boundingRect();
    nodeData["width"] = bounds.width();
    nodeData["height"] = bounds.height();
    
    // Add selection state
    nodeData["selected"] = node->isSelected();
    
    // Add socket information with enhanced details
    QVariantList sockets;
    int inputCount = 0;
    int outputCount = 0;
    
    for (QGraphicsItem* item : node->childItems()) {
        if (Socket* socket = qgraphicsitem_cast<Socket*>(item)) {
            QVariantMap socketData;
            socketData["index"] = socket->getIndex();
            socketData["type"] = (socket->getRole() == Socket::Input) ? "input" : "output";
            socketData["connected"] = socket->isConnected();
            
            // Add socket position relative to node
            QPointF socketPos = socket->pos();
            socketData["relativeX"] = socketPos.x();
            socketData["relativeY"] = socketPos.y();
            
            sockets.append(socketData);
            
            if (socket->getRole() == Socket::Input) {
                inputCount++;
            } else {
                outputCount++;
            }
        }
    }
    
    nodeData["sockets"] = sockets;
    nodeData["inputCount"] = inputCount;
    nodeData["outputCount"] = outputCount;
    nodeData["totalSockets"] = sockets.size();
    
    // Add edge connection information
    nodeData["connectedEdges"] = node->getIncidentEdgeCount();
    
    return nodeData;
}

QVariantMap GraphController::edgeToVariant(Edge* edge)
{
    QVariantMap edgeData;
    
    if (!edge) {
        return edgeData;
    }
    
    edgeData["id"] = edge->getId().toString();
    
    // Add connection information
    Socket* fromSocket = edge->getFromSocket();
    Socket* toSocket = edge->getToSocket();
    
    if (fromSocket && toSocket) {
        edgeData["fromNode"] = fromSocket->getParentNode()->getId().toString();
        edgeData["fromIndex"] = fromSocket->getIndex();
        edgeData["toNode"] = toSocket->getParentNode()->getId().toString();
        edgeData["toIndex"] = toSocket->getIndex();
    }
    
    return edgeData;
}

=== window.h ===
#pragma once

#include <QMainWindow>
#include <QString>
#include <QToolBar>
#include <QAction>
#include <QDockWidget>
#include <QLabel>
#include <QStatusBar>
#include <QMenuBar>
#include <QProgressBar>
#include <QSpinBox>
#include <QComboBox>
#include <libxml/tree.h>

class View;
class Scene;
class GraphFactory;
class XmlAutosaveObserver;
class NodePaletteWidget;
// class JavaScriptConsole;  // Disabled for now

/**
 * Window - Enhanced main window for self-serializing node editor
 * 
 * Features:
 * - Professional UI with dock widgets and status bar
 * - Node palette with drag-and-drop functionality
 * - Multi-section status bar with graph statistics
 * - Menu system with proper actions
 * - Integration with self-serializing architecture
 */
class Window : public QMainWindow
{
public:
    explicit Window(QWidget* parent = nullptr);
    ~Window();
    
    // Access to scene for testing
    Scene* getScene() const { return m_scene; }
    
    // Update status bar with current graph information
    void updateStatusBar();
    
    // Create node at specific position (disabled for now)
    // void createNodeAtPosition(const QString& nodeType, const QPointF& scenePos);
    
    // JavaScript test runner
    void runJavaScriptTests();
    
    // Simple script execution
    void loadAndExecuteScript();
    
    // JavaScript test runners
    void runSpecificScript(const QString& filePath);
    void runAllTests();

protected:
    // PHASE 3: Safe shutdown coordination
    void closeEvent(QCloseEvent* event) override;
public slots:
    // Scene event handlers
    void onSceneChanged();
    void onSelectionChanged();
    
    // Basic XML saving functionality
    bool saveGraph(const QString& filename);
    bool loadGraph(const QString& filename);
    
    // File management
    void setCurrentFile(const QString& filename);
    QString getCurrentFile() const { return m_currentFile; }
    
    // Interactive node creation
    void createInputNode();
    void createOutputNode();
    void createProcessorNode();
    
    // Node creation from palette (will be implemented with proper includes)
    void createNodeFromPalette(const QPointF& scenePos, const QString& nodeType, 
                              const QString& name, int inputSockets, int outputSockets);
    
private slots:
    // Menu actions
    void newFile();
    void openFile();
    void saveFile();
    void saveAsFile();
    void exportGraph();
    void showAbout();
    
    // View actions
    void zoomIn();
    void zoomOut();
    void zoomFit();
    void zoomReset();
    
    // Selection info update
    void updateSelectionInfo();
    
    // Palette integration
    void onNodeCreationRequested();
    
protected:
    // Handle keyboard shortcuts
    void keyPressEvent(QKeyEvent* event) override;

private:
    Scene* m_scene;
    View* m_view;
    GraphFactory* m_factory;
    xmlDocPtr m_xmlDocument;
    XmlAutosaveObserver* m_autosaveObserver;
    
    // UI elements
    QAction* m_addInputAction;
    QAction* m_addOutputAction;
    QAction* m_addProcessorAction;
    
    // Professional node palette system
    QDockWidget* m_nodePaletteDock;
    NodePaletteWidget* m_nodePalette;
    
    // JavaScript console (disabled for now)
    // QDockWidget* m_javaScriptConsoleDock;
    // JavaScriptConsole* m_javaScriptConsole;
    
    // Status bar components
    QLabel* m_fileInfoLabel;      // Current file info
    QLabel* m_graphStatsLabel;    // Node/edge count
    QLabel* m_selectionLabel;     // Selection information
    QLabel* m_positionLabel;      // Mouse position
    QLabel* m_zoomLabel;          // Current zoom level
    QProgressBar* m_operationProgress; // For long operations
    
    // Menu system
    QMenu* m_fileMenu;
    QMenu* m_editMenu;
    QMenu* m_viewMenu;
    QMenu* m_toolsMenu;
    QMenu* m_helpMenu;
    
    // File management
    QString m_currentFile;
    
    // Setup methods
    void setupUI();
    void setupMenus();
    void setupActions();
    void setupStatusBar();
    void setupDockWidgets();
    
    // Menu creation helpers
    void createFileMenu();
    void createEditMenu();
    void createViewMenu();
    void createToolsMenu();
    void createHelpMenu();
    
    // Status bar helpers
    void createStatusBarWidgets();
    void connectStatusBarSignals();
};

=== scene.h ===
#pragma once

#include <QGraphicsScene>
#include <QHash>
#include <QUuid>
#include "graph_observer.h"

class Node;
class Edge;
class Socket;
class JavaScriptEngine;
class GhostEdge;

/**
 * Scene - QElectroTech-style typed scene management
 * 
 * Uses QHash collections for O(1) UUID lookups
 * Never use generic items() - always use typed collections
 * Follows QElectroTech/Fritzing patterns for professional node editors
 */
class Scene : public QGraphicsScene, public GraphSubject
{
    Q_OBJECT

signals:
    void sceneChanged();

public:
    explicit Scene(QObject* parent = nullptr);
    
    // Typed item management - QElectroTech style
    void addNode(Node* node);
    void addEdge(Edge* edge);
    void addSocket(Socket* socket);  // Deprecated - sockets managed by nodes
    
    void removeNode(const QUuid& nodeId);
    void removeEdge(const QUuid& edgeId);
    
    // Fast UUID-based lookups O(1) - no searching, no casting
    Node* getNode(const QUuid& nodeId) const;
    Edge* getEdge(const QUuid& edgeId) const;
    
    // Type-safe iteration - never need qgraphicsitem_cast
    const QHash<QUuid, Node*>& getNodes() const { return m_nodes; }
    const QHash<QUuid, Edge*>& getEdges() const { return m_edges; }
    // Clean design: sockets accessed via nodes, not scene
    
    // Deletion methods - maintain integrity
    void deleteNode(const QUuid& nodeId);
    void deleteEdge(const QUuid& edgeId);
    void deleteSelected();  // Delete all selected items
    
    // Clear both graphics items AND registries - prevents dangling pointers
    void clearGraph();
    
    // PHASE 1.2: Safe shutdown preparation
    void prepareForShutdown();
    bool isShutdownInProgress() const { return m_shutdownInProgress; }
    
    // Public observer notifications (for Node movement)
    using GraphSubject::notifyNodeMoved;
    
    // Ghost edge for visual connection feedback (right-click and drag)
    void startGhostEdge(Socket* fromSocket, const QPointF& startPos);
    void updateGhostEdge(const QPointF& currentPos);
    void finishGhostEdge(Socket* toSocket = nullptr);
    void cancelGhostEdge();
    bool ghostEdgeActive() const { return m_ghostEdgeActive; }
    
    // JavaScript engine access
    JavaScriptEngine* getJavaScriptEngine() const { return m_jsEngine; }
    QString executeJavaScript(const QString& script);
    void loadJavaScriptFile(const QString& filePath);
    
    // Critical destruction safety flag
    static bool isClearing() { return s_clearingGraph; }

protected:
    // Mouse event handling for ghost edge interactions
    void mouseMoveEvent(QGraphicsSceneMouseEvent* event) override;
    void mouseReleaseEvent(QGraphicsSceneMouseEvent* event) override;

private:
    // QElectroTech-style typed collections with UUID keys
    QHash<QUuid, Node*> m_nodes;
    QHash<QUuid, Edge*> m_edges;
    QHash<QUuid, Socket*> m_sockets;  // Deprecated - kept for compatibility
    
    // Ghost edge for visual feedback during right-click connection creation
    GhostEdge* m_ghostEdge;
    Socket* m_ghostFromSocket;
    bool m_ghostEdgeActive;
    
    // Helper method for ghost edge styling
    QPen ghostPen() const;
    void resetAllSocketStates();
    
    // Static flag to prevent socket cleanup during clearGraph
    static bool s_clearingGraph;
    
    // Shutdown coordination flag
    bool m_shutdownInProgress;
    
    // JavaScript engine integration
    JavaScriptEngine* m_jsEngine;
};

=== view.h ===
#pragma once

#include <QGraphicsView>
#include <QMouseEvent>
#include <QWheelEvent>
#include <QDragEnterEvent>
#include <QDragMoveEvent>
#include <QDropEvent>

class Scene;

/**
 * View - Custom graphics view for node editor
 * 
 * Simple boilerplate extending QGraphicsView
 * Handles basic mouse and keyboard events
 */
class View : public QGraphicsView
{
    Q_OBJECT

public:
    explicit View(Scene* scene, QWidget* parent = nullptr);

protected:
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void wheelEvent(QWheelEvent* event) override;
    
    // Drag and drop support
    void dragEnterEvent(QDragEnterEvent* event) override;
    void dragMoveEvent(QDragMoveEvent* event) override;
    void dropEvent(QDropEvent* event) override;

signals:
    // Signal emitted when a node is dropped
    void nodeDropped(const QPointF& scenePos, const QString& nodeType, const QString& name, 
                    int inputSockets, int outputSockets);

private:
    Scene* m_scene;
};

=== node.h ===
#pragma once

#include <QGraphicsItem>
#include <QGraphicsScene>
#include <QPainter>
#include <QStyleOptionGraphicsItem>
#include <QWidget>
#include <QUuid>
#include <QPointF>
#include <QString>
#include <QVector>
#include <QRectF>
#include <QSizeF>
#include <QColor>
#include <QSet>
#include <libxml/tree.h>

// Forward declarations to avoid circular includes
class Socket;
class Edge;

/**
 * Node - A self-serializing visual node
 * 
 * Core principles:
 * - Self-serialization via write()/read() methods
 * - Value semantics, no smart pointers
 * - No QObject inheritance or connect usage
 * - Sockets are children of nodes only
 * - Uses Qt containers instead of std library
 */
class Node : public QGraphicsItem
{
public:
    Node(const QUuid& id = QUuid::createUuid(), 
         const QPointF& position = QPointF(100, 100));
    ~Node(); // Destructor for safe edge invalidation
    
    // Core identity
    const QUuid& getId() const { return m_id; }
    
    // Self-serialization interface
    xmlNodePtr write(xmlDocPtr doc, xmlNodePtr repr = nullptr) const;
    virtual void read(xmlNodePtr node);
    
    // QGraphicsItem interface
    QRectF boundingRect() const override;
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) override;
    
    // Movement tracking for live XML updates
    QVariant itemChange(GraphicsItemChange change, const QVariant &value) override;
    
    // Node properties
    void setNodeSize(qreal width, qreal height);
    QSizeF getNodeSize() const { return QSizeF(m_width, m_height); }
    
    // Visual state - using Qt's selection system
    // Use QGraphicsItem::isSelected() and setSelected()
    
    // Socket management - O(1) performance
    Socket* getSocketByIndex(int index) const;
    int getSocketCount() const;
    void setNodeType(const QString& type);
    QString getNodeType() const { return m_nodeType; }
    
    // Socket registration for performance cache
    void registerSocket(Socket* socket, int index);
    
    // XML-driven socket creation
    void createSocketsFromXml(int inputCount, int outputCount);
    
    // ✅ Two-phase positioning: Position all sockets with complete information
    void positionAllSockets(int totalInputs, int totalOutputs);
    
    // Change notification - simple callback, no connect
    void setChangeCallback(void (*callback)(Node*));
    
    // Observer interface for GraphFactory - contract enforcement
    void setObserver(void* observer) { m_observer = observer; }
    bool hasObserver() const { return m_observer != nullptr; }
    void* getObserver() const { return m_observer; }
    
    // Edge connection management - O(degree) performance optimization
    void registerEdge(Edge* edge);
    void unregisterEdge(Edge* edge);
    void updateConnectedEdges();
    
    // Debug/testing helper
    int getIncidentEdgeCount() const { return m_incidentEdges.size(); }

private:
    QUuid m_id;
    QString m_nodeType;
    qreal m_width;
    qreal m_height;
    
    // Performance optimization: cache display string (created once, not every frame)
    mutable QString m_cachedDisplayId;
    
    // Socket cache for O(1) lookups - critical performance fix
    QVector<Socket*> m_sockets;  // Indexed by socket index for O(1) access
    
    // Edge adjacency set for O(degree) edge updates - performance optimization
    QSet<Edge*> m_incidentEdges;  // Edges touching this node (cleaned up by Edge destructor)
    
    // Simple callback - no QObject connect
    void (*m_changeCallback)(Node*);
    
    // Observer for contract enforcement
    void* m_observer;
    
    // Per-node position tracking (fixes global static bug)
    QPointF m_lastPos;
    
    // Dynamic node sizing based on socket count
    void calculateNodeSize(int inputCount, int outputCount);
    
    // Socket creation
    void createStaticSockets();
    
    // Visual styling helpers
    void paintSockets(QPainter* painter) const;
};

=== socket.h ===
#pragma once

#include <QGraphicsItem>
#include <QPainter>
#include <QStyleOptionGraphicsItem>
#include <QWidget>
#include <QGraphicsSceneMouseEvent>
#include <QUuid>
#include <QPointF>
#include <QString>
#include <QColor>
#include <QRectF>
#include <libxml/tree.h>

class Node;
class Edge;

/**
 * Socket - QGraphicsItem connection point on a node
 * 
 * Core principles:
 * - QGraphicsItem child of Node QGraphicsItem
 * - Self-serializing like its parent node
 * - Handles mouse events for connection creation
 * - Position managed by Qt parent-child system
 * - Index-based identification within parent node
 */
class Socket : public QGraphicsItem
{
public:
    enum Role {
        Input,
        Output
    };
    
    enum ConnectionState {
        Disconnected,
        Connecting,    // During ghost edge drag
        Connected,     // Has connected edge
        Highlighted    // Target of ghost edge
    };
    
    // Helper for debugging
    static const char* roleToString(Role role) {
        switch (role) {
            case Input: return "INPUT";
            case Output: return "OUTPUT";
            default: return "UNKNOWN";
        }
    }
    
    Socket(Role role, Node* parentNode, int index);
    
    // Core identity - NO UUID, just index within parent node
    int getIndex() const { return m_index; }
    Role getRole() const { return m_role; }
    // Access parent node via Qt's system  
    Node* getParentNode() const;
    
    // Self-serialization interface
    xmlNodePtr write(xmlDocPtr doc, xmlNodePtr repr = nullptr) const;
    void read(xmlNodePtr node);
    
    // QGraphicsItem interface
    QRectF boundingRect() const override;
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) override;
    
    // Mouse events for connection creation
    void mousePressEvent(QGraphicsSceneMouseEvent *event) override;
    void mouseReleaseEvent(QGraphicsSceneMouseEvent *event) override;
    void hoverEnterEvent(QGraphicsSceneHoverEvent *event) override;
    void hoverLeaveEvent(QGraphicsSceneHoverEvent *event) override;
    
    // Connection state
    bool isConnected() const { return m_connectedEdge != nullptr; }
    void setConnectedEdge(Edge* edge) { m_connectedEdge = edge; updateConnectionState(); }
    Edge* getConnectedEdge() const { return m_connectedEdge; }
    
    // Visual connection state
    ConnectionState getConnectionState() const { return m_connectionState; }
    void setConnectionState(ConnectionState state) { m_connectionState = state; update(); }
    void updateConnectionState() { 
        setConnectionState(m_connectedEdge ? Connected : Disconnected); 
    }
    
    // ✅ Direct position assignment - no calculations, just assignment
    void setDirectPosition(qreal x, qreal y) { setPos(x, y); }
    
    // Size properties for edge connection calculations
    qreal getRadius() const { return m_radius; }
    QSizeF getSocketSize() const { return boundingRect().size(); }
    
    // Visual state for drag-and-drop feedback (disabled)
    // VisualState getVisualState() const { return m_visualState; }
    // void setVisualState(VisualState state) { m_visualState = state; update(); }

private:
    Role m_role;
    int m_index;                 // Socket index within parent node (0, 1, 2...)
    Edge* m_connectedEdge;       // Connected edge (if any)  
    ConnectionState m_connectionState; // Visual connection state
    qreal m_radius;
    bool m_hovered;
    qreal m_hoverOpacity; // Smooth hover opacity transition
    bool m_pressed; // Click feedback state
    
    // Performance optimization: cache index string (created once, not every frame)
    mutable QString m_cachedIndexString;
    
};

=== edge.h ===
#pragma once

#include <QGraphicsItem>
#include <QPainter>
#include <QStyleOptionGraphicsItem>
#include <QWidget>
#include <QUuid>
#include <QString>
#include <QColor>
#include <QPainterPath>
#include <QPainterPathStroker>
#include <QPointF>
#include <functional>
#include <libxml/tree.h>

class Socket;
class Node;

/**
 * Edge - Connection between two sockets
 * 
 * Core principles:
 * - Self-serializing connection between socket UUIDs
 * - No QObject inheritance or connect usage
 * - Draws path from socket to socket
 * - References sockets by UUID, not pointers
 */
class Edge : public QGraphicsItem
{
public:
    Edge(const QUuid& id = QUuid::createUuid(),
         const QUuid& fromSocketId = QUuid(),
         const QUuid& toSocketId = QUuid());
    ~Edge(); // Destructor for node unregistration
    
    // Core identity
    const QUuid& getId() const { return m_id; }
    
    // Self-serialization interface
    xmlNodePtr write(xmlDocPtr doc, xmlNodePtr repr = nullptr) const;
    void read(xmlNodePtr node);
    
    // QGraphicsItem interface
    QRectF boundingRect() const override;
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) override;
    QPainterPath shape() const override;
    QVariant itemChange(GraphicsItemChange change, const QVariant &value) override;
    
    // Connection management - clean design uses node+index only
    // No socket UUIDs - edges resolved via resolveConnections() method
    
    // Visual state uses Qt's selection system
    // Use QGraphicsItem::isSelected() and setSelected()
    
    // Path update - call when socket positions change
    void updatePath();
    
    // Mouse event debugging and interaction
    void mousePressEvent(QGraphicsSceneMouseEvent *event) override;
    void mouseReleaseEvent(QGraphicsSceneMouseEvent *event) override;
    void hoverEnterEvent(QGraphicsSceneHoverEvent *event) override;
    void hoverLeaveEvent(QGraphicsSceneHoverEvent *event) override;
    
    // Connection checking
    bool isConnectedToNode(const QString& nodeId) const;
    bool isConnectedToNode(const QUuid& nodeId) const;  // Optimized UUID version
    
    // Socket resolution after all nodes are loaded
    bool resolveConnections(class Scene* scene);
    
    // Direct connection methods (optimization for GraphFactory)
    void setConnectionData(const QString& fromNodeId, const QString& toNodeId, 
                          int fromSocketIndex, int toSocketIndex);
    void setResolvedSockets(Socket* fromSocket, Socket* toSocket);
    
    // Manual weak pointer system for safe destruction
    void invalidateNode(const Node* node);
    
    // Public accessors for layout engine
    Node* getFromNode() const { return m_fromNode; }
    Node* getToNode() const { return m_toNode; }
    Socket* getFromSocket() const { return m_fromSocket; }
    Socket* getToSocket() const { return m_toSocket; }

private:
    QUuid m_id;
    QString m_fromNodeId;     // Store node IDs from XML (for serialization)
    QString m_toNodeId;
    QUuid m_fromNodeUuid;     // Cached UUIDs for fast comparison
    QUuid m_toNodeUuid;
    int m_fromSocketIndex;    // Store socket indices from XML
    int m_toSocketIndex;
    Socket* m_fromSocket;     // Resolved socket pointers
    Socket* m_toSocket;
    
    // Manual weak pointers for safe destruction (nulled by Node::~Node)
    Node* m_fromNode;         // Source node (may be nullptr during destruction)
    Node* m_toNode;           // Destination node (may be nullptr during destruction)
    
    // Cached path for rendering
    QPainterPath m_path;
    QRectF m_boundingRect;
    
    // Interaction state
    bool m_hovered;
    
    #ifdef QT_DEBUG
    // Per-edge debug counter (thread-safe, per-instance)
    mutable int m_shapeCallCount;
    #endif
    
    // Visual styling
    void buildPath(const QPointF& start, const QPointF& end);
};

=== graph_factory.h ===
#pragma once

#include <QGraphicsScene>
#include <QUuid>
#include <QString>
#include <QPointF>
#include <QDebug>
#include <libxml/tree.h>
#include "socket.h"

class Node;
class Edge;

/**
 * GraphFactory - XML-First Object Creation with NodeRegistry
 * 
 * Simplified factory that uses NodeRegistry for type-based creation.
 * Enforces XML-first discipline while allowing extensible node types.
 */
class GraphFactory
{
public:
    // Initialize factory with scene and XML document
    GraphFactory(QGraphicsScene* scene, xmlDocPtr xmlDoc);
    
    // XML-first creation methods
    Node* createNodeFromXml(xmlNodePtr xmlNode);
    Edge* createEdgeFromXml(xmlNodePtr xmlEdge);
    
    // Runtime creation (creates XML first, then objects)
    Node* createNode(const QString& nodeType, const QPointF& position, int inputs = 1, int outputs = 1);
    Edge* createEdge(Node* fromNode, int fromSocketIndex, Node* toNode, int toSocketIndex);
    
    // Atomic edge connection - enforces proper edge creation
    Edge* connectSockets(Socket* fromSocket, Socket* toSocket);
    
    // Post-load validation
    bool validateGraphIntegrity() const;
    
    // XML file loading
    bool loadFromXmlFile(const QString& filePath);
    
    // Clean design: socket resolution handled by edges internally
    
    // Socket factory method - prevents manual socket creation
    Socket* createSocket(Socket::Role role, Node* parentNode, int index);
    
    // Utility to get XML property
    static QString getXmlProperty(xmlNodePtr node, const QString& name);

private:
    QGraphicsScene* m_scene;
    xmlDocPtr m_xmlDocument;
    
    // Helper methods
    xmlNodePtr createXmlNode(const QString& nodeType, const QPointF& position, int inputs = 1, int outputs = 1);
    xmlNodePtr createXmlEdgeNodeIndex(const QUuid& fromNodeId, int fromSocketIndex, const QUuid& toNodeId, int toSocketIndex);
    
    // Get nodes/edges parent elements in XML
    xmlNodePtr getNodesElement();
    xmlNodePtr getEdgesElement();
};

=== node_registry.h ===
#pragma once

#include <QString>
#include <QMap>
#include <functional>

class Node;

/**
 * NodeRegistry - Factory registry for node types
 * 
 * Allows registering node types by string name and creating instances
 * without the factory knowing about concrete types.
 * 
 * Usage:
 *   NodeRegistry::instance().registerNode("SOURCE", []() { return new SourceNode(); });
 *   Node* node = NodeRegistry::instance().createNode("SOURCE");
 */

using NodeFactoryFunction = std::function<Node*()>;

class NodeRegistry
{
public:
    // Singleton instance
    static NodeRegistry& instance();
    
    // Register a node type with its factory function
    void registerNode(const QString& typeName, NodeFactoryFunction factory);
    
    // Create a node instance by type name
    Node* createNode(const QString& typeName) const;
    
    // Check if a type is registered
    bool isRegistered(const QString& typeName) const;
    
    // Get all registered type names
    QStringList getRegisteredTypes() const;
    
    // Clear all registrations (for testing)
    void clear();

private:
    NodeRegistry() = default;
    NodeRegistry(const NodeRegistry&) = delete;
    NodeRegistry& operator=(const NodeRegistry&) = delete;
    
    QMap<QString, NodeFactoryFunction> m_factories;
};

/**
 * Convenience macro for registering node types
 * Use this in the .cpp file of each node type:
 * 
 * REGISTER_NODE_TYPE("SOURCE", SourceNode)
 */
#define REGISTER_NODE_TYPE(typeName, className) \
    namespace { \
        struct Register##className { \
            Register##className() { \
                NodeRegistry::instance().registerNode(typeName, []() { \
                    return new className(); \
                }); \
            } \
        }; \
        static Register##className register##className##Instance; \
    }


=== javascript_engine.h ===
#pragma once

#include <QJSEngine>
#include <QJSValue>
#include <QObject>
#include <QString>
#include <QVariant>
#include <QDebug>

class Node;
class Edge;
class Scene;
class GraphController;
class GraphFactory;

/**
 * JavaScriptEngine - Modern JavaScript integration for NodeGraph
 * 
 * Provides QJSEngine integration for:
 * - Node scripting and behavior logic
 * - Graph processing algorithms
 * - Custom node types in JavaScript
 * - Real-time graph operations
 */
class JavaScriptEngine : public QObject
{
    Q_OBJECT

public:
    explicit JavaScriptEngine(QObject* parent = nullptr);
    ~JavaScriptEngine();

    // JavaScript execution
    QJSValue evaluate(const QString& script);
    QJSValue evaluateFile(const QString& filePath);
    
    // API registration
    void registerNodeAPI(Scene* scene);
    void registerGraphAPI();
    void registerGraphController(Scene* scene, GraphFactory* factory);
    
    // Node scripting support
    QJSValue createNodeScript(const QString& nodeType, const QString& script);
    bool executeNodeScript(Node* node, const QString& script, const QVariantMap& inputs = QVariantMap());
    
    // Graph processing
    QJSValue processGraph(const QString& algorithm, const QVariantMap& parameters = QVariantMap());
    
    // Utility methods
    bool hasErrors() const;
    QString getLastError() const;
    void clearErrors();
    
    // Engine information
    QString getEngineInfo() const;
    void logEngineCapabilities() const;
    
    // Script management
    void loadScriptModule(const QString& moduleName, const QString& scriptContent);
    QJSValue getModule(const QString& moduleName);

signals:
    void scriptExecuted(const QString& script, const QJSValue& result);
    void scriptError(const QString& error);
    void nodeScriptChanged(const QString& nodeId, const QString& script);

public slots:
    // Console API callbacks
    void qt_console_log(const QString& message);
    void qt_console_error(const QString& message);

private slots:
    void handleJavaScriptException(const QJSValue& exception);

private:
    void setupGlobalAPI();
    void registerConsoleAPI();
    void registerUtilityAPI();
    void loadEnhancedAPIs();
    
    QJSValue nodeToJSValue(Node* node);
    QJSValue edgeToJSValue(Edge* edge);
    
    QJSEngine* m_engine;
    Scene* m_scene;
    GraphController* m_graphController;
    QString m_lastError;
    QMap<QString, QJSValue> m_scriptModules;
};

=== graph_controller.h ===
#pragma once

#include <QObject>
#include <QString>
#include <QVariantMap>
#include <QUuid>

class Scene;
class GraphFactory;
class XmlLiveSync;
class Node;
class Edge;

/**
 * GraphController - JavaScript-accessible graph control interface
 * 
 * Provides runtime control over the node graph system via JavaScript:
 * - Create/delete nodes and edges
 * - Save/load XML 
 * - Query graph statistics
 * - Trigger XML synchronization
 * 
 * This class is exposed to QJSEngine as the "Graph" global object
 */
class GraphController : public QObject
{
    Q_OBJECT

public:
    explicit GraphController(Scene* scene, GraphFactory* factory, QObject* parent = nullptr);
    ~GraphController() = default;

public slots:
    // Node operations
    QString createNode(const QString& type, qreal x, qreal y);
    bool deleteNode(const QString& uuid);
    bool moveNode(const QString& uuid, qreal dx, qreal dy);
    QVariantMap getNode(const QString& uuid);
    QVariantList getNodes();
    
    // Edge operations  
    QString connect(const QString& fromNodeId, int fromIndex, 
                   const QString& toNodeId, int toIndex);
    bool deleteEdge(const QString& uuid);
    QVariantList getEdges();
    
    // Graph-wide operations
    void clear();
    void saveXml(const QString& path);
    void loadXml(const QString& path);
    void rebuildXml();
    QString getXmlString();
    QVariantMap getStats();
    
    // Utility functions
    bool isValidNodeType(const QString& type);
    QStringList getValidNodeTypes();
    
signals:
    void nodeCreated(const QString& uuid);
    void nodeDeleted(const QString& uuid);
    void edgeCreated(const QString& uuid);
    void edgeDeleted(const QString& uuid);
    void graphCleared();
    void xmlSaved(const QString& path);
    void xmlLoaded(const QString& path);
    void error(const QString& message);

private:
    Scene* m_scene;
    GraphFactory* m_factory;
    
    // Helper methods
    Node* findNode(const QString& uuid);
    Edge* findEdge(const QString& uuid);
    QVariantMap nodeToVariant(Node* node);
    QVariantMap edgeToVariant(Edge* edge);
};

